[glossary]
[[glossary]]
== Glosario.

Este glosario rápido contiene muchos de los términos utilizados en relación con Bitcoin y la Lightning Network. Estos términos se utilizan a lo largo del libro, así que marque esto para una referencia rápida.

dirección (address)::
    Las direcciones de Bitcoin codifican de forma compacta la información necesaria para pagar a un receptor. Una dirección moderna consiste en una cadena de letras y números que comienza con bc1 y se parece a +bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4+. Una dirección es la abreviatura de un script de bloqueo del receptor, que puede ser utilizado por un remitente para firmar sobre los fondos al receptor. La mayoría de las direcciones representan la clave pública del receptor o alguna forma de script que define condiciones de gasto más complejas. El ejemplo anterior es una dirección bech32 que codifica un programa testigo que bloquea los fondos al hash de una clave pública (Ver _Pay-to-Witness-Public-Key-Hash_). También hay formatos de dirección más antiguos que empiezan por 1 o 3 que utilizan la codificación de direcciones Base58Check para representar hashes de clave pública o hashes de script.


sistema criptográfico asimétrico (asymmetric cryptographic system)::
    La criptografía asimétrica, o criptografía de clave pública, es un sistema criptográfico que utiliza pares de claves: claves públicas que pueden difundirse ampliamente y claves privadas que sólo conoce el propietario.
    La generación de estas claves depende de algoritmos criptográficos basados en problemas matemáticos para producir funciones que son fáciles de resolver en un sentido, pero muy difíciles de resolver en sentido inverso.
    La seguridad efectiva sólo requiere mantener la clave privada; la clave pública puede distribuirse abiertamente sin comprometer la seguridad.

piloto automático (autopilot)::
    Un autopilot es un motor de recomendación para los nodos Lightning que utiliza las estadísticas de la topología de la red para sugerir con qué nodos deberían abrirse canales.
    Dependiendo de la implementación del autopilot, también se puede recomendar la capacidad del canal.
    El autopilot no forma parte del Protocolo LN.

saldo (balance)::
    El balance de un payment channel es la cantidad de bitcoin que pertenece a cada socio del canal.
    Por ejemplo, Alice podría abrir un canal con Bob por el valor de 1 BTC.
    El balance del canal es entonces de 1 BTC para Alice y 0 BTC para Bob.
    A medida que los usuarios realizan transacciones, el balance del canal se actualiza.
    Por ejemplo, si Alice envía 0,2 BTC a Bob, el balance es ahora de 0,8 BTC para Alice y 0,2 para Bob.
    Cuando el canal se cierra, el bitcoin en el canal se dividirá entre los dos socios según el último balance codificado en la commitment transaction.
    En la Lightning Network, la capacidad de enviar y recibir pagos está limitada por el balance del canal.
    Véase _capacidad_.

bech32::
    bech32 se refiere a un formato genérico codificado en base32 con suma de comprobación que presenta fuertes garantías de detección de errores. Aunque bech32 se desarrolló originalmente para ser utilizado como formato de dirección para las salidas nativas de SegWit (BIP-173), también se utiliza para codificar facturas de rayos (BOLT #11). Mientras que las salidas nativas de SegWit versión 0 (P2WPKH y P2WSH) utilizan bech32, las versiones de salida nativas superiores de SegWit (por ejemplo, Pay-to-Taproot o P2TR) utilizan la variante mejorada bech32m (BIP-350). Las direcciones bech32m se denominan a veces direcciones "bc1", reflejando el prefijo de dichas direcciones. Las salidas nativas de SegWit son más eficientes en cuanto a espacio de bloques que las direcciones más antiguas y, por lo tanto, pueden reducir las tasas de transacción para el propietario de dicha dirección.

propuesta de mejora de Bitcoin (Bitcoin Improvement Proposal (BIP))::
    Una propuesta que los miembros de la comunidad Bitcoin han presentado para mejorar Bitcoin. Por ejemplo, la BIP-21 es una propuesta para mejorar el esquema del identificador uniforme de recursos (URI) de Bitcoin. Las BIPs pueden encontrarse en https://github.com/bitcoin/bips[GitHub].

bitcoin, Bitcoin::
    Dependiendo del contexto, puede referirse al nombre de la unidad monetaria (la moneda), la red o el protocolo subyacente. Escrito como bitcoin con "b" minúscula suele referirse a la unidad monetaria. Bitcoin con "B" mayúscula suele referirse al protocolo o sistema.

minería de Bitcoin (Bitcoin mining)::
    La minería de Bitcoin es el proceso de construir un bloque a partir de transacciones recientes de Bitcoin y luego resolver un problema computacional requerido como prueba de trabajo.
    Es el proceso por el cual el libro de contabilidad compartido de Bitcoin (es decir, la blockchain de Bitcoin) se actualiza y por el cual las nuevas transacciones se incluyen en el libro de contabilidad.
    También es el proceso por el que se emiten nuevos bitcoins.
    Cada vez que se crea un nuevo bloque, el nodo de minería recibirá nuevos bitcoin creados dentro de la transacción de coinbase de ese bloque. 

bloque (block)::
    Un bloque es una estructura de datos en la blockchain de Bitcoin que consiste en una cabecera y un cuerpo de transacciones de Bitcoin.
    El bloque está marcado con una marca de tiempo y se compromete con un bloque predecesor (padre) específico.
    Cuando se hace hash, la cabecera del bloque proporciona la prueba de trabajo que hace que la blockchain sea probabilísticamente inmutable.
    Los bloques deben adherirse a las reglas impuestas por el consenso de la red para ampliar la blockchain.
    Cuando se añade un bloque a la blockchain, se considera que las transacciones incluidas tienen su primera confirmación.

blockchain::
    El blockchain es un registro distribuido, o base de datos, de todas las transacciones de Bitcoin.
    Las transacciones se agrupan en actualizaciones discretas llamadas bloques, limitadas a 4 millones de unidades de peso.
    Los bloques se producen aproximadamente cada 10 minutos mediante un proceso estocástico llamado minería.
    Cada bloque incluye una "prueba de trabajo" computacionalmente intensiva.
    El requisito de la prueba de trabajo se utiliza para regular los intervalos de los bloques y proteger la blockchain contra ataques para reescribir la historia:
    un atacante necesitaría superar la prueba de trabajo existente para reemplazar los bloques ya publicados, haciendo que cada bloque sea probabilísticamente inmutable al quedar enterrado bajo los bloques posteriores.

BOLT::
    BOLT, o Basis of Lightning Technology, es la especificación formal de la Lightning Network. A diferencia de Bitcoin, que tiene una implementación de referencia que también sirve como especificación del protocolo, las distintas implementaciones de LN siguen BOLT para poder trabajar entre sí y formar la misma red. Está disponible en https://github.com/lightningnetwork/lightning-rfc[GitHub].

capacity::
    La capacidad de un payment channel es equivalente a la cantidad de bitcoin aportada por la funding transaction.
    Como la funding transaction es visible públicamente en la blockchain, y el canal se anuncia a través del gossip protocol, la capacidad es información pública.
    No revela ninguna información sobre la cantidad de bitcoin que posee cada uno de los socios del canal, es decir, el balance.
    Una alta capacidad no garantiza que el canal pueda utilizarse para el enrutamiento en ambas direcciones.

c-lightning::
    Implementación del Protocolo LN por la empresa de Victoria https://blockstream.com[Blockstream]. Está escrito en C. El código fuente está en https://github.com/ElementsProject/lightning[GitHub].

closing transaction::
    Si ambos socios del canal acuerdan cerrar un canal, crearán una transacción de liquidación que refleje la commitment transaction más reciente.
    Después de intercambiar las firmas para una transacción de cierre, no se deben hacer más actualizaciones del canal.
    El cierre mutuo de un canal con la ayuda de una transacción de cierre tiene la ventaja de que se requieren menos transacciones de blockchain para reclamar todos los fondos, en comparación con forzar unilateralmente el cierre de un canal mediante la publicación de una commitment transaction. Además, los fondos para ambas partes son inmediatamente gastables desde una transacción de cierre.

CLTV::
    CLTV es un acrónimo/abreviatura del operador de Bitcoin Script OP_CHECKLOCKTIMEVERIFY. Esto define una altura de bloque absoluta antes de que una salida pueda ser gastada. La atomicidad del proceso de enrutamiento depende en gran medida de los valores de CLTV en los HTLC. Los nodos de enrutamiento anuncian, a través del gossip protocol, sus deltas de expiración de CLTV esperados que desean para cualquier HTLC entrante y saliente.

coinbase::
    El coinbase es un campo especial que sólo se permite en la única entrada de transacciones de coinbase.
    El coinbase permite hasta 100 bytes de datos arbitrarios, pero desde el BIP-34, debe presentar primero la altura del bloque actual para garantizar que las transacciones coinbase sean únicas.
    No debe confundirse con la transacción coinbase.

transacción coinbase::
    La primera transacción de un bloque que siempre es creada por un minero y que incluye una única coinbase.
    La transacción coinbase puede reclamar la recompensa del bloque y asignarla a una o más salidas.
    La recompensa del bloque consiste en la subvención del bloque (bitcoin recién creado) y la suma de todas las comisiones de las transacciones incluidas en el bloque.
    Las salidas de Coinbase sólo pueden gastarse después de madurar durante 100 bloques.
    Si el bloque incluye alguna transacción SegWit, la transacción de Coinbase debe incluir un compromiso con los identificadores de transacción de los testigos en una salida adicional.

almacenamiento en frío (cold storage)::
    Se refiere a mantener una cantidad de bitcoin fuera de línea. El cold storage se consigue cuando las claves privadas de Bitcoin se crean y almacenan en un entorno seguro fuera de línea. El cold storage es importante para proteger las posesiones de bitcoin. Los ordenadores en línea son vulnerables a los hackers y no deberían utilizarse para almacenar una cantidad significativa de bitcoin.
 

commitment transaction::
    Una commitment transaction es una transacción de Bitcoin, firmada por ambos socios del canal, que codifica el último balance de un canal.
    Cada vez que un nuevo pago es realizado o reenviado usando el canal, el balance del canal se actualizará, y una nueva commitment transaction será firmada por ambas partes.
    Es importante destacar que en un canal entre Alice y Bob, tanto Alice como Bob mantienen su propia versión de la commitment transaction, que también está firmada por la otra parte.
    En cualquier momento, el canal puede ser cerrado por Alice o Bob si envían su commitment transaction a la blockchain de Bitcoin.
    Presentar una commitment transaction más antigua (obsoleta) se considera _cheating_ (es decir, una violación del protocolo) en la Lightning Network y puede ser penalizada por la otra parte, reclamando todos los fondos del canal para sí misma, a través de una transacción de penalización.

confirmations::
    Una vez que una transacción se incluye en un bloque, tiene una confirmación. En cuanto se mina otro bloque en la blockchain, la transacción tiene dos confirmaciones, y así sucesivamente. Seis o más confirmaciones se consideran prueba suficiente de que una transacción no puede ser revertida.

contract::
    Un contrato es un conjunto de transacciones de Bitcoin que juntas dan como resultado un determinado comportamiento deseado.
    Algunos ejemplos son los RSMC para crear un payment channel bidireccional sin confianza, o los HTLC para crear un mecanismo que permita el reenvío de pagos sin confianza a través de terceros.

Intercambio de claves Diffie-Hellman (Diffie–Hellman Key Exchange (DHKE))::
    En la Lightning Network se utiliza el método Diffie-Hellman de curva elíptica (ECDH).
    Se trata de un protocolo de acuerdo de claves anónimas que permite a dos partes, cada una con un par de claves públicas y privadas de curva elíptica, establecer un secreto compartido a través de un canal de comunicación inseguro.
    Este secreto compartido puede utilizarse directamente como clave o para derivar otra clave.
    La clave, o la clave derivada, puede utilizarse entonces para cifrar las comunicaciones posteriores utilizando un cifrado de clave simétrica.
    Un ejemplo de la clave derivada sería el secreto compartido entre la clave de sesión efímera de un remitente de una cebolla con la clave pública del nodo de un salto de la cebolla, tal y como se describe y utiliza el formato de mezcla SPHINX.

firma digital (digital signature)::
    Una firma digital es un esquema matemático para verificar la autenticidad e integridad de mensajes o documentos digitales.
    Puede considerarse como un compromiso criptográfico en el que el mensaje no se oculta.

doble gasto (double-spending)::
    El double-spending es el resultado de gastar con éxito algún dinero más de una vez.
    Bitcoin protege contra el double-spending verificando que cada transacción añadida a la blockchain se adhiere a las reglas del consenso; esto significa comprobar que las entradas para la transacción no han sido gastadas previamente.

Algoritmo de firma digital de curva elíptica (Elliptic Curve Digital Signature Algorithm (ECDSA))::
    El Algoritmo de Firma Digital de Curva Elíptica o ECDSA es un algoritmo criptográfico utilizado por Bitcoin para asegurar que los fondos sólo pueden ser gastados por el titular de la clave privada correcta.

Eclair::
    Implementación del Protocolo LN por la empresa con sede en París https://acinq.co[ACINQ]. Está escrito en Scala. El código fuente está en https://github.com/ACINQ/eclair[GitHub].

codificación (encoding)::
    La codificación es el proceso de convertir un mensaje en una forma diferente. Por ejemplo, convertir un número de decimal a hexadecimal.

Servidor de Electrum (Electrum server)::
    Un servidor de Electrum es un nodo de Bitcoin con una interfaz adicional (API). A menudo es requerido por los monederos de bitcoin que no ejecutan un nodo completo. Por ejemplo, estos monederos comprueban el estado de transacciones específicas o transmiten transacciones al mempool utilizando las API del servidor Electrum. Algunos monederos Lightning también utilizan servidores Electrum.

clave efímera (ephemeral key)::
    Las claves efímeras son claves que sólo se utilizan durante un corto período de tiempo y no se conservan después de su uso. A menudo se derivan para su uso en una sesión de otra clave que se mantiene a largo plazo. Las claves efímeras se utilizan principalmente en el formato mixto de SPHINX y en el enrutamiento de cebolla en la Lightning Network.
    Esto aumenta la seguridad de los mensajes o pagos transportados.
    Aunque una ephemeral key se filtre, sólo se hace pública la información de una única sesión.

feature bits::
    Una cadena binaria que los nodos Lightning utilizan para comunicarse entre sí las características que soportan.
    Los bits de características se incluyen en muchos mensajes Lightning, así como en BOLT #11.
    Pueden descodificarse utilizando BOLT #9, e indicarán a los nodos qué características ha habilitado el nodo, y si son compatibles con versiones anteriores.
    También se conocen como banderas de características. 

tarifas (fees)::
    En el contexto de la Red Relámpago, los nodos cobrarán tasas de enrutamiento por reenviar los pagos de otros usuarios.
    Los nodos individuales pueden establecer sus propias políticas de fees, que se calcularán como la suma de una +tarifa base+ fija y una +tarifa+ que depende del importe del pago.
    En el contexto de Bitcoin, el remitente de una transacción paga una tasa de transacción a los mineros por incluir la transacción en un bloque.
    Las tasas de transacción de Bitcoin no incluyen una tasa base y dependen linealmente del peso de la transacción, pero no del importe.

ftransacción de financiación (funding transaction)::
    La funding transaction se utiliza para abrir un payment channel. El valor (en bitcoin) de la funding transaction es exactamente la capacidad del payment channel.
    El resultado de la funding transaction es una secuencia de comandos de dos firmas (multisig) en la que cada socio del canal controla una clave. Debido a su naturaleza multisig, sólo puede gastarse de mutuo acuerdo entre los socios del canal.
    Se gastará finalmente por una de las transacciones de compromiso o por la transacción de cierre.

características globales (global features (+globalfeatures+ field))::
    Las características globales de un nodo Rayo son las características de interés para todos los demás nodos.
    Lo más habitual es que estén relacionadas con los formatos de enrutamiento soportados.
    Se anuncian en el mensaje `init` del protocolo peer, así como en los mensajes `channel_announcement` y `node_announcement` del protocolo gossip.

protocolo de cotilleo (gossip protocol)::
    Los nodos LN envían y reciben información sobre la topología de la Lightning Network a través de mensajes de cotilleo que se intercambian con sus pares.
    El gossip protocol se define principalmente en BOLT #7 y define el formato de los mensajes `node_announcement`, `channel_announcement` y `channel_update`.
    Para evitar el spam, los mensajes de anuncio de nodo sólo se reenviarán si el nodo ya tiene un canal, y los mensajes de anuncio de canal sólo se reenviarán si la funding transaction del canal ha sido confirmada por la red Bitcoin.
    Normalmente, los nodos Lightning se conectan con sus socios de canal, pero está bien conectarse con cualquier otro nodo Lightning para procesar los mensajes de cotilleo.

hardware wallet::
    Un hardware wallet es un tipo especial de monedero Bitcoin que almacena las claves privadas del usuario en un dispositivo hardware seguro.
    En el momento de escribir el libro, los monederos de hardware no están disponibles para los nodos LN porque las claves utilizadas por Lightning necesitan estar en línea para participar en el protocolo.

hash::
    Una huella digital de tamaño fijo de una entrada binaria de longitud arbitraria. También se conoce como _digest_.

Código de autenticación de mensajes basado en hash (hash-based message authentication code (HMAC))::
    HMAC es un algoritmo para verificar la integridad y autenticidad de un mensaje basado en una función hash y una clave criptográfica.
    Se utiliza en el enrutamiento de cebolla para garantizar la integridad de un paquete en cada salto, así como dentro de la variante del Protocolo de Ruido utilizada para el cifrado de mensajes.

función hash::
    Una función hash criptográfica es un algoritmo matemático que asigna datos de tamaño arbitrario a una cadena de bits de tamaño fijo (un hash) y está diseñada para ser una función unidireccional, es decir, una función que es inviable de invertir.
    La única manera de recrear los datos de entrada a partir de la salida de una función hash criptográfica ideal es intentar una búsqueda por fuerza bruta de las posibles entradas para ver si producen una coincidencia.

hashlock::
    Un hashlock es una condición de gasto del Script de Bitcoin que restringe el gasto de una salida hasta que se revele una pieza específica de datos. Los hashlocks tienen la útil propiedad de que una vez que cualquier hashlock es revelado a través del gasto, cualquier otro hashlock asegurado usando la misma clave también puede ser gastado. Esto hace posible crear múltiples salidas que están todas gravadas por el mismo hashlock y que todas se pueden gastar al mismo tiempo.

contrato con bloqueo temporal de hash (hash time-locked contract (HTLC))::
    Un contrato con bloqueo de tiempo por hash (HTLC) es un Script de Bitcoin que consiste en hashlocks y timelocks para requerir que el receptor de un pago gaste el pago antes de una fecha límite presentando la preimagen de hash o que el remitente pueda reclamar un reembolso después de que el timelock expire.
    En la Lightning Network, los HTLC son salidas en la commitment transaction de un payment channel y se utilizan para permitir el enrutamiento sin confianza de los pagos.

factura (invoice)::
    El proceso de pago en la Lightning Network lo inicia el receptor (beneficiario) que emite una invoice, también conocida como _solicitud de pago_.
    Las facturas incluyen el hash del pago, el importe, una descripción y el tiempo de caducidad. Las facturas relámpago se definen en BOLT #11.
    Las facturas también pueden incluir una dirección Bitcoin de reserva a la que se puede realizar el pago en caso de que no se encuentre ninguna ruta, así como pistas para enrutar un pago a través de un private channel. 

just-in-time (JIT) routing::
   El enrutamiento ust-in-time (JIT) es una alternativa al enrutamiento basado en la fuente que fue propuesto por primera vez por el coautor René Pickhardt.
   Con el enrutamiento JIT, los nodos intermediarios a lo largo de una ruta pueden pausar un pago en vuelo para reequilibrar sus canales antes de proceder al pago.
   Esto podría permitirles reenviar con éxito pagos que, de otro modo, habrían fracasado por falta de capacidad de salida.

Lightning message::
   Un mensaje Lightning es una cadena de datos encriptada que puede enviarse entre dos pares en la Lightning Network. Al igual que otros protocolos de comunicación, los mensajes Lightning constan de una cabecera y un cuerpo. La cabecera y el cuerpo tienen su propio HMAC. Los mensajes Lightning son el principal bloque de construcción de la messaging layer.

Lightning Network, Lightning Network Protocol, Lightning Protocol::
   La Lightning Network es un protocolo sobre Bitcoin (u otras criptomonedas).
   Crea una red de canales de pago que permite el reenvío sin confianza de los pagos a través de la red con la ayuda de HTLCs y onion routing.
   Otros componentes de la Lightning Network son el gossip protocol, la capa de transporte y las solicitudes de pago.

Lightning Network protocol suite::
   El conjunto de protocolos de Lightning Network consta de cinco capas que son responsables de varias partes del protocolo.
   Desde la base (la primera capa) hasta la parte superior (la quinta capa), estas capas se denominan capa de comunicación de red, messaging layer, capa de pares, capa de enrutamiento y capa de pago.
   Varios BOLTs definen partes de una o varias capas.

Nodo de la Lightning Network, nodo Lightning (Lightning Network node, Lightning node)::
    Un ordenador que participa en la Lightning Network, a través del protocolo Lightning peer-to-peer.
    Los nodos Lightning tienen la capacidad de abrir canales con otros nodos, enviar y recibir pagos y enrutar los pagos de otros usuarios.
    Normalmente, un usuario de un nodo Lightning también ejecutará un nodo Bitcoin.

lnd::
    Implementación del protocolo LN por la empresa de San Francisco https://lightning.engineering[Lightning Labs].
    Está escrito en Go. El código fuente está en https://github.com/lightningnetwork/lnd[GitHub].

características locales (local features (field: +localfeatures+))::
    Las características locales de un nodo LN son las características configurables de interés directo para sus compañeros.
    Se anuncian en el mensaje `init` del protocolo peer, así como en los mensajes `channel_announcement` y `node_announcement` del protocolo gossip.

locktime::
    Locktime, o más técnicamente nLockTime, es la parte de una transacción de Bitcoin que indica la hora más temprana o el bloque más temprano en que esa transacción puede ser añadida al blockchain.

capa de mensajería (messaging layer)::
    La messaging layer se construye sobre la capa de conexión de red del conjunto de protocolos de la Lightning Network.
    Es responsable de garantizar una comunicación e intercambio de información cifrados y seguros a través del protocolo de la capa de conexión de red elegido.
    La messaging layer define el encuadre y el formato de los mensajes Lightning, tal y como se define en BOLT #1.
    Los bits de características definidos en BOLT #9 también forman parte de esta capa.


milisatoshi::
    La unidad de cuenta más pequeña de la Lightning Network. Un milisatoshi es la cienmilésima parte de un solo bitcoin. Un milisatoshi es la milésima parte de un satoshi. Los milisatoshis no existen en la red Bitcoin ni pueden liquidarse en ella.

Pagos multiparte (multipart payments (MPP))::
 	Los pagos multiparte (MPP), a menudo también denominados pagos multitrayecto, son un método para dividir el importe del pago en múltiples partes más pequeñas y entregarlas a lo largo de una o más rutas. Dado que el MPP puede enviar muchas o todas las partes por un solo camino, el término pago multiparte es más preciso que el de pago multitrayecto. En informática, los pagos multiparte se modelan como flujos de red.

multifirma (multisignature)::
    Multifirma (multisig) se refiere a una escritura que requiere más de una firma para autorizar el gasto.
    Los canales de pago se codifican siempre como direcciones multifirma que requieren una firma de cada socio del payment channel.
    En el caso estándar de un payment channel de dos partes, se utiliza una dirección multisig de 2 de 2.

nodo (node)::
    Véase _Nodo de la red de rayos_. 

capacidad de la red (network capacity)::
    La capacidad de la LN es la cantidad total de bitcoin bloqueada y que circula dentro de la Lightning Network.
    Es la suma de las capacidades de cada canal público.
    Refleja hasta cierto punto el uso de la Lightning Network porque esperamos que la gente ponga bitcoin en los canales Lightning para gastarlos o reenviar los pagos de otros usuarios.
    Por tanto, cuanto mayor sea la cantidad de bitcoins en los canales Lightning, mayor será el uso esperado de la Lightning Network.
    Hay que tener en cuenta que, dado que sólo se puede observar la capacidad de los canales públicos, se desconoce la verdadera capacidad de la red. Además, como la capacidad de un canal puede permitir un número ilimitado de pagos de ida y vuelta, la capacidad de la red no implica un límite de valor transferido en la Lightning Network.

capa de conexión de la red (network connection layer)::
    La capa más baja del conjunto de protocolos de la Lightning Network.
    Su responsabilidad es soportar protocolos de Internet como IPv4, IPv6, TOR2 y TOR3, y utilizarlos para establecer un canal de comunicación criptográfico seguro, como se define en BOLT #8, o para hablar de DNS para el arranque de la red, como se define en BOLT #10.

Noise_XK::
    La plantilla del marco de protocolo Noise para establecer un canal de comunicación autenticado y cifrado entre dos pares de la Lightning Network.
    X significa que no es necesario que el iniciador de la conexión conozca su clave pública.
    K significa que es necesario conocer la clave pública del receptor.

enrutamiento cebolla (onion routing)::
    El onion routing es una técnica de comunicación anónima a través de una red informática.
    En una red de cebolla, los mensajes se encapsulan en capas de encriptación, análogas a las capas de una cebolla.
    Los datos encriptados se transmiten a través de una serie de nodos de la red denominados enrutadores cebolla, cada uno de los cuales retira una sola capa, descubriendo el siguiente destino de los datos.
    Cuando se descifra la última capa, el mensaje llega a su destino.
    El remitente permanece en el anonimato porque cada intermediario sólo conoce la ubicación de los nodos inmediatamente anteriores y posteriores.

salida (output)::
    La salida de una transacción de Bitcoin, también llamada salida de transacción no gastada (UTXO).
    Una salida es una cantidad indivisible de bitcoin que puede ser gastada, así como una secuencia de comandos que define qué condiciones deben cumplirse para que ese bitcoin sea gastado.
    Cada transacción de bitcoin consume algunas salidas de las transacciones registradas anteriormente y crea nuevas salidas que pueden ser gastadas más tarde por transacciones posteriores.
    Una salida típica de bitcoin requerirá una firma para ser gastada, pero las salidas pueden requerir el cumplimiento de guiones más complejos.
    Por ejemplo, una secuencia de comandos multifirma requiere que dos o más titulares de claves firmen antes de que la salida pueda ser gastada, lo cual es un bloque de construcción fundamental de la Lightning Network.

Pay-to-Public-Key-Hash (P2PKH)::
    P2PKH es un tipo de salida que bloquea bitcoin al hash de una clave pública. Una salida bloqueada por un script P2PKH puede ser desbloqueada (gastada) presentando la clave pública que coincida con el hash y una firma digital creada por la clave privada correspondiente.

Pay-to-Script-Hash (P2SH)::
    P2SH es un tipo de salida versátil que permite el uso de complejos Scripts de Bitcoin. Con P2SH, el script complejo que detalla las condiciones para gastar la salida (script de canje) no se presenta en el script de bloqueo. En su lugar, el valor se bloquea en el hash de un script, que debe ser presentado y cumplido para gastar la salida.

Dirección P2SH (P2SH address)::
    Las direcciones P2SH son codificaciones Base58Check del hash de 20 bytes de un script. Las direcciones P2SH comienzan con un "3". Las direcciones P2SH ocultan toda la complejidad, de modo que el remitente de un pago no ve el script.

Pay-to-Witness-Public-Key-Hash (P2WPKH)::
	P2WPKH es el equivalente SegWit de P2PKH, utilizando un testigo segregado. La firma para gastar una salida P2WPKH se pone en el árbol de testigos en lugar del campo ScriptSig. Véase _SegWit_.

Dirección P2WPKH (P2WPKH address)::
	El formato de dirección "nativo de SegWit v0", las direcciones P2WPKH están codificadas en bech32 y empiezan por "bc1q".

Pay-to-Witness-Script-Hash (P2WSH)::
    P2WSH es el equivalente SegWit de P2SH, utilizando un testigo segregado. La firma y el guión para gastar una salida P2WSH se pone en el árbol de testigos en lugar del campo ScriptSig. Véase _SegWit_.

Dirección P2WSH (P2WSH address)::
	El formato de dirección de script "nativo de Segwi v0", las direcciones P2WSH están codificadas en bech32 y comienzan con "bc1q".

Pay-to-Taproot (P2TR)::
	Activado en noviembre de 2021, Taproot es un nuevo tipo de salida que bloquea bitcoin a un árbol de condiciones de gasto, o a una única condición de raíz.

Dirección P2TR (P2TR address)::
	El formato de la dirección Taproot, que representa SegWit v1, es una dirección codificada en bech32m y comienza con "bc1p".

pago (payment)::
    Un Lightning payment se produce cuando se transfiere bitcoin dentro de la Lightning Network. Los pagos generalmente no se ven en la blockchain de Bitcoin. 

payment channel (payment channel)::
    Un payment channel es una relación financiera entre dos nodos de la Lightning Network, creada mediante una transacción de bitcoin que paga una dirección multifirma.
    Los socios del canal pueden usar el canal para enviar bitcoin de ida y vuelta entre ellos sin comprometer todas las transacciones en la blockchain de Bitcoin.
    En un payment channel típico sólo se añaden a la blockchain dos transacciones, la de financiación y la de compromiso.
    Los pagos enviados a través del canal no se registran en la blockchain y se dice que ocurren "fuera de la cadena".

capa de pago (payment layer)::
    La capa superior y quinta del conjunto de protocolos de Lightning Network opera sobre la capa de enrutamiento.
    Su responsabilidad es habilitar el proceso de pago a través de las facturas BOLT #11.
    Aunque utiliza en gran medida el gráfico de canales del gossip protocol definido en BOLT #7, las estrategias reales para realizar un pago no forman parte de la especificación del protocolo y se dejan a las implementaciones.
    Como este tema es muy importante para garantizar la fiabilidad del proceso de entrega de pagos, lo hemos incluido en este libro.

peer::
    Los participantes en una red peer-to-peer. En la Red Relámpago, los pares se conectan entre sí mediante una comunicación cifrada y autentificada a través de un socket TCP, sobre IP o Tor.

capa peer-to-peer (peer-to-peer layer)::
    La capa peer-to-peer es la tercera capa del conjunto de protocolos de la Lightning Network y funciona sobre la messaging layer.
    Se encarga de definir la sintaxis y la semántica de la información que se intercambia entre pares a través de los mensajes Lightning.
    Consiste en mensajes de control definidos en BOLT #9; mensajes de establecimiento, operación y cierre de canales definidos en BOLT #2; así como mensajes de cotilleo y enrutamiento definidos en BOLT #7.

canal privado (private channel)::
    Un canal no anunciado al resto de la red.
    Técnicamente, "privado" es una denominación errónea, ya que estos canales aún pueden ser identificados a través de pistas de enrutamiento y transacciones de compromiso.
    Es mejor describirlos como canales "no anunciados".
	Con un canal no anunciado, los socios del canal pueden enviar y recibir pagos entre ellos de forma normal.
    Sin embargo, el resto de la red no conoce el canal y, por tanto, no puede utilizarlo para enrutar los pagos.
    Dado que se desconoce el número y la capacidad de los canales no anunciados, el recuento total de canales públicos y su capacidad sólo representa una parte del total de la Lightning Network.

preimagen::
	En el contexto de la criptografía y específicamente en la Lightning Network, la preimagen se refiere a la entrada de una función hash que produce un hash específico. No es posible calcular la preimagen a partir del hash (las funciones hash sólo van en una dirección). Seleccionando un valor aleatorio secreto como preimagen y calculando su hash, podemos comprometernos con esa preimagen y revelarla posteriormente. Cualquiera puede confirmar que la preimagen revelada produce correctamente el hash.

Prueba de trabajo (Proof of Work (PoW))::
    Datos que requieren un cálculo significativo para encontrarlos, y que pueden ser fácilmente verificados por cualquiera para probar la cantidad de trabajo que se requirió para producirlos.
    En Bitcoin, los mineros deben encontrar una solución numérica al algoritmo SHA-256 que cumpla con un objetivo de toda la red, llamado objetivo de dificultad.
    Ver _Minería de Bitcoin_ para más información.

Contrato de punto de tiempo bloqueado (Point Time-Locked Contract (PTLC))::
    Un Contrato de Punto con Bloqueo de Tiempo (PTLC) es un script de Bitcoin que permite un gasto condicional ya sea en la presentación de un secreto o después de que haya pasado un determinado blockheight, similar a un HTLC. A diferencia de los HTLC, los PTLC no dependen de la preimagen de una función hash, sino de la clave privada de un punto de curva elíptica. La hipótesis de seguridad se basa, pues, en el logaritmo discreto. Las PTLC aún no están implementadas en la Lightning Network.

timelock relativo (relative timelock)::
    Un timelock relativo es un tipo de timelock que permite que una entrada especifique el momento más temprano en que la entrada puede ser añadida a un bloque. El tiempo es relativo y se basa en el momento en que la salida a la que hace referencia esa entrada se registró en un bloque. Los timelocks relativos se establecen mediante el campo de transacción +nSequence+ y el opcode de Bitcoin Script +CHECKSEQUENCEVERIFY+ (CSV), que fue introducido por BIP-68/112/113.

Contrato de vencimiento de secuencia revocable (Revocable Sequence Maturity Contract (RSMC))::
    Este contrato se utiliza para construir un payment channel entre dos usuarios de Bitcoin o LN que no necesitan confiar el uno en el otro.
    El nombre proviene de una secuencia de estados que se codifican como transacciones de compromiso y pueden ser revocadas si se publican y minan erróneamente por la red Bitcoin.

revocation key::
    Cada RSMC contiene dos claves de revocación. Cada socio del canal conoce una clave de revocación. Conociendo ambas claves de revocación, la salida del RSMC puede ser gastada dentro del timelock predefinido.  Mientras se negocia un nuevo estado del canal, se comparten las antiguas claves de revocación, con lo que se "revoca" el estado anterior.  Las claves de revocación se utilizan para disuadir a los socios del canal de emitir un estado de canal antiguo. 

RIPEMD-160::
    RIPEMD-160 es una función hash criptográfica que produce un hash de 160 bits (20 bytes).

capa de enrutamiento (routing layer)::
    La cuarta capa del conjunto de protocolos de la Red Relámpago opera sobre la capa peer-to-peer.
    Su responsabilidad es definir las primitivas criptográficas y el protocolo de comunicación necesario para permitir el transporte seguro y atómico de bitcoin desde un nodo emisor hasta un nodo receptor.
    Mientras que BOLT #4 define el formato de la cebolla que se utiliza para comunicar la información de transporte a los pares remotos con los que no existen conexiones directas, el transporte real de la cebolla y las primitivas criptográficas se definen en BOLT #2.

topología (topology)::
    La topología de la Red Relámpago describe la forma de la Red Relámpago como un gráfico matemático. Los nodos del gráfico son los nodos Lightning (participantes/pares de la red). Las aristas del gráfico son los canales de pago.
    La topología de la Red Relámpago se difunde públicamente con la ayuda del gossip protocol, con la excepción de los canales no anunciados.
    Esto significa que la Red Relámpago puede ser significativamente mayor que el número anunciado de canales y nodos.
    Conocer la topología es de especial interés en el proceso de enrutamiento de pagos basado en la fuente, en el que el emisor descubre una ruta.

satoshi::
    Un satoshi es la unidad más pequeña (denominación) de bitcoin que puede registrarse en la blockchain. Un satoshi es la 1/100 millonésima parte (0,00000001) de un bitcoin y recibe su nombre del creador de Bitcoin, Satoshi Nakamoto.

Satoshi Nakamoto::
    Satoshi Nakamoto es el nombre utilizado por la persona o grupo de personas que diseñaron Bitcoin y crearon su implementación de referencia original. Como parte de la implementación, también idearon la primera base de datos blockchain. En el proceso, fueron los primeros en resolver el problema del double-spending de la moneda digital. Su verdadera identidad sigue siendo desconocida.

Firma Schnorr (Schnorr signature)::
    Un nuevo esquema de firma digital que se activará en Bitcoin en noviembre de 2021. Permite innovaciones en la Lightning Network, como las eficientes PTLC (una mejora de las HTLC).

Script, Script de Bitcoin::
    Bitcoin utiliza un sistema de scripting para las transacciones llamado Bitcoin Script. Se asemeja al lenguaje de programación Forth, es simple, se basa en la pila y se procesa de izquierda a derecha. Es intencionadamente Turing-incompleto, sin bucles ni recursividad.

ScriptPubKey (aka pubkey script)::
    ScriptPubKey o script pubkey, es un script incluido en las salidas que establece las condiciones que deben cumplirse para que esas salidas se gasten. Los datos para cumplir las condiciones pueden proporcionarse en un script de firma. Véase también _ScriptSig_.

ScriptSig (aka signature script)::
    ScriptSig o script de firma son los datos generados por un emisor, que casi siempre se utilizan como variables para satisfacer un script pubkey.

secret key (aka private key)::
    El número secreto que desbloquea el bitcoin enviado a la dirección correspondiente. Una clave secreta tiene el siguiente aspecto: +5J76sF8L5jTtzE96r66Sf8cka9y44wdpJjMwCxR3tzLh3ibVPxh+.

Segregated Witness (SegWit)::
    Segregated Witness (SegWit) es una actualización del protocolo Bitcoin introducida en 2017 que añade un nuevo testigo para las firmas y otras pruebas de autorización de transacciones. Este nuevo campo de testigo está exento del cálculo del ID de la transacción, lo que resuelve la mayoría de las clases de maleabilidad de las transacciones de terceros. El Testigo Segregado se desplegó como un soft fork y es un cambio que técnicamente hace que las reglas del protocolo de Bitcoin sean más restrictivas.

Secure Hash Algorithm (SHA)::
    El Algoritmo Hash Seguro o SHA es una familia de funciones hash criptográficas publicadas por el Instituto Nacional de Estándares y Tecnología (NIST). El protocolo de Bitcoin utiliza actualmente SHA-256, que produce un hash de 256 bits.

ID de canal corto (short channel ID (scid))::
    Una vez que se establece un canal, el índice de la funding transaction en el blockchain se utiliza como ID de canal corto para identificar de forma exclusiva el canal.
    El ID corto del canal consta de ocho bytes que hacen referencia a tres números.
    En su forma serializada, representa estos tres números como valores decimales separados por la letra "x" (por ejemplo, +600123x01x00+)
    El primer número (4 bytes) es la altura del bloque.
    El segundo número (2 bytes) es el índice de la operación de financiación con los bloques.
    El último número (2 bytes) es la salida de la transacción.

Verificación simplificada de pagos (simplified payment verification (SPV))::
    SPV o verificación de pago simplificada es un método para verificar que determinadas transacciones fueron incluidas en un bloque sin necesidad de descargar el bloque completo. El método es utilizado por algunos monederos ligeros de Bitcoin y Lightning. 

Enrutamiento basado en la fuente (source-based routing)::
    En la Lightning Network, el remitente de un pago decide la ruta del mismo.
    Aunque esto disminuye la tasa de éxito del proceso de enrutamiento, aumenta la privacidad de los pagos.
    Debido al formato de mezcla SPHINX utilizado por el enrutamiento de cebolla, todos los nodos de enrutamiento no conocen al emisor de un pago ni al destinatario final.
    El enrutamiento basado en la fuente es fundamentalmente diferente de cómo funciona el enrutamiento en el Protocolo de Internet.

soft fork::
    La soft fork, o cambio de soft fork, es una actualización del protocolo que es compatible hacia adelante y hacia atrás, por lo que permite que tanto los nodos antiguos como los nuevos sigan utilizando la misma cadena.

Formato de mezcla SPHINX (SPHINX Mix Format)::
    Una técnica particular de enrutamiento de cebolla utilizada en la Red Relámpago e inventada por https://cypherpunks.ca/~iang/pubs/Sphinx_Oakland09.pdf[George Danezis e Ian Goldberg en 2009].
    Con el formato de mezcla SPHINX, cada mensaje del paquete de cebolla se rellena con algunos datos aleatorios para que ningún salto pueda estimar la distancia que ha recorrido en la ruta.
    Aunque la privacidad del emisor y del receptor del pago está protegida, cada nodo puede devolver un mensaje de error a lo largo de la ruta al emisor del mensaje.

swap submarino (submarine swap)::
    Un swap submarino es un intercambio atómico sin confianza entre direcciones Bitcoin en la cadena y pagos de la Lightning Network fuera de la cadena. Al igual que los pagos de la Lightning Network utilizan HTLC que condicionan la reclamación final de fondos a que el receptor revele un secreto (preimagen de hash), los swaps submarinos utilizan el mismo mecanismo para transferir fondos a través de la barrera entre la cadena y la fuera de ella con una confianza mínima. Los intercambios submarinos inversos permiten intercambios en la dirección opuesta, desde un pago LN fuera de la cadena a una dirección Bitcoin dentro de la cadena.

timelock::
    Un timelock es un tipo de gravamen que restringe el gasto de algún bitcoin hasta un momento futuro especificado o una altura de bloque. Los timelocks ocupan un lugar destacado en muchos contratos de Bitcoin, incluidos los canales de pago y los HTLC.

transacción::
    Las transacciones son estructuras de datos utilizadas por Bitcoin para transferir bitcoin de una dirección a otra.
    Varios miles de transacciones se agregan en un bloque, que luego se registra (minado) en la blockchain.
    La primera transacción de cada bloque, llamada transacción coinbase, genera nuevos bitcoin.

maleabilidad de las transacciones (transaction malleability)::
    La maleabilidad de la transacción es una propiedad que permite cambiar el hash de una transacción sin cambiar la semántica de la misma.
    Por ejemplo, la alteración de la firma puede cambiar el hash de una transacción.
    Una commitment transaction necesita el hash de una funding transaction, y si el hash de la funding transaction cambia, las transacciones que dependen de ella quedarán invalidadas. Esto hará que los usuarios no puedan reclamar los reembolsos si los hay.
    La soft fork de Segregated Witness aborda este problema y, por lo tanto, fue una actualización importante para apoyar la Lightning Network.

capa de transporte (transport layer)::
    En las redes informáticas, la capa de transporte es una división conceptual de los métodos utilizados por los ordenadores (y, en última instancia, las aplicaciones) para hablar entre sí.
    La capa de transporte proporciona servicios de comunicación entre ordenadores, como el control de flujo, la verificación y la multiplexación (para permitir que varias aplicaciones trabajen en un ordenador al mismo tiempo).

salida de transacción no utilizada (unspent transaction output (UTXO))::
    Véase _salida_.

billetera (wallet)::
    Un monedero es una pieza de software que contiene las claves privadas de Bitcoin. Se utiliza para crear y firmar transacciones de Bitcoin. En el contexto de la Lightning Network, también contiene los secretos de revocación del estado del canal antiguo y las últimas transacciones de compromiso presignadas.

watchtower::
    Las torres de vigilancia son un servicio de seguridad en la Lightning Network que supervisa los canales de pago para detectar posibles infracciones del protocolo.
    Si uno de los socios del canal se desconecta o pierde su copia de seguridad, una watchtower mantiene copias de seguridad y puede restaurar la información de su canal.
+
Las torres de vigilancia también supervisan la blockchain de Bitcoin y pueden enviar una transacción de penalización si uno de los socios intenta "hacer trampa" transmitiendo un estado obsoleto. Las torres de vigilancia pueden ser gestionadas por los propios socios del canal, o como un servicio de pago ofrecido por un tercero. Las Atalayas no tienen control sobre los fondos de los propios canales.

Algunas definiciones aportadas han sido obtenidas bajo licencia CC-BY de https://en.bitcoin.it/wiki/Main_Page[Bitcoin Wiki], https://en.wikipedia.org[Wikipedia], https://github.com/bitcoinbook/bitcoinbook[_Mastering Bitcoin_], o de otras publicaciones de código abierto.


[role="pagenumrestart"]
[[intro_what_is_the_lightning_network]]
== Introducción.

¡Bienvenido a _Mastering the Lightning Network_!

La Lightning Network (a menudo abreviada como LN), está cambiando la forma en que la gente intercambia valor en línea, y es uno de los avances más emocionantes que han ocurrido en la historia de Bitcoin.
Hoy, en 2021, la Red Relámpago está todavía en su infancia. La Lightning Network es un protocolo para utilizar Bitcoin de forma inteligente y no obvia. Es una tecnología de segunda capa sobre Bitcoin.

El concepto de la Red Relámpago se propuso en 2015, y la primera implementación se lanzó en 2018. A partir de 2021, sólo estamos empezando a ver las oportunidades que la Lightning Network proporciona a Bitcoin, incluyendo la mejora de la privacidad, la velocidad y la escala.
Con un conocimiento básico de la Lightning Network, puede ayudar a dar forma al futuro de la red y, al mismo tiempo, crear oportunidades para usted.

Suponemos que ya tiene algunos conocimientos básicos sobre Bitcoin, pero si no es así, no se preocupe: le explicaremos los conceptos más importantes de Bitcoin, aquellos que debe conocer para entender la Lightning Network, en <<bitcoin_fundamentals_review>>. Si quiere aprender más sobre Bitcoin, puede leer _Mastering Bitcoin_, 2ª edición, de Andreas M. Antonopoulos (O'Reilly), disponible https://github.com/bitcoinbook/bitcoinbook[de forma gratuita online].

Aunque la mayor parte de este libro está escrito para programadores, los primeros capítulos están escritos para que sean accesibles a cualquier persona, independientemente de su experiencia técnica. En este capítulo, empezaremos con algo de terminología, luego pasaremos a ver la confianza y su aplicación en estos sistemas y, por último, hablaremos de la historia y el futuro de la Lightning Network. Empecemos.


=== Conceptos básicos de la Red Relámpago.

A medida que exploramos el funcionamiento real de la Red Relámpago, nos encontraremos con cierta terminología técnica que, al principio, puede resultar un poco confusa. Aunque todos estos conceptos y términos se explicarán en detalle a medida que avancemos en el libro y se definen en el glosario, algunas definiciones básicas ahora facilitarán la comprensión de los conceptos en los dos próximos capítulos. Si todavía no entiende todas las palabras de estas definiciones, no pasa nada. Entenderás más a medida que avances en el texto.

Blockchain:: Un libro de contabilidad de transacciones distribuido, producido por una red de ordenadores. Bitcoin, por ejemplo, es un sistema que produce una blockchain. La Lightning Network no es en sí misma una blockchain, ni produce una blockchain. Es una red que se basa en una blockchain externa para su seguridad.

Firma digital:: Una firma digital es un esquema matemático para verificar la autenticidad de los mensajes o documentos digitales. Una firma digital válida da a un destinatario razones para creer que el mensaje fue creado por un remitente conocido, que el remitente no puede negar haber enviado el mensaje, y que el mensaje no fue alterado en tránsito.

Función hash:: Una función hash criptográfica es un algoritmo matemático que asigna datos de tamaño arbitrario a una cadena de bits de tamaño fijo (un hash) y está diseñada para ser una función unidireccional, es decir, una función que es inviable de invertir.

Nodo:: Ordenador que participa en una red. Un nodo Lightning es un ordenador que participa en la Lightning Network. Un nodo Bitcoin es un ordenador que participa en la red Bitcoin. Normalmente, un usuario de LN ejecutará un nodo Lightning _y_ un nodo Bitcoin.

On-chain versus off-chain:: Los pagos enviados a través de canales de pago entre nodos Lightning, y que no son visibles en la blockchain subyacente, se denominan pagos _fuera de la cadena_. Normalmente, en la Lightning Network, las únicas transacciones on-chain son las que se utilizan para abrir y cerrar un payment channel Lightning. Existe un tercer tipo de transacción que modifica el canal, denominada empalme, que puede utilizarse para añadir/eliminar la cantidad de fondos comprometidos en un canal.

Pago:: Cuando se intercambia valor en la Lightning Network, lo llamamos "pago" en comparación con una "transacción" en la blockchain de Bitcoin.

Canal de pago:: Una _relación financiera_ entre dos nodos de la Lightning Network, normalmente implementada por transacciones Bitcoin multifirma que comparten el control sobre bitcoin entre los dos nodos Lightning.

Enrutamiento versus envío:: A diferencia de Bitcoin, donde las transacciones se "envían" difundiéndolas a todo el mundo, Lightning es una red enrutada en la que los pagos se "enrutan" a través de uno o más canales de pago siguiendo un _camino_ desde el emisor hasta el receptor.

Transacción:: Una estructura de datos que registra la transferencia de control sobre unos fondos (por ejemplo, unos bitcoin). La Lightning Network se basa en las transacciones de Bitcoin (o en las de otra blockchain) para hacer un seguimiento del control de los fondos.

Se pueden encontrar definiciones más detalladas de estos y otros muchos términos en el <<glossary>>. A lo largo de este libro, explicaremos qué significan estos conceptos y cómo funcionan realmente estas tecnologías. 

[TIP]
====
A lo largo de este libro, verás "Bitcoin" con la primera letra en mayúscula, que se refiere al _sistema Bitcoin_ y es un nombre propio. También verás "bitcoin", con _b_ minúscula, que se refiere a la unidad monetaria. Cada bitcoin se subdivide a su vez en 100 millones de unidades, cada una de las cuales se denomina "satoshi" (singular) o "satoshis" (plural).
====

Ahora que estás familiarizado con estos términos básicos, pasemos a un concepto con el que ya te sientes cómodo: la confianza.


=== Confianza en las redes descentralizadas.

A menudo oirás que la gente llama a Bitcoin y a la Lightning Network "sin confianza". A primera vista esto es confuso. Después de todo, ¿no es la confianza algo bueno? Los bancos la utilizan incluso en sus nombres. ¿No es un sistema "trustless", un sistema carente de confianza, algo malo?

El uso de la palabra "trustless" pretende transmitir la capacidad de operar sin _necesidad_ de confiar en los otros participantes del sistema. En un sistema descentralizado como Bitcoin, siempre puedes elegir hacer transacciones con alguien en quien confíes. Sin embargo, el sistema se asegura de que no pueda ser engañado incluso si no puede confiar en la otra parte de la transacción. La confianza es una propiedad agradable en lugar de una propiedad imprescindible del sistema.

Contrasta con los sistemas tradicionales, como el bancario, en el que debes confiar en un tercero, ya que éste controla tu dinero. Si el banco viola su confianza, puede encontrar algún recurso en un regulador o en un tribunal, pero con un enorme coste de tiempo, dinero y esfuerzo.

No significa que no haya confianza. Significa que la confianza no es un prerrequisito necesario para todas las transacciones y que puedes realizar transacciones incluso con personas en las que no confías porque el sistema evita las trampas.

Antes de entrar en el funcionamiento de la Red Relámpago, es importante entender un concepto básico que subyace en Bitcoin, la Red Relámpago y muchos otros sistemas de este tipo: algo que llamamos un _protocolo de equidad_. Un protocolo de equidad es una forma de conseguir resultados justos entre los participantes, que no necesitan confiar los unos en los otros, sin necesidad de una autoridad central, y es la columna vertebral de los sistemas descentralizados como Bitcoin.


=== Equidad sin autoridad central.

Cuando las personas tienen intereses contrapuestos, ¿cómo pueden establecer la suficiente confianza para adoptar un comportamiento cooperativo o transaccional? La respuesta a esta pregunta se encuentra en el núcleo de varias disciplinas científicas y humanísticas, como la economía, la sociología, la psicología del comportamiento y las matemáticas. Algunas de esas disciplinas nos dan respuestas "blandas" que dependen de conceptos como la reputación, la equidad, la moralidad e incluso la religión. Otras disciplinas nos dan respuestas concretas que dependen únicamente de la suposición de que los participantes en estas interacciones actuarán racionalmente, con su propio interés como objetivo principal.

A grandes rasgos, hay un puñado de formas de garantizar resultados justos en las interacciones entre individuos que pueden tener intereses contrapuestos:

Exigir confianza: Sólo se interactúa con personas en las que ya se confía, debido a interacciones previas, reputación o relaciones familiares. Esto funciona lo suficientemente bien a pequeña escala, especialmente dentro de las familias y los grupos pequeños, que es la base más común para el comportamiento cooperativo. Desgraciadamente, no funciona a escala y sufre el sesgo tribalista (dentro del grupo).

Estado de derecho:: Establece reglas para las interacciones que son aplicadas por una institución. Esta solución se adapta mejor, pero no se puede aplicar a nivel mundial debido a las diferencias en las costumbres y tradiciones, así como a la incapacidad de aplicar las instituciones de ejecución. Un efecto secundario desagradable de esta solución es que las instituciones se vuelven más y más poderosas a medida que crecen y eso puede llevar a la corrupción.

Terceros de confianza:: Poner un intermediario en cada interacción para hacer cumplir la equidad. En combinación con el "Estado de Derecho" para supervisar a los intermediarios, esta solución es mejor, pero adolece del mismo desequilibrio de poder: los intermediarios se vuelven muy poderosos y pueden atraer la corrupción. La concentración de poder conduce al riesgo sistémico y al fracaso sistémico ("demasiado grande para caer").

Protocolos de equidad de la teoría del juego:: Esta última categoría surge de la combinación de Internet y la criptografía y es el tema de esta sección. Veamos cómo funciona y cuáles son sus ventajas e inconvenientes. 

==== Protocolos de confianza sin intermediarios.

Los sistemas criptográficos como Bitcoin y Lightning Network son sistemas que permiten realizar transacciones con personas (y ordenadores) en los que no se confía. A menudo se denomina operación "sin confianza", aunque en realidad no es sin confianza. Tienes que confiar en el software que ejecutas, y tienes que confiar en que el protocolo implementado por ese software dará resultados justos.

La gran diferencia entre un sistema criptográfico como éste y un sistema financiero tradicional es que en las finanzas tradicionales se cuenta con un tercero _de confianza_, por ejemplo un banco, para garantizar que los resultados sean justos. Un problema importante de estos sistemas es que otorgan demasiado poder al tercero, y también son vulnerables a un _punto único de fallo_. Si el propio tercero de confianza viola la confianza o intenta hacer trampas, la base de la confianza se rompe.

Al estudiar los sistemas criptográficos, notarás un cierto patrón: en lugar de confiar en un tercero de confianza, estos sistemas intentan evitar resultados injustos utilizando un sistema de incentivos y desincentivos. En los sistemas criptográficos se confía en el _protocolo_, que es efectivamente un sistema con un conjunto de reglas que, si está bien diseñado, aplicará correctamente los incentivos y desincentivos deseados. La ventaja de este enfoque es doble: no sólo se evita confiar en un tercero, sino que también se reduce la necesidad de imponer resultados justos. Mientras los participantes sigan el protocolo acordado y se mantengan dentro del sistema, el mecanismo de incentivos de ese protocolo consigue resultados justos sin necesidad de aplicarlos.

El uso de incentivos y desincentivos para lograr resultados justos es un aspecto de una rama de las matemáticas llamada _teoría de los juegos_, que estudia "modelos de interacción estratégica entre tomadores de decisiones racionales". "footnote:[La Wikipedia https://en.wikipedia.org/wiki/Game_theory[entrada sobre teoría de los juegos] proporciona más información]. Los sistemas criptográficos que controlan las interacciones financieras entre los participantes, como Bitcoin y la Lightning Network, se basan en gran medida en la teoría de juegos para evitar que los participantes hagan trampas y permitir que los participantes que no confían en los demás consigan resultados justos.

Aunque la teoría de juegos y su uso en los sistemas criptográficos pueden parecer confusos y poco familiares al principio, lo más probable es que ya estés familiarizado con estos sistemas en tu vida diaria; simplemente no los reconoces todavía. En la siguiente sección utilizaremos un sencillo ejemplo de la infancia para ayudarnos a identificar el patrón básico. Una vez que entiendas el patrón básico, lo verás en todas partes en el espacio de la blockchain y llegarás a reconocerlo rápida e intuitivamente.

Protocolo de equidad, definido como un proceso que utiliza un sistema de incentivos y/o desincentivos para garantizar resultados justos para los participantes que no confían en los demás. La aplicación de un protocolo de equidad sólo es necesaria para garantizar que los participantes no puedan escapar de los incentivos o desincentivos.

==== Un protocolo de equidad en acción.

Veamos un ejemplo de protocolo de equidad con el que quizá ya esté familiarizado.

Imagine una comida familiar, con un padre y dos hijos. Los niños son quisquillosos y lo único que aceptan comer son patatas fritas. El padre ha preparado un plato de patatas fritas ("french fries" o "chips", según el dialecto inglés que utilice). Los dos hermanos deben compartir el plato de patatas fritas. El padre debe garantizar una distribución justa de las patatas fritas a cada uno de los niños; de lo contrario, el padre tendrá que oír constantes quejas (quizá todo el día), y siempre existe la posibilidad de que una situación injusta llegue a la violencia. ¿Qué puede hacer un padre?

Hay varias formas de lograr la equidad en esta interacción estratégica entre dos hermanos que no confían el uno en el otro y tienen intereses contrapuestos. El método más ingenuo, pero comúnmente utilizado, es que el padre utilice su autoridad como tercero de confianza: divide el bol de patatas fritas en dos porciones. Esto es similar a las finanzas tradicionales, en las que un banco, un contable o un abogado actúan como tercero de confianza para evitar cualquier trampa entre dos partes que quieren realizar una transacción.

El problema de este escenario es que confiere mucho poder y responsabilidad al tercero de confianza. En este ejemplo, el padre es totalmente responsable del reparto equitativo de las fichas, y las partes se limitan a esperar, observar y quejarse.  Los niños acusan al padre de tener favoritos y de no repartir las fichas de forma justa. Los hermanos se pelean por las fichas, gritando "¡esa ficha es más grande!" y arrastrando al padre a su pelea. Suena muy mal, ¿verdad? ¿Debería el padre gritar más fuerte? ¿Quitar todas las patatas? ¿Amenazar con no volver a hacer patatas fritas y dejar que esos niños desagradecidos pasen hambre? 

Existe una solución mucho mejor: se enseña a los hermanos a jugar a un juego llamado "divide y elige". En cada comida, uno de los hermanos divide el bol de patatas fritas en dos porciones y el _otro_ hermano puede elegir qué porción quiere. Casi inmediatamente, los hermanos se dan cuenta de la dinámica de este juego. Si el que divide comete un error o intenta hacer trampa, el otro hermano puede "castigarlo" eligiendo el bol más grande. Lo mejor para ambos hermanos, pero sobre todo para el que reparte, es jugar limpio. En este caso, sólo pierde el que hace trampas. El padre ni siquiera tiene que hacer uso de su autoridad o imponer la equidad. Todo lo que tiene que hacer el padre es _hacer cumplir el protocolo_; mientras los hermanos no puedan escapar de sus papeles asignados de "repartidor" y "elegidor", el propio protocolo garantiza un resultado justo sin necesidad de ninguna intervención. El padre no puede tener favoritos ni distorsionar el resultado.

[WARNING]
====
Aunque las infames batallas de fichas de los años 80 ilustran perfectamente el punto, cualquier similitud entre el escenario anterior y cualquiera de las experiencias infantiles reales de los autores con sus primos es totalmente coincidente... ¿o no?
====

==== Primitivas de seguridad como bloques de construcción.

Para que un protocolo de equidad como éste funcione, es necesario que haya ciertas garantías, o _primitivas de seguridad_, que puedan combinarse para asegurar su cumplimiento. La primera primitiva de seguridad es el _ordenamiento/secuencia temporal estricto_: la acción de "dividir" debe ocurrir antes que la acción de "elegir". No es evidente, pero a menos que se garantice que la acción A tiene lugar antes que la acción B, el protocolo se desmorona. La segunda primitiva de seguridad es el _compromiso con no repudio_. Cada hermano debe comprometerse con el papel que ha elegido: repartir o elegir. Además, una vez que se ha completado la división, el divisor está comprometido con la división que ha creado, no puede repudiar esa elección y volver a intentarlo.

Los sistemas criptográficos ofrecen una serie de primitivas de seguridad que pueden combinarse de diferentes maneras para construir un protocolo de equidad. Además de la secuenciación y el compromiso, podemos utilizar muchas otras herramientas:

- Funciones hash para tomar huellas digitales de los datos, como forma de compromiso, o como base de una firma digital
- Firmas digitales para la autenticación, el no repudio y la prueba de propiedad de un secreto
- Cifrado/descifrado para restringir el acceso a la información sólo a los participantes autorizados.

Esta es sólo una pequeña lista de toda una "colección" de primitivas criptográficas y de seguridad que se utilizan. Cada vez se inventan más primitivas y combinaciones básicas.

En nuestro ejemplo de la vida real, vimos una forma de protocolo de equidad llamada "divide y vencerás". Éste es sólo uno de los innumerables protocolos de equidad diferentes que pueden construirse combinando los bloques de construcción de las primitivas de seguridad de diferentes maneras. Pero el patrón básico es siempre el mismo: dos o más participantes interactúan sin confiar el uno en el otro realizando una serie de pasos que forman parte de un protocolo acordado. Los pasos del protocolo organizan incentivos y desincentivos para garantizar que, si los participantes son racionales, el engaño es contraproducente y la equidad es el resultado automático. El cumplimiento no es necesario para obtener resultados justos, sólo es necesario para evitar que los participantes se salgan del protocolo acordado.

Ahora que entiendes este patrón básico, empezarás a verlo en todas partes en Bitcoin, la Lightning Network y muchos otros sistemas. Veamos algunos ejemplos específicos a continuación.

==== Ejemplo de Protocolo de Equidad.

El ejemplo más destacado de un protocolo de equidad es el algoritmo de consenso de Bitcoin, Proof of Work (PoW). En Bitcoin, los mineros compiten para verificar las transacciones y agregarlas en bloques. Para garantizar que los mineros no hagan trampas, sin confiarles la autoridad, Bitcoin utiliza un sistema de incentivos y desincentivos. Los mineros tienen que usar electricidad y dedicar hardware a hacer "trabajo" que se incorpora como "prueba" dentro de cada bloque. Esto se consigue gracias a una propiedad de las funciones hash en la que el valor de salida se distribuye aleatoriamente en todo el rango de salidas posibles. Si los mineros consiguen producir un bloque válido con la suficiente rapidez, son recompensados ganando la recompensa de ese bloque. Obligar a los mineros a usar mucha electricidad antes de que la red considere su bloque significa que tienen un incentivo para validar correctamente las transacciones del bloque. Si hacen trampas o cometen algún tipo de error, su bloque es rechazado y la electricidad que utilizaron para "probarlo" se desperdicia. No es necesario obligar a los mineros a producir bloques válidos; la recompensa y el castigo les incentivan a hacerlo. Todo lo que necesita hacer el protocolo es asegurar que sólo se acepten bloques válidos con Prueba de Trabajo.

El patrón del protocolo de equidad también puede encontrarse en muchos aspectos diferentes de la Lightning Network: 

* Los que financian canales se aseguran de tener una transacción de reembolso firmada antes de publicar la funding transaction.

* Cada vez que un canal pasa a un nuevo estado, el estado anterior se "revoca" asegurando que si alguien intenta emitirlo, pierde todo el balance y es castigado.

* Los que reenvían pagos saben que si comprometen fondos hacia adelante, pueden obtener un reembolso o ser pagados por el nodo que les precede.

Una y otra vez, vemos este patrón. Los resultados justos no son impuestos por ninguna autoridad. Surgen como consecuencia natural de un protocolo que premia la equidad y castiga las trampas, un protocolo de equidad que aprovecha el interés propio dirigiéndolo hacia resultados justos.

Tanto Bitcoin como Lightning Network son implementaciones de protocolos de equidad. Entonces, ¿por qué necesitamos la Lightning Network? ¿No es suficiente con Bitcoin?


=== Motivación para la Lightning Network.

Bitcoin es un sistema que registra las transacciones en un libro de contabilidad público replicado globalmente. Cada transacción es vista, validada y almacenada por cada ordenador participante. Como se puede imaginar, esto genera muchos datos y es difícil de escalar.

A medida que Bitcoin y la demanda de transacciones crecían, el número de transacciones en cada bloque aumentaba hasta alcanzar el límite de tamaño de los bloques.
Una vez que los bloques están "llenos", el exceso de transacciones se deja esperando en una cola. Muchos usuarios aumentarán las fees que están dispuestos a pagar para comprar espacio para sus transacciones en el siguiente bloque.

Si la demanda sigue superando la capacidad de la red, un número cada vez mayor de transacciones de los usuarios se quedan esperando sin confirmar. La competencia por las fees también aumenta el coste de cada transacción, lo que hace que muchas transacciones de menor valor (por ejemplo, las microtransacciones) sean completamente antieconómicas durante los periodos de demanda especialmente alta.

Para resolver este problema, podríamos aumentar el límite de tamaño de los bloques para crear espacio para más transacciones. Un aumento de la "oferta" de espacio de bloques conducirá a un equilibrio de precios más bajo para las fees de las transacciones.

Sin embargo, aumentar el tamaño de los bloques traslada el coste a los operadores de los nodos y les obliga a gastar más recursos para validar y almacenar la blockchain. Dado que las cadenas de bloques son protocolos de cotilleo, cada nodo debe conocer y validar cada una de las transacciones que se producen en la red. Además, una vez validada, cada transacción y bloque debe propagarse a los "vecinos" del nodo, lo que multiplica los requisitos de ancho de banda. Por tanto, cuanto mayor sea el tamaño del bloque, mayores serán los requisitos de ancho de banda, procesamiento y almacenamiento de cada nodo. Aumentar la capacidad de transacción de este modo tiene el efecto indeseable de centralizar el sistema al reducir el número de nodos y operadores de nodos. Dado que los operadores de nodos no son compensados por el funcionamiento de los nodos, si el funcionamiento de los nodos es muy caro, sólo unos pocos operadores de nodos bien financiados seguirán dirigiendo los nodos.

==== Escalado de Blockchains.

Los efectos secundarios de aumentar el tamaño de los bloques o de disminuir el tiempo de los mismos con respecto a la centralización de la red son graves, como demuestran algunos cálculos con los números.

Supongamos que el uso de Bitcoin crece de manera que la red tiene que procesar 40.000 transacciones por segundo, que es el nivel aproximado de procesamiento de transacciones de la red de Visa durante el uso máximo.

Suponiendo una media de 250 bytes por transacción, esto se traduciría en un flujo de datos de 10 megabytes por segundo (MBps) u 80 megabits por segundo (Mbps) sólo para poder recibir todas las transacciones.
Esto no incluye la sobrecarga de tráfico que supone reenviar la información de las transacciones a otros pares.
Aunque 10 MBps no parecen extremos en el contexto de las velocidades de la fibra óptica de alta velocidad y de la telefonía móvil 5G, excluiría de hecho de la gestión de un nodo a cualquiera que no pueda cumplir este requisito, especialmente en los países en los que la Internet de alto rendimiento no es asequible o no está ampliamente disponible.

Los usuarios también tienen muchas otras demandas en su ancho de banda y no se puede esperar que gasten tanto sólo para recibir transacciones.

Además, almacenar esta información localmente supondría 864 gigabytes al día. Esto es aproximadamente un terabyte de datos, o el tamaño de un disco duro. 

Verificar 40.000 firmas del Algoritmo de Firma Digital de Curva Elíptica (ECDSA) por segundo también es apenas factible (véase https://bitcoin.stackexchange.com/questions/95339/how-many-bitcoin-transactions-can-be-verified-per-second[este artículo en StackExchange]), lo que hace que la _descarga inicial de bloques (IBD)_ de la blockchain de Bitcoin (sincronizar y verificar todo a partir del bloque génesis) sea casi imposible sin un hardware muy caro.

Aunque 40.000 transacciones por segundo parecen muchas, sólo alcanzan la paridad con las redes de pago financieras tradicionales en las horas punta. Las innovaciones en los pagos de máquina a máquina, las microtransacciones y otras aplicaciones probablemente empujarán la demanda a muchos órdenes superiores a eso.

En pocas palabras: no se puede escalar una blockchain para validar las transacciones de todo el mundo de forma descentralizada.

¿Pero qué pasaría si cada nodo no tuviera que conocer y validar cada una de las transacciones? ¿Y si hubiera una forma de tener transacciones escalables fuera de la cadena, sin perder la seguridad de la red Bitcoin?_.

En febrero de 2015, Joseph Poon y Thaddeus Dryja propusieron una posible solución al problema de la escalabilidad de Bitcoin, con la publicación de "The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments". "footnote:[Joseph Poon y Thaddeus Dryja. "The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments". Versión DRAFT 0.5.9.2. 14 de enero de 2016. https://lightning.network/lightning-network-paper.pdf[].]

En el libro blanco (ya obsoleto), Poon y Dryja estiman que para que Bitcoin alcance las 47.000 transacciones por segundo procesadas en su pico por Visa, se necesitarían 8 GB de bloques.
Esto haría que el funcionamiento de un nodo fuera completamente insostenible para cualquiera que no fuera una empresa a gran escala y operaciones de tipo industrial.
El resultado sería una red en la que sólo unos pocos usuarios podrían validar el estado del libro mayor.
Bitcoin depende de que los usuarios validen el libro de contabilidad por sí mismos, sin confiar explícitamente en terceros, para mantenerse descentralizado.
Poner un precio a los usuarios para que no puedan utilizar los nodos obligaría al usuario medio a confiar en terceros para descubrir el estado del libro de contabilidad, rompiendo en última instancia el modelo de confianza de Bitcoin.

La Lightning Network propone una nueva red, una segunda capa, en la que los usuarios pueden realizar pagos entre sí de igual a igual, sin necesidad de publicar una transacción en la blockchain de Bitcoin para cada pago.
Los usuarios pueden pagarse unos a otros en la Lightning Network tantas veces como quieran, sin crear transacciones adicionales de Bitcoin ni incurrir en comisiones en la cadena.
Sólo hacen uso de la blockchain de Bitcoin para cargar bitcoin en la Lightning Network inicialmente y para _liquidar_, es decir, para retirar bitcoin de la Lightning Network.
El resultado es que muchos más pagos de Bitcoin pueden tener lugar fuera de la cadena, con sólo la carga inicial y las transacciones de liquidación final que necesitan ser validadas y almacenadas por los nodos de Bitcoin.
Además de reducir la carga de los nodos, los pagos en la Lightning Network son más baratos para los usuarios porque no necesitan pagar las tasas de la blockchain, y más privados para los usuarios porque no se publican a todos los participantes de la red y además no se almacenan permanentemente.

Aunque la Lightning Network se concibió inicialmente para Bitcoin, puede implementarse en cualquier blockchain que cumpla algunos requisitos técnicos básicos. Otras blockchains, como Litecoin, ya son compatibles con la Lightning Network. Además, varias otras blockchains están desarrollando soluciones similares de segunda capa o "capa 2" para ayudarlas a escalar 

=== Características definitorias de la Lightning Network.

La Lightning Network es una red que opera como un protocolo de segunda capa sobre Bitcoin y otros blockchains. La Lightning Network permite realizar pagos rápidos, seguros, privados, sin confianza y sin permisos. Estas son algunas de las características de la Lightning Network:

 * Los usuarios de la Lightning Network pueden enrutar los pagos entre sí a bajo coste y en tiempo real.
 * Los usuarios que intercambian valor a través de la Lightning Network no necesitan esperar las confirmaciones de los bloques para los pagos.
 * Una vez que un pago en la Lightning Network se ha completado, normalmente en unos pocos segundos, es definitivo y no puede ser revertido. Al igual que una transacción de Bitcoin, un pago en la Lightning Network sólo puede ser devuelto por el receptor.
 * Mientras que las transacciones en la cadena de Bitcoin son transmitidas y verificadas por todos los nodos de la red, los pagos realizados en la Lightning Network se transmiten entre pares de nodos y no son visibles para todo el mundo, por lo que la privacidad es mucho mayor.
 * A diferencia de las transacciones en la red Bitcoin, los pagos enrutados en la Lightning Network no necesitan ser almacenados permanentemente. Por tanto, Lightning utiliza menos recursos y, por lo tanto, es más barato. Esta propiedad también tiene beneficios para la privacidad.
 * La Lightning Network utiliza el onion routing, similar al protocolo utilizado por la red de privacidad The Onion Router (Tor), de modo que incluso los nodos que participan en el enrutamiento de un pago sólo conocen directamente a su predecesor y sucesor en la ruta de pago.
 * Cuando se utiliza sobre Bitcoin, la Lightning Network utiliza bitcoin real, que siempre está en posesión (custodia) y pleno control del usuario. Lightning no es un token o moneda independiente, _es_ Bitcoin.


[[user-stories]]
=== Casos de uso de la Lightning Network, usuarios y sus historias.

Para entender mejor cómo funciona realmente la Lightning Network y por qué la gente la utiliza, seguiremos a varios usuarios y sus historias.

En nuestros ejemplos, algunas de las personas ya han utilizado Bitcoin y otras son completamente nuevas en la red Bitcoin. Cada persona y su historia, tal y como se enumeran aquí, ilustran uno o más casos de uso específicos. Los revisaremos a lo largo de este libro:

Consumidor::
Alice es una usuaria de Bitcoin que quiere hacer pagos rápidos, seguros, baratos y privados para pequeñas compras al por menor. Ella compra café con bitcoin, usando la Lightning Network.

Comerciante::
Bob es dueño de una cafetería, "Bob's Cafe". Los pagos con Bitcoin en cadena no escalan para cantidades pequeñas como una taza de café, por lo que utiliza la Lightning Network para aceptar pagos con Bitcoin de forma casi instantánea y por fees bajas.

Negocio de servicios de software::
Chan es un empresario chino que vende servicios de información relacionados con la Lightning Network, así como con Bitcoin y otras criptodivisas. Chan está vendiendo estos servicios de información a través de Internet mediante la implementación de micropagos a través de la Lightning Network. Además, Chan ha implementado un servicio de proveedor de liquidez que alquila la capacidad del canal de entrada en la Lightning Network, cobrando una pequeña cuota de bitcoin por cada período de alquiler.

Gamer::
Dina es una jugadora adolescente de Rusia. Juega a muchos juegos de ordenador diferentes, pero sus favoritos son los que tienen una "economía en el juego" basada en dinero real. Mientras juega, también gana dinero adquiriendo y vendiendo objetos virtuales del juego. La Red Relámpago le permite realizar transacciones de pequeñas cantidades por objetos del juego, así como ganar pequeñas cantidades por completar misiones.

=== Conclusión.

En este capítulo hemos hablado del concepto fundamental en el que se basan tanto Bitcoin como la Lightning Network: el protocolo de equidad.

Hemos visto la historia de la Lightning Network y las motivaciones detrás de las soluciones de escalado de segunda capa para Bitcoin y otras redes basadas en blockchain.

Aprendimos la terminología básica: nodo, payment channel, transacciones en la cadena y pagos fuera de la cadena.

Por último, conocimos a Alice, Bob, Chan y Dina, a quienes seguiremos durante el resto del libro. 


[[getting-started]]
== Empezando.

En este capítulo, empezaremos por donde la mayoría de la gente empieza cuando se encuentra con la Lightning Network por primera vez, eligiendo el software para participar en la economía de la LN. Examinaremos las elecciones de dos usuarios que representan un caso de uso común para la Lightning Network y aprenderemos con el ejemplo. Alice, una clienta de una cafetería, utilizará un monedero Lightning en su dispositivo móvil para comprar café en la cafetería de Bob. Bob, un comerciante, utilizará un nodo y un monedero Lightning para ejecutar un sistema de punto de venta en su cafetería, de modo que pueda aceptar pagos a través de la Lightning Network.

=== La primera billetera Lightning de Alice.

Alice es una antigua usuaria de Bitcoin. Conocimos a Alice en el capítulo 1 de _Mastering Bitcoin_,footnote:[Andreas M. Antonopoulos, _Mastering Bitcoin_, 2ª Edición, https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch01.asciidoc[Capítulo 1] (O'Reilly)] cuando compró una taza de café en la cafetería de Bob usando una transacción de Bitcoin. Si todavía no está familiarizado con el funcionamiento de las transacciones de Bitcoin o necesita un repaso, por favor lea _Mastering Bitcoin_ o el resumen en <<bitcoin_fundamentals_review>>.

¡Alice se ha enterado recientemente de que el Café de Bob acaba de empezar a aceptar pagos en LN! Alice está ansiosa por conocer y experimentar con la Lightning Network; quiere ser uno de los primeros clientes de LN de Bob. Para ello, en primer lugar, Alice tiene que seleccionar un monedero Lightning que se ajuste a sus necesidades.

Alice no quiere confiar la custodia de su bitcoin a terceros. Ha aprendido lo suficiente sobre la criptomoneda para saber cómo utilizar un monedero. También quiere un monedero móvil para poder utilizarlo para pequeños pagos sobre la marcha, así que elige el monedero _Eclair_, un popular monedero Lightning móvil no custodiado. Conozcamos más sobre cómo y por qué ha hecho estas elecciones.

=== Nodos Lightning.

Se accede a la Lightning Network a través de aplicaciones de software que pueden hablar el protocolo LN. Un _nodo Lightning Network_ (nodo LN o simplemente nodo) es una aplicación de software que tiene tres características importantes. En primer lugar, los nodos Lightning son monederos, por lo que envían y reciben pagos a través de la Lightning Network, así como en la red Bitcoin. En segundo lugar, los nodos deben comunicarse de igual a igual con otros nodos Lightning que crean la red. Por último, los nodos Lightning también necesitan acceder a la blockchain de Bitcoin (u otras blockchains para otras criptodivisas) para asegurar los fondos utilizados para los pagos.

Los usuarios tienen el mayor grado de control al ejecutar su propio nodo Bitcoin y su nodo Lightning. Sin embargo, los nodos Lightning también pueden utilizar un cliente ligero de Bitcoin, comúnmente conocido como verificación simplificada de pagos (SPV), para interactuar con la blockchain de Bitcoin.

[[ln_explorer]]
=== Exploradores Lightning.

Los exploradores LN son herramientas útiles para mostrar las estadísticas de los nodos, los canales y la capacidad de la red.

A continuación se presenta una lista inagotable:

* https://1ml.com[1ML Lightning explorer] 
* https://explorer.acinq.co[ACINQ's Lightning explorer], con visualización de lujo 
* https://amboss.space[Amboss Space Lightning explorer], con métricas de la comunidad y visualizaciones intuitivas
* https://ln.bigsun.xyz[Fiatjaf's Lightning explorer], con muchos diagramas
* https://hashxp.org/lightning/node[Explorador de rayos de hashXP]

[TIP]
====
Hay que tener en cuenta que al utilizar los exploradores Lightning, al igual que con otros exploradores de bloques, la privacidad puede ser un problema.
Si los usuarios se descuidan, el sitio web puede rastrear sus direcciones IP y recopilar sus registros de comportamiento (por ejemplo, los nodos que les interesan a los usuarios).

Además, hay que tener en cuenta que, dado que no existe un consenso global sobre el gráfico actual de Lightning o el estado actual de cualquier política de canales existente, los usuarios nunca deben confiar en los exploradores de Lightning para obtener la información más actualizada.
Además, a medida que los usuarios abren, cierran y actualizan canales, el gráfico cambiará y los exploradores de Lightning individuales pueden no estar actualizados.
Utilice los exploradores de Lightning para visualizar la red o recopilar información, pero no como fuente autorizada de lo que ocurre en la red de Lightning.
Para tener una visión autorizada de la Lightning Network, ejecuta tu propio nodo Lightning que construirá un gráfico de canales y recopilará diversas estadísticas, que podrás ver con una interfaz basada en la web.
====
 

=== Carteras Lightning.

El término _Lightning wallet_ es algo ambiguo porque puede describir una amplia variedad de componentes combinados con alguna interfaz de usuario. Los componentes más comunes del software Lightning wallet incluyen:

* Un almacén de claves que contiene secretos, como las claves privadas
* Un nodo LN (nodo Lightning) que se comunica en la red peer-to-peer, como se ha descrito anteriormente
* Un nodo Bitcoin que almacena los datos de la blockchain y se comunica con otros nodos Bitcoin
* Un "mapa" de base de datos de los nodos y canales que se anuncian en la Lightning Network
* Un gestor de canales que puede abrir y cerrar canales de la LN
* Un sistema de cierre que puede encontrar una ruta de canales conectados desde el origen del pago hasta el destino del mismo

Un monedero Lightning puede contener todas estas funciones, actuando como un monedero "completo", sin depender de ningún servicio de terceros. O uno o más de estos componentes pueden depender (parcial o totalmente) de servicios de terceros que medien en esas funciones.

Una distinción _clave_ (juego de palabras) es si la función de almacén de claves es interna o subcontratada. En las cadenas de bloques, el control de las claves determina la custodia de los fondos, tal y como recuerda la frase "tus claves, tus monedas; no tus claves, no tus monedas". El monedero de autocustodia, en comparación, es aquel en el que el almacén de claves forma parte del monedero, y las claves son controladas directamente por el usuario.  El término monedero sin custodia sólo implica que el almacén de claves es local y está bajo el control del usuario. Sin embargo, uno o más de los otros componentes del monedero pueden o no estar externalizados y depender de terceros de confianza.

Las cadenas de bloques, especialmente las cadenas de bloques abiertas como Bitcoin, intentan minimizar o eliminar la confianza en terceros y dar poder a los usuarios. A menudo se denomina modelo "sin confianza", aunque "confianza minimizada" es un término más adecuado. En estos sistemas, el usuario confía en las reglas del software, no en terceros. Por lo tanto, la cuestión del control de las claves es una consideración principal a la hora de elegir un monedero Lightning.

Todos los demás componentes de un monedero Lightning conllevan consideraciones similares de confianza. Si todos los componentes están bajo el control del usuario, se minimiza la cantidad de confianza en terceros, aportando el máximo poder al usuario. Por supuesto, esto conlleva una contrapartida directa porque con ese poder viene la correspondiente responsabilidad de gestionar un software complejo.

Cada usuario debe tener en cuenta sus propios conocimientos técnicos antes de decidir qué tipo de monedero Lightning va a utilizar. Aquellos con fuertes habilidades técnicas deberían utilizar un monedero Lightning que ponga todos los componentes bajo el control directo del usuario. Aquellos con menos habilidades técnicas, pero con el deseo de controlar sus fondos, deberían elegir una billetera Lightning no custodiada.
A menudo, la confianza en estos casos está relacionada con la privacidad.
Si los usuarios deciden externalizar alguna funcionalidad a un tercero, suelen renunciar a cierta privacidad, ya que el tercero conocerá cierta información sobre ellos.

Por último, aquellos que buscan la simplicidad y la comodidad, incluso a expensas del control y la seguridad, pueden elegir un monedero Lightning de custodia. Esta es la opción menos complicada técnicamente, pero _socava el modelo de confianza de la criptodivisa_ y, por lo tanto, debería considerarse sólo como un peldaño hacia un mayor control y autoconfianza.

Hay muchas formas de caracterizar o categorizar los monederos.
Las preguntas más importantes que hay que hacerse sobre un monedero específico son:

. ¿Este monedero Lightning tiene un nodo Lightning completo o utiliza un nodo Lightning de terceros?
. ¿Este monedero Lightning tiene un nodo Bitcoin completo o utiliza un nodo Bitcoin de terceros?
. ¿Esta billetera Lightning almacena sus propias claves bajo el control del usuario (autocustodia) o las claves están en manos de un tercero?

[TIP]
====
Si un monedero Lightning utiliza un nodo Lightning de terceros, es este nodo Lightning de terceros el que decide cómo comunicarse con Bitcoin. Por lo tanto, utilizar un nodo Lightning de terceros implica que también se utiliza un nodo Bitcoin de terceros. Sólo cuando el monedero Lightning utiliza su propio nodo Lightning existe la posibilidad de elegir entre un nodo Bitcoin completo y un nodo Bitcoin de terceros.
====

En el nivel más alto de abstracción, las preguntas 1 y 3 son las más elementales.
De estas dos preguntas, podemos derivar cuatro posibles categorías.
Podemos colocar estas cuatro categorías en un cuadrante, como se ve en <<lnwallet-categories>>.
Pero recuerda que ésta es sólo una forma de categorizar las billeteras Lightning. 

[[lnwallet-categories]]
.Lightning wallets quadrant
[options="header"]
|===
|                        | *Full Lightning node*      | *Third-party Lightning node*
| *Self-custody*         | Q1: High technical skill, least trust in third parties, most permissionless | Q2: Below medium technical skills, below medium trust in third parties, requires some permissions
| *Custodial*            | Q3: Above medium technical skills, above medium trust in third parties, requires some permissions | Q4: Low technical skills, high trust in third parties, least permissionless
|===

El cuadrante 3 (Q3), en el que se utiliza un nodo Lightning completo, pero las claves están en manos de un custodio, no es actualmente común.
Los futuros monederos de ese cuadrante pueden dejar que un usuario se preocupe de los aspectos operativos de su nodo, pero luego delegar el acceso a las claves a un tercero que utilice principalmente el cold storage.

Los monederos Lightning pueden instalarse en diversos dispositivos, como ordenadores portátiles, servidores y dispositivos móviles. Para ejecutar un nodo Lightning completo, será necesario utilizar un servidor o un ordenador de sobremesa, ya que los dispositivos móviles y los ordenadores portátiles no suelen ser lo suficientemente potentes en términos de capacidad, procesamiento, duración de la batería y conectividad.

La categoría de nodos Lightning de terceros puede subdividirse de nuevo:

Lightweight:: 
 Esto significa que el monedero no opera un nodo Lightning y, por lo tanto, necesita obtener información sobre la Lightning Network a través de Internet del nodo Lightning de otra persona.
None:: 
 Esto significa que no sólo el nodo Lightning es operado por un tercero, sino que la mayor parte de la billetera es operada por un tercero en la nube. Se trata de un monedero de custodia en el que otra persona controla la custodia de los fondos.

Estas subcategorías se utilizan en <<lnwallet-examples>>.

[role="pagebreak-before"]
Otros términos que necesitan explicación en <<lnwallet-examples>> en la columna "Bitcoin node" son:

Neutrino::
 Este monedero no opera un nodo Bitcoin. En su lugar, se accede a un nodo Bitcoin operado por otra persona (un tercero) a través del Protocolo Neutrino.
Electrum::
 Este monedero no opera un nodo Bitcoin. En su lugar, se accede a un nodo Bitcoin operado por otra persona (un tercero) a través del Protocolo Electrum.
Bitcoin Core::
 Es una implementación de un nodo Bitcoin.
btcd::
 Esta es otra implementación de un nodo Bitcoin.

En <<lnwallet-examples>>, vemos algunos ejemplos de aplicaciones de nodos Lightning y monederos actualmente populares para diferentes tipos de dispositivos. La lista está ordenada primero por tipo de dispositivo y luego alfabéticamente.

[[lnwallet-examples]]
.Examples of popular Lightning wallets
[options="header"]
|===
| Application    | Device  | Lightning node | Bitcoin node          | Keystore
| Blue Wallet    | Mobile  | None        | None                  | Custodial
| Breez Wallet   | Mobile  | Full node   | Neutrino              | Self-custody
| Eclair Mobile  | Mobile  | Lightweight | Electrum              | Self-custody
| lntxbot        | Mobile  | None        | None                  | Custodial
| Muun | Mobile  | Lightweight | Neutrino              | Self-custody
| Phoenix Wallet | Mobile  | Lightweight | Electrum              | Self-custody
| Zeus           | Mobile  | Full node   | Bitcoin Core/btcd     | Self-custody
| Electrum       | Desktop | Full node   | Bitcoin Core/Electrum | Self-custody
| Zap Desktop    | Desktop | Full node   | Neutrino              | Self-custody
| c-lightning    | Server  | Full node   | Bitcoin Core          | Self-custody
| Eclair Server  | Server  | Full node   | Bitcoin Core/Electrum | Self-custody
| lnd            | Server  | Full node   | Bitcoin Core/btcd     | Self-custody
|===

[[testnet-bitcoin]]
==== Testnet Bitcoin.

The Bitcoin system offers an alternative chain for testing purposes called _testnet_, in contrast with the "normal" Bitcoin chain which is referred to as _mainnet_. On testnet, the currency is _testnet bitcoin_ (_tBTC_), which is a worthless copy of bitcoin used exclusively for testing. Every function of Bitcoin is replicated exactly, but the money is worth nothing, so you literally have nothing to lose!

Some Lightning wallets can also operate on testnet, allowing you to make Lightning payments with testnet bitcoin, without risking real funds. This is a great way to experiment with Lightning safely. Eclair Mobile, which Alice uses in this chapter, is one example of a Lightning wallet that supports testnet operation.

You can get some tBTC to play with from a _testnet bitcoin faucet_, which gives out free tBTC on demand. Here are a few testnet faucets:

++++
<ul class="simplelist">
<li><a href="https://coinfaucet.eu/en/btc-testnet/"><em>https://coinfaucet.eu/en/btc-testnet</em></a></li>
<li><a href="https://testnet-faucet.mempool.co/"><em>https://testnet-faucet.mempool.co</em></a></li>
<li><a href="https://bitcoinfaucet.uo1.net/"><em>https://bitcoinfaucet.uo1.net</em></a></li>
<li><a href="https://testnet.help/en/btcfaucet/testnet"><em>https://testnet.help/en/btcfaucet/testnet</em></a></li>
</ul>
++++

Todos los ejemplos de este libro pueden ser replicados exactamente en testnet con tBTC, así que puedes seguirlos si quieres sin arriesgar dinero real.

=== Equilibrio entre complejidad y control.

Los monederos Lightning tienen que lograr un cuidadoso equilibrio entre la complejidad y el control del usuario. Las que dan al usuario el mayor control sobre sus fondos, el mayor grado de privacidad y la mayor independencia de servicios de terceros son necesariamente más complejas y difíciles de manejar. A medida que la tecnología avanza, algunas de estas compensaciones se harán menos duras, y los usuarios podrán obtener más control sin más complejidad. Sin embargo, por el momento, diferentes empresas y proyectos están explorando diferentes posiciones a lo largo de este espectro de control-complejidad, con la esperanza de encontrar el "punto dulce" para los usuarios a los que se dirigen.

A la hora de elegir un monedero, ten en cuenta que aunque no veas estas compensaciones, siguen existiendo. Por ejemplo, muchos monederos intentan eliminar la carga de la gestión del canal de sus usuarios. Para ello, introducen _nodos centrales_ a los que se conectan automáticamente todos sus monederos. Aunque esta solución simplifica la interfaz y la experiencia del usuario, introduce un punto único de fallo (SPoF), ya que estos nodos centrales se vuelven indispensables para el funcionamiento del monedero. Además, depender de un "centro" como éste puede reducir la privacidad del usuario, ya que el centro conoce al remitente y potencialmente (si construye la ruta de pago en nombre del usuario) también al destinatario de cada pago realizado por el monedero del usuario.

En la siguiente sección, volveremos a nuestro primer usuario y recorreremos la configuración de su primer monedero Lightning. Ella ha elegido un monedero que es más sofisticado que los monederos de custodia más fáciles. Esto nos permite mostrar algo de la complejidad subyacente e introducir algunos de los funcionamientos internos de un monedero avanzado. Puede que tu primer monedero ideal esté orientado a la facilidad de uso, aceptando algunas de las compensaciones de control y privacidad. O tal vez usted es más un usuario avanzado y quiere ejecutar sus propios nodos Lightning y Bitcoin como parte de su solución de monedero.

=== Descarga e instalación de un monedero Lightning.

Cuando busques un nuevo monedero de criptomonedas, debes tener mucho cuidado de seleccionar una fuente segura para el software.

Desafortunadamente, muchas aplicaciones de monederos falsos robarán tu dinero, y algunos de ellos incluso encuentran su camino en sitios de software de buena reputación y supuestamente vetados como las tiendas de aplicaciones de Apple y Google. Tanto si está instalando su primer monedero como su décimo, extreme siempre las precauciones. Una aplicación fraudulenta no sólo puede robar el dinero que le confíes, sino que también puede ser capaz de robar claves y contraseñas de otras aplicaciones al comprometer el sistema operativo de tu dispositivo móvil.

Alice utiliza un dispositivo Android y va a utilizar Google Play Store para descargar e instalar el monedero Eclair. Buscando en Google Play, encuentra una entrada para "Eclair Mobile", como se muestra en <<eclair-playstore>>.

[[eclair-playstore]]
.Eclair Mobile in the Google Play Store
image::images/mtln_0201.png["Eclair wallet in the Google Play Store"]


[TIP]
====
Es posible experimentar y probar todo el software de tipo Bitcoin con riesgo cero (excepto su propio tiempo) utilizando bitcoins de testnet. También puedes descargar el monedero de testnet de Eclair para probar Lightning (en testnet) yendo a la Google Play Store.
====

Alice se da cuenta de algunos elementos diferentes en esta página que le ayudan a cerciorarse de que éste es, muy probablemente, el monedero "Eclair Mobile" correcto que está buscando. En primer lugar, la organización ACINQfootnote:[ACINQ: Developers of the Eclair Mobile Lightning wallet.] aparece como desarrollador de este monedero móvil, que Alice sabe por su investigación que es el desarrollador correcto. En segundo lugar, el monedero se ha instalado más de 10.000 veces y tiene más de 320 comentarios positivos. Es poco probable que se trate de una aplicación fraudulenta que se haya colado en Google Play Store. Como tercer paso, se dirige a la página web https://acinq.co[ACINQ]. Comprueba que la página web es segura verificando que la dirección comienza con https, o con el prefijo de un candado en algunos navegadores. En el sitio web, va a la sección de descargas o busca el enlace a la tienda de aplicaciones de Google. Encuentra el enlace y hace clic en él. Comprueba que este enlace la lleva a la misma aplicación en la tienda de aplicaciones de Google. Satisfecha con estos resultados, Alice instala la aplicación Eclair en su dispositivo móvil.

[WARNING]
====
Tenga siempre mucho cuidado al instalar software en cualquier dispositivo. Hay muchos monederos de criptomonedas falsos que no sólo le robarán su dinero, sino que también podrían comprometer todas las demás aplicaciones de su dispositivo.
====

=== Creación de un nuevo monedero.

Cuando Alice abre la aplicación Eclair Mobile por primera vez, se le presenta la opción de "Crear una nueva billetera" o "Importar una billetera existente". Alice creará un nuevo monedero, pero primero vamos a discutir por qué se presentan estas opciones y qué significa importar un monedero existente. 

==== Responsabilidad con Custodia de Llaves.

Como mencionamos al principio de esta sección, Eclair es un monedero _no custodio_, lo que significa que Alice tiene la custodia exclusiva de las claves utilizadas para controlar su bitcoin. Esto también significa que Alice es responsable de proteger y respaldar esas claves. Si Alice pierde las claves, nadie puede ayudarla a recuperar el bitcoin, y se perderán para siempre.

[WARNING]
====
Con el monedero Eclair Mobile, Alice tiene la custodia y el control de las claves y, por lo tanto, la plena responsabilidad de mantener las claves seguras y respaldadas. Si pierde las claves, pierde el bitcoin, ¡y nadie puede ayudarla a recuperarse de esa pérdida!
====

==== Palabras mnemotécnicas.

Al igual que la mayoría de los monederos de Bitcoin, Eclair Mobile proporciona una _frase mnemónica_ (también llamada a veces "semilla" o "frase semilla") para que Alice haga una copia de seguridad. La frase mnemónica consiste en 24 palabras en inglés, seleccionadas aleatoriamente por el software y utilizadas como base para las claves que genera el monedero. Alice puede utilizar la frase mnemotécnica para restaurar todas las transacciones y los fondos del monedero de Eclair Mobile en caso de pérdida del dispositivo móvil, un error de software o una corrupción de la memoria.

[TIP]
====
El término correcto para estas palabras de respaldo es "frase mnemónica". Evitamos el uso del término "semilla" para referirse a una frase mnemónica porque aunque su uso es común, es incorrecto.
====

Cuando Alice elige crear un nuevo monedero, verá una pantalla con su frase mnemotécnica, que se parece a la captura de pantalla de <<eclair-mnemonic>>.

[[eclair-mnemonic]]
.New wallet mnemonic phrase
image::images/mtln_0202.png["New Wallet Mnemonic Phrase"]

En <<eclair-mnemonic>>, hemos ocultado a propósito parte de la frase mnemotécnica para evitar que los lectores de este libro reutilicen la mnemotecnia.

[[mnemonic-storage]]
==== Almacenar la mnemotecnia con seguridad.

Alice debe tener cuidado de almacenar la frase mnemotécnica de manera que se evite el robo pero también la pérdida accidental. La forma recomendada para equilibrar adecuadamente estos riesgos es escribir dos copias de la frase mnemotécnica en papel, con cada una de las palabras numeradas-el orden importa.

Una vez que Alice haya grabado la frase mnemotécnica, después de tocar "OK GOT IT" en su pantalla, se le presentará un cuestionario para asegurarse de que ha grabado correctamente la mnemotecnia. El cuestionario le pedirá tres o cuatro palabras al azar. Alice no se espera un test, pero como ha grabado la mnemotecnia correctamente, pasa sin ninguna dificultad.

Una vez que Alice haya grabado la frase mnemotécnica y haya superado la prueba, deberá guardar cada copia en un lugar seguro y separado, como un cajón del escritorio cerrado con llave o una caja fuerte a prueba de incendios.

[WARNING]
====
Nunca intente un esquema de seguridad "DIY" que se desvíe de alguna manera de la recomendación de mejores prácticas en <<mnemonic-storage>>. No cortes tu mnemónica por la mitad, ni hagas capturas de pantalla, ni la almacenes en unidades USB o en la nube, ni la encriptes, ni intentes ningún otro método no estándar. Inclinarás la balanza de tal manera que te arriesgas a perderla definitivamente. Muchas personas han perdido fondos, no por robo, sino porque intentaron una solución no estándar sin tener la experiencia necesaria para equilibrar los riesgos involucrados. La recomendación de la mejor práctica está cuidadosamente estudiada por los expertos y es adecuada para la gran mayoría de los usuarios.
====

Después de que Alice inicialice su monedero Eclair Mobile, verá un breve tutorial que destaca los distintos elementos de la interfaz de usuario. No replicaremos el tutorial aquí, pero exploraremos todos esos elementos mientras seguimos el intento de Alice de comprar una taza de café.

=== Cargar Bitcoin en el monedero.

Alice tiene ahora un monedero Lightning. ¡Pero está vacía! Ahora se enfrenta a uno de los aspectos más desafiantes de este experimento: tiene que encontrar una manera de adquirir algunos bitcoin y cargarlos en su monedero Eclair.

[TIP]
====
Si Alice ya tiene bitcoin en otro monedero, podría elegir enviar ese bitcoin a su monedero Eclair en lugar de adquirir nuevos bitcoin para cargarlos en su nuevo monedero.
====

[[acquiring-bitcoin]]
==== Adquirir Bitcoin.

Hay varias formas en las que Alice puede adquirir bitcoin:

* Puede cambiar algo de su moneda nacional (por ejemplo, USD) en un intercambio de criptodivisas.
* Puede comprar algo a un amigo, o a un conocido de un encuentro de Bitcoin, a cambio de dinero en efectivo.
* Puede encontrar un _Bitcoin ATM_ en su zona, que actúa como una máquina expendedora, vendiendo bitcoin a cambio de dinero.
[role="pagebreak-before"]
* Puede ofrecer sus habilidades o un producto que venda y aceptar el pago en bitcoin.
* Puede pedir a su empleador o a sus clientes que le paguen en bitcoin.

Todos estos métodos tienen diferentes grados de dificultad, y muchos implican el pago de una cuota. Algunos también requerirán que Alice proporcione documentos de identificación para cumplir con la normativa bancaria local. Sin embargo, con todos estos métodos, Alice podrá recibir bitcoin. 

==== Recibiendo Bitcoin.

Supongamos que Alice ha encontrado un cajero automático de Bitcoin local y ha decidido comprar algo de bitcoin a cambio de dinero en efectivo. Un ejemplo de cajero automático de Bitcoin, uno construido por la empresa Lamassu, se muestra en <<bitcoin-atm>>. Este tipo de cajeros automáticos de Bitcoin aceptan moneda nacional (dinero en efectivo) a través de una ranura para el dinero y envían bitcoin a una dirección de Bitcoin escaneada desde la billetera del usuario utilizando una cámara incorporada.

[[bitcoin-atm]]
.A Lamassu Bitcoin ATM
image::images/mtln_0203.png["Lamassu Bitcoin ATM"]

Para recibir el bitcoin en su monedero Eclair Lightning, Alice tendrá que presentar una dirección Bitcoin del monedero Eclair Lightning al cajero automático. El cajero puede entonces enviar el bitcoin recién adquirido por Alice a esta dirección Bitcoin.

Para ver una dirección de Bitcoin en el monedero Eclair, Alice debe deslizar el dedo hacia la columna de la izquierda titulada SU DIRECCIÓN DE BITCOIN (ver <<eclair-receive>>), donde verá un código de barras cuadrado (llamado _código QR_) y una cadena de letras y números debajo de él.

El código QR contiene la misma cadena de letras y números que se muestra debajo, en un formato fácil de escanear. De esta manera, Alice no tiene que escribir la dirección de Bitcoin. En la captura de pantalla (<<eclair-receive>>), hemos difuminado a propósito ambos, para evitar que los lectores envíen inadvertidamente bitcoin a esta dirección.

[[eclair-receive]]
.Alice's bitcoin address, shown in Eclair
image::images/mtln_0204.png["Eclair bitcoin address QR code"]

[NOTE]
====
Tanto las direcciones Bitcoin como los códigos QR contienen información de detección de errores que evita que cualquier error de escritura o de escaneo produzca una dirección Bitcoin "errónea". Si hay un error en la dirección, cualquier monedero Bitcoin se dará cuenta del error y se negará a aceptar la dirección Bitcoin como válida.
====

[role="pagebreak-before"]
Alice puede llevar su dispositivo móvil al cajero automático y mostrarlo a la cámara incorporada, como se muestra en <<bitcoin-atm-receive>>. Después de introducir algo de dinero en la ranura, ¡recibirá bitcoin en Eclair!

[[bitcoin-atm-receive]]
.Bitcoin ATM scans the QR code
image::images/mtln_0205.png["Bitcoin ATM scans the QR code"]

Alice verá la transacción del cajero en la pestaña HISTORIA DE TRANSACCIONES del monedero Eclair. Aunque Eclair detectará la transacción de bitcoin en apenas unos segundos, la transacción de bitcoin tardará aproximadamente una hora en ser "confirmada" en la blockchain de Bitcoin. Como puedes ver en <<eclair-tx1>>, el monedero Eclair de Alice muestra "6+ conf" debajo de la transacción, indicando que la transacción ha recibido el mínimo requerido de seis confirmaciones, y sus fondos están ahora listos para ser utilizados.

[TIP]
====
El número de confirmaciones de una transacción es el número de bloques minados desde (e incluyendo) el bloque que contenía esa transacción. Seis confirmaciones es la mejor práctica, pero diferentes monederos Lightning pueden considerar un canal abierto después de cualquier número de confirmaciones. Algunos monederos incluso escalan el número de confirmaciones esperadas por el valor monetario del canal.
====

Aunque en este ejemplo Alice utilizó un cajero automático para adquirir su primer bitcoin, los mismos conceptos básicos se aplicarían incluso si utilizara uno de los otros métodos en <<acquiring-bitcoin>>. Por ejemplo, si Alice quisiera vender un producto o prestar un servicio profesional a cambio de bitcoin, sus clientes podrían escanear la dirección de Bitcoin con sus billeteras y pagarle en bitcoin.

[[eclair-tx1]]
.Alice receives bitcoin
image::images/mtln_0206.png["Bitcoin transaction received"]

Del mismo modo, si facturara a un cliente por un servicio ofrecido a través de Internet, Alice podría enviar un correo electrónico o un mensaje instantáneo con la dirección Bitcoin o el código QR a su cliente, y éste podría pegar o escanear la información en un monedero Bitcoin para pagarle.

Alice podría incluso imprimir el código QR y pegarlo en un cartel y mostrarlo públicamente para recibir propinas. Por ejemplo, podría tener un código QR pegado a su guitarra y recibir propinas mientras actúa en la calle. footnote:[Generalmente no es aconsejable reutilizar la misma dirección de Bitcoin para múltiples pagos porque todas las transacciones de Bitcoin son públicas.
Una persona entrometida que pase por allí podría escanear el código QR de Alice y ver cuántas propinas ha recibido ya Alice en esta dirección en la blockchain de Bitcoin.
Afortunadamente, la Lightning Network ofrece soluciones más privadas para esto, que se discutirán más adelante en el libro!].

Finalmente, si Alice compró bitcoin en un intercambio de criptomonedas, podría (y debería) "retirar" el bitcoin pegando su dirección de Bitcoin en el sitio web del intercambio. El intercambio enviará entonces el bitcoin a su dirección directamente 

=== De Bitcoin a Lightning Network.

El bitcoin de Alice está ahora controlado por su monedero Eclair y ha sido registrado en la blockchain de Bitcoin. En este punto, el bitcoin de Alice está _en-cadena_, lo que significa que la transacción ha sido transmitida a toda la red Bitcoin, verificada por todos los nodos Bitcoin, y _minada_ (registrada) en la blockchain Bitcoin.

Hasta ahora, el monedero de Eclair Mobile se ha comportado sólo como un monedero de Bitcoin, y Alice no ha utilizado las características de la Lightning Network de Eclair. Como es el caso de muchos monederos Lightning, Eclair tiende un puente entre Bitcoin y la Lightning Network actuando como monedero Bitcoin y como monedero Lightning.

Ahora, Alice está preparada para empezar a utilizar la Lightning Network llevando su bitcoin fuera de la cadena para aprovechar los pagos rápidos, baratos y privados que ofrece la Lightning Network.

==== Canales de la Lightning Network.

Deslizando el dedo hacia la derecha, Alice accede a la sección LIGHTNING CHANNELS de Eclair. Aquí puede gestionar los canales que conectarán su monedero a la Lightning Network.

Vamos a repasar la definición de un canal LN en este punto, para dejar las cosas un poco más claras. En primer lugar, la palabra "canal" es una metáfora de una _relación financiera_ entre el monedero Lightning de Alice y otro monedero Lightning. Lo llamamos canal porque es un medio para que el monedero de Alice y este otro monedero intercambien muchos pagos entre sí en la Lightning Network (fuera de la cadena) sin comprometer las transacciones en la blockchain de Bitcoin (en la cadena).

El monedero o _nodo_ al que Alicia abre un canal se llama su _par de canal_. Una vez "abierto", un canal puede utilizarse para enviar muchos pagos de ida y vuelta entre el monedero de Alicia y su par de canal.

Además, el channel peer de Alice puede _reenviar_ los pagos a través de otros canales más allá de la Lightning Network. De este modo, Alice puede _encaminar_ un pago a cualquier monedero (por ejemplo, el monedero Lightning de Bob) siempre y cuando el monedero de Alice pueda encontrar un _camino_ viable realizado saltando de canal en canal, hasta llegar al monedero de Bob.

[TIP]
====
No todos los pares del canal son _buenos_ pares para enrutar pagos. Los pares bien conectados podrán enrutar los pagos a través de caminos más cortos hasta el destino, aumentando las posibilidades de éxito. Los pares del canal con amplios fondos podrán enrutar pagos más grandes. 
====

En otras palabras, Alice necesita uno o más canales que la conecten con uno o más nodos de la Lightning Network. No necesita un canal que conecte su billetera directamente con el Café de Bob para enviarle un pago, aunque también puede optar por abrir un canal directo. Cualquier nodo de la Lightning Network puede utilizarse para el primer canal de Alice. Cuanto más conectado esté un nodo, más gente podrá alcanzar Alice. En este ejemplo, ya que queremos demostrar también el enrutamiento de pagos, no haremos que Alice abra un canal directamente a la billetera de Bob. En su lugar, haremos que Alicia abra un canal hacia un nodo bien conectado y que luego utilice ese nodo para reenviar su pago, enrutándolo a través de cualquier otro nodo que sea necesario para llegar a Bob.

Al principio, no hay canales abiertos, así que como vemos en <<eclair-channels>>, la pestaña LIGHTNING CHANNELS muestra una lista vacía. Si te fijas, en la esquina inferior derecha hay un símbolo de más (+), que es un botón para abrir un nuevo canal.

[[eclair-channels]]
.LIGHTNING CHANNELS tab
image::images/mtln_0207.png["LIGHTNING CHANNELS tab"]

[role="pagebreak-before"]
Alice pulsa el símbolo más y se le presentan cuatro formas posibles de abrir un canal:

* Pegar un nodo URI
* Escanear un nodo URI
* Nodo aleatorio
* Nodo ACINQ

Un "URI de nodo" es un Identificador Universal de Recursos (URI) que identifica un nodo específico de Lightning. Alice puede pegar un URI de este tipo desde su portapapeles o escanear un código QR que contenga esa misma información. Un ejemplo de URI de nodo se muestra como un código QR en <<node-URI-QR>> y luego como una cadena de texto.

[[node-URI-QR]]
.Node URI as a QR code
image::images/mtln_0208.png["Lightning node URI QR code",width=120]

[[node-URI-example]]
.node URI
----
0237fefbe8626bf888de0cad8c73630e32746a22a2c4faa91c1d9877a3826e1174@1.ln.aantonop.com:9735
----

Aunque Alice podría seleccionar un nodo Lightning específico, o utilizar la opción "Random node" para que la billetera Eclair seleccione un nodo al azar, seleccionará la opción ACINQ Node para conectarse a uno de los nodos Lightning bien conectados de ACINQ.

La elección del nodo ACINQ reducirá ligeramente la privacidad de Alice, porque dará a ACINQ la capacidad de ver todas las transacciones de Alice. También creará un único punto de fallo, ya que Alice sólo tendrá un canal, y si el nodo ACINQ no está disponible, Alice no podrá realizar pagos. Para mantener las cosas simples al principio, aceptaremos estas compensaciones. En los capítulos siguientes, aprenderemos gradualmente a ganar más independencia y a hacer menos concesiones.

Alice selecciona el nodo ACINQ y está lista para abrir su primer canal en la Lightning Network. 

==== Abrir un canal Lightning.

Cuando Alice selecciona un nodo para abrir un nuevo canal, se le pide que seleccione la cantidad de bitcoin que quiere asignar a este canal. En capítulos posteriores, discutiremos las implicaciones de estas elecciones, pero por ahora, Alice asignará casi todos sus fondos al canal. Dado que tendrá que pagar las tasas de transacción para abrir el canal, seleccionará una cantidad ligeramente inferior a su balance total.footnote:[El monedero Eclair no ofrece una opción para calcular automáticamente las tasas necesarias y asignar la cantidad máxima de fondos a un canal, por lo que Alice tiene que calcularlo ella misma].

Alice asigna 0.018 BTC de su total de 0.020 BTC a su canal y acepta la tarifa por defecto, como se muestra en <<eclair-open-channel>>.

[[eclair-open-channel]]
.Opening a Lightning channel
image::images/mtln_0209.png["Opening a Lightning Channel"]

Una vez que hace clic en ABRIR, su billetera construye la transacción especial de Bitcoin que abre un canal Lightning, conocida como la _transacción de financiación_. La funding transaction en la cadena se envía a la red Bitcoin para su confirmación.

Alice ahora tiene que esperar de nuevo (ver "canal de espera") para que la transacción se registre en la blockchain de Bitcoin. Al igual que con la transacción inicial de Bitcoin que utilizó para adquirir su bitcoin, tiene que esperar seis o más confirmaciones (aproximadamente una hora).

[[eclair-channel-waiting]]
.Waiting for the funding transaction to open the channel
image::images/mtln_0210.png["Waiting for the Funding Transaction to Open the Channel"]

Una vez confirmada la funding transaction, el canal de Alice hacia el nodo ACINQ está abierto, financiado y listo, como se muestra en <<eclair-channel-open>>.

[[eclair-channel-open]]
.Channel is open
image::images/mtln_0211.png["Channel is Open"]

[TIP]
====
¿Te has dado cuenta de que la cantidad del canal parece haber cambiado? No lo ha hecho: el canal contiene 0,018 BTC, pero en el tiempo transcurrido entre las capturas de pantalla, el tipo de cambio del BTC cambió, por lo que el valor en USD es diferente. Puedes elegir mostrar los saldos en BTC o en USD, pero ten en cuenta que los valores en USD se calculan en tiempo real y cambiarán
====

=== Comprando una taza de café usando la Lightning Network.

Alice ya tiene todo listo para empezar a usar la Lightning Network. Como puedes ver, ha costado un poco de trabajo y un poco de tiempo esperando las confirmaciones. Sin embargo, ahora las acciones posteriores son rápidas y fáciles. La Lightning Network permite realizar pagos sin tener que esperar confirmaciones, ya que los fondos se liquidan en segundos.

Alice coge su dispositivo móvil y corre al Café de Bob en su barrio. Está emocionada por probar su nuevo monedero Lightning y utilizarlo para comprar algo.

==== Bob's Cafe.

Bob tiene una sencilla aplicación de punto de venta (PoS) para el uso de cualquier cliente que quiera pagar con bitcoin a través de la Lightning Network. Como veremos en el próximo capítulo, Bob utiliza la popular plataforma de código abierto _BTCPay Server_ que contiene todos los componentes necesarios para una solución de comercio electrónico o venta al por menor, tales como:

* Un nodo Bitcoin que utiliza el software Bitcoin Core
* Un nodo Lightning utilizando el software c-lightning
* Una simple aplicación PoS para una tableta

BTCPay Server facilita la instalación de todo el software necesario, la carga de imágenes y precios de los productos, y el lanzamiento de una tienda rápidamente.

En el mostrador del Café de Bob, hay un dispositivo de tableta que muestra lo que se ve en <<bob-cafe-posapp>>.

[[bob-cafe-posapp]]
.Bob's point-of-sale application
image::images/mtln_0212.png["Bob's Point-of-Sale Application"]

==== Una invoice relámpago.

Alice selecciona la opción Café Latte en la pantalla y se le presenta una _factura relámpago_ (también conocida como "solicitud de pago"), como se muestra en <<bob-cafe-invoice>>.

[[bob-cafe-invoice]]
.Lightning invoice for Alice's latte
image::images/mtln_0213.png["BTCPay Server Lightning invoice"]

[role="pagebreak-before"]
Para pagar la invoice, Alice abre su monedero Eclair y selecciona el botón Enviar (que parece una flecha hacia arriba) en la pestaña HISTORIA DE TRANSACCIONES, como se muestra en <<alice-send-start>>.

[[alice-send-start]]
.Alice selecting Send
image::images/mtln_0214.png["Lightning transaction send",width=300]

[TIP]
====
El término "solicitud de pago" puede referirse a una solicitud de pago de Bitcoin o a una invoice de Lightning, y los términos "invoice" y "solicitud de pago" suelen utilizarse indistintamente. El término técnico correcto es "invoice Lightning", independientemente de cómo se denomine en el monedero.
====

Alice selecciona la opción de "escanear una solicitud de pago", escanea el código QR que aparece en la pantalla de la tableta (ver <<bob-cafe-invoice>>), y se le pide que confirme su pago, como se muestra en <<alice-send-detail>>. 

Alice pulsa PAGAR, y un segundo después, la tableta de Bob muestra un pago exitoso. Alice ha completado su primer pago de LN. Ha sido rápido, barato y fácil. Ahora puede disfrutar de su café con leche comprado con bitcoin a través de un sistema de pago rápido, barato y descentralizado. A partir de ahora, Alice puede simplemente seleccionar un artículo en la pantalla de la tableta de Bob, escanear el código QR con su teléfono móvil, hacer clic en PAGAR y que le sirvan un café, todo ello en cuestión de segundos y sin una transacción en la cadena.

[[alice-send-detail]]
.Alice's send confirmation
image::images/mtln_0215.png["Lightning transaction send confirmation",width=300]

Los pagos Lightning también son mejores para Bob. Está seguro de que se le pagará por el café con leche de Alice sin tener que esperar una confirmación en la cadena. En el futuro, cuando a Alice le apetezca tomarse un café en el Café de Bob, podrá elegir entre pagar con bitcoin en la red Bitcoin o en la Lightning Network. ¿Cuál crees que elegirá?

=== Conclusión.

En este capítulo hemos seguido a Alice mientras descargaba e instalaba su primer monedero Lightning, adquiría y transfería algunos bitcoins, abría su primer canal Lightning y compraba una taza de café haciendo su primer pago en la Lightning Network. En los siguientes capítulos, veremos "bajo cuerda" cómo funciona cada componente de la Lightning Network y cómo el pago de Alice llegó al café de Bob.


[[ch03_How_Lightning_Works]]
== Cómo funciona la Lightning Network.

Ahora que hemos seguido a Alice mientras creaba una billetera Lightning y compraba un café a Bob, miraremos bajo el capó y desentrañaremos los diferentes componentes de la Lightning Network involucrados en ese proceso.
Este capítulo dará una visión general de alto nivel y no profundizará en todos los detalles técnicos.
El objetivo es más bien ayudarte a conocer los conceptos más importantes y los bloques de construcción de la Red Relámpago.

Si tienes experiencia en informática, criptografía, Bitcoin y desarrollo de protocolos, este capítulo debería ser suficiente para que puedas completar los detalles de conexión por ti mismo.
Si tiene menos experiencia, este capítulo le dará una visión general lo suficientemente buena como para que le resulte más fácil entender las especificaciones formales del protocolo, conocidas como BOLTs (Basis of Lightning Technology).
Si es un principiante, este capítulo le ayudará a comprender mejor los capítulos técnicos del libro.

Si necesita un repaso de los fundamentos de Bitcoin, puede encontrar un repaso resumido de los siguientes temas en <<bitcoin_fundamentals_review>>:

* Claves y direcciones
* Funciones Hash
* Firmas digitales
* Estructura de las transacciones
* Entradas y salidas de las transacciones
* Encadenamiento de transacciones
* Guiones de Bitcoin
* Direcciones y scripts multifirma
* Timelocks
* Guiones complejos

Empezaremos con una definición de una sola frase de lo que es la Red Relámpago y la desglosaremos en el resto de este capítulo.

La Lightning Network es una red peer-to-peer de _canales de pago_ implementados como contratos inteligentes en la _Bitcoin blockchain_ así como un protocolo de comunicación que define cómo los participantes configuran y ejecutan estos contratos inteligentes.

[[what_is_payment_channel]]
=== ¿Qué es un payment channel?

Hay varias formas de describir un payment channel, dependiendo del contexto. Empecemos por un nivel alto y luego añadamos algo más de detalle.

Un payment channel es una _relación financiera_ entre dos nodos de la Lightning Network, llamados _socios del canal_. La relación financiera asigna un _balance de fondos_ (denominado en milisatoshis), entre los dos socios del canal.

El payment channel se gestiona mediante un _protocolo criptográfico_, lo que significa que los socios del canal utilizan un proceso predefinido basado en la criptografía para redistribuir el balance del canal a favor de uno u otro socio del canal. El protocolo criptográfico garantiza que un socio del canal no pueda engañar al otro, por lo que los socios no necesitan confiar entre sí.

El protocolo criptográfico se establece mediante la financiación de una _dirección de firma múltiple_ 2-de-2 que obliga a los dos socios del canal a cooperar e impide que cualquiera de ellos gaste los fondos unilateralmente.

En resumen: un payment channel es una relación financiera entre nodos, que asigna fondos de una dirección multifirma a través de un protocolo criptográfico estrictamente definido.

=== Conceptos básicos del payment channel.

La base del payment channel es simplemente una dirección multifirma 2-de-2 en el blockchain de Bitcoin, para la cual usted tiene una clave y su socio de canal tiene la otra clave.

Usted y su socio de canal negocian una secuencia de transacciones que gastan desde esta dirección multifirma. En lugar de transmitir y registrar estas transacciones en la blockchain de Bitcoin, ambos las conservan, sin gastarlas.

La última transacción de esa secuencia codifica el balance del canal y define cómo se divide ese balance entre usted y su socio del canal.

Por lo tanto, añadir una nueva transacción a esta secuencia equivale a mover una parte del balance del canal de un socio del canal al otro, sin que la red Bitcoin lo sepa. Al negociar cada nueva transacción, cambiando la asignación de fondos en el canal, también se revoca la transacción anterior, de modo que ninguna de las partes puede retroceder a un estado anterior.

Cada transacción en la secuencia hace uso del lenguaje de scripting de Bitcoin, y así la negociación de fondos entre usted y su socio del canal es gestionada por un contrato inteligente de Bitcoin.
El contrato inteligente está configurado para penalizar a un miembro del canal si intenta presentar un estado previamente revocado del canal.

[NOTE]
====
Si usted tiene una transacción no publicada de una dirección multifirma 2-de-2 que le paga parte del balance, entonces una firma de la otra parte le asegura que puede publicar independientemente esta transacción en cualquier momento añadiendo su propia firma.

La capacidad de mantener una transacción parcialmente firmada, sin conexión y sin publicar, con la opción de publicar y poseer ese balance en cualquier momento, es la base de la Lightning Network.
==== 

=== Enrutamiento de pagos a través de canales.

Una vez que varios participantes tienen canales de una parte a otra, los pagos también pueden ser "reenviados" de un payment channel a otro estableciendo una _ruta_ a través de la red que conecte varios canales de pago.

Por ejemplo, Alice puede enviar dinero a Charlie si Alice tiene un canal con Bob y Bob tiene un canal con Charlie.

Por el diseño de la Lightning Network, es posible ampliar los contratos inteligentes que operan el canal para que Bob no tenga forma de robar los fondos que se envían a través de su canal.

De la misma manera que el contrato inteligente protege a los socios del canal para que no tengan que confiar los unos en los otros, toda la red protege a los participantes para que puedan reenviar los pagos sin confiar en ninguno de los otros participantes.

Dado que los canales se construyen a partir de direcciones multifirma y que las transacciones de actualización de balance son transacciones Bitcoin prefirmadas, toda la confianza necesaria para el funcionamiento de la Lightning Network proviene de la confianza en la red Bitcoin descentralizada.

Las innovaciones mencionadas anteriormente son sin duda los principales avances que permitieron la creación de la Lightning Network.
Sin embargo, la Red Relámpago es mucho más que los protocolos criptográficos sobre el lenguaje Bitcoin Script.
Es un protocolo de comunicación integral que permite a los pares intercambiar mensajes Lightning para lograr la transferencia de bitcoin.
El protocolo de comunicación define cómo se cifran e intercambian los mensajes Lightning.

La Lightning Network también utiliza un gossip protocol para distribuir información pública sobre los canales (topología de la red) a todos los participantes.

Alice, por ejemplo, necesita la información sobre la topología de la red para conocer el canal entre Bob y Charlie, de modo que pueda construir una ruta hacia Charlie.

Por último, pero no por ello menos importante, es importante entender que la Lightning Network no es más que una aplicación sobre Bitcoin, que utiliza transacciones de Bitcoin y Bitcoin Script. No hay ninguna "moneda Lightning" ni "blockchain Lightning".
Más allá de todas las primitivas técnicas, el protocolo LN es una forma creativa de obtener más beneficios de Bitcoin al permitir una cantidad arbitraria de pagos instantáneos con liquidaciones instantáneas sin la necesidad de tener que confiar en nadie más que en la red Bitcoin.

=== Canales de pago.

Como vimos en el capítulo anterior, Alice utilizó el software de su monedero para crear un payment channel entre ella y otro participante de LN.

Un canal sólo está limitado por tres cosas:

* Primero, el tiempo que tarda Internet en transferir los pocos cientos de bytes de datos que requiere el protocolo para mover los fondos de un extremo del canal al otro.

* En segundo lugar, la capacidad del canal, es decir, la cantidad de bitcoin que se compromete en el canal cuando se abre

* Tercero, el límite de tamaño máximo de una transacción de Bitcoin también limita el número de pagos incompletos (en progreso) que pueden ser transportados simultáneamente a través de un canal.

Los canales de pago tienen algunas propiedades muy interesantes y útiles:

* Dado que el tiempo de actualización de un canal está limitado principalmente por la velocidad de comunicación de Internet, realizar un pago en un payment channel puede ser casi instantáneo.

* Si el canal está abierto, realizar un pago no requiere la confirmación de los bloques de Bitcoin. De hecho, mientras usted y su socio del canal sigan el protocolo, no se requiere ninguna interacción con la red Bitcoin ni con nadie más que su socio del canal. 

[role="pagebreak-before"]
* El protocolo criptográfico está construido de tal manera que se necesita poca o ninguna confianza entre usted y su socio de canal. Si su socio no responde o intenta engañarle, puede pedir al sistema Bitcoin que actúe como un "tribunal", resolviendo el contrato inteligente que usted y su socio han acordado previamente.

* Los pagos realizados en un payment channel sólo los conocen usted y su socio. En ese sentido, ganas privacidad en comparación con Bitcoin, donde cada transacción es pública.  Sólo el balance final, que es la suma de todos los pagos en ese canal, será visible en la blockchain de Bitcoin.

Bitcoin tenía unos cinco años de vida cuando los desarrolladores con talento descubrieron por primera vez cómo se podían construir canales de pago bidireccionales, de vida indefinida y enrutables, y en la actualidad existen al menos tres métodos diferentes conocidos.

Este capítulo se centrará en el método de construcción de canales descrito por primera vez en el https://lightning.network/lightning-network-paper.pdf[Lightning Network whitepaper] por Joseph Poon y Thaddeus Dryja en 2015. Estos se conocen como canales _Poon-Dryja_, y son el método de construcción de canales que se utiliza actualmente en la Red del Rayo.
Los otros dos métodos propuestos son los canales _Duplex Micropayment_, introducidos por Christian Decker más o menos al mismo tiempo que los canales Poon-Dryja y los canales _eltoo_, introducidos en https://blockstream.com/eltoo.pdf["eltoo: A Simple Layer2 Protocol for Bitcoin"] por Christian Decker, Rusty Russel, y (coautor de este libro) Olaoluwa Osuntokun en 2018.

Los canales de eltoo tienen algunas propiedades interesantes y simplifican la implementación de los canales de pago. Sin embargo, los canales de eltoo requieren un cambio en el lenguaje Bitcoin Script y, por lo tanto, no pueden ser implementados en la red principal de Bitcoin a partir de 2020.

==== Dirección Multifirma.

Los canales de pago se construyen sobre direcciones multifirma 2-de-2.

En resumen, una dirección multifirma es aquella en la que el bitcoin está bloqueado de forma que requiere múltiples firmas para desbloquearlo y gastarlo. En una dirección multifirma 2-de-2, como se utiliza en la Lightning Network, hay dos firmantes participantes y _ambos_ necesitan firmar para gastar los fondos.

Los scripts y direcciones multifirma se explican con más detalle en <<multisig>>.

[role="pagebreak-before less_space"]
==== Transacción de financiación.

El bloque de construcción fundamental de un payment channel es una dirección multifirma 2-de-2. Uno de los dos socios del canal financiará el payment channel enviando bitcoin a la dirección multifirma. Esta transacción se denomina _transacción de financiación_, y se registra en la blockchain de Bitcoin.footnote:[Mientras que el documento técnico original de Lightning describía canales financiados por ambos socios del canal, la especificación actual, a partir de 2020, asume que sólo un socio compromete fondos para el canal. A partir de mayo de 2021, los canales Lightning financiados por ambos socios son experimentales en la implementación de c-lightning LN].

Aunque la funding transaction es pública, no es obvio que sea un payment channel Lightning hasta que se cierre, a menos que el canal se anuncie públicamente. Los canales suelen ser anunciados públicamente por los nodos de enrutamiento que desean reenviar los pagos. Sin embargo, también existen canales no anunciados, y suelen ser creados por nodos móviles que no participan activamente en el enrutamiento. Además, los pagos del canal siguen sin ser visibles para nadie más que los socios del canal, ni la distribución del balance del canal entre ellos.

La cantidad depositada en la dirección multifirma se denomina _capacidad del canal_ y establece la cantidad máxima que se puede enviar a través del payment channel. Sin embargo, dado que los fondos pueden enviarse de un lado a otro, la capacidad del canal no es el límite superior de la cantidad de valor que puede fluir a través del canal. Esto se debe a que si la capacidad del canal se agota con los pagos en una dirección, se puede utilizar para enviar pagos en la dirección opuesta de nuevo.


[NOTE]
====
Los fondos enviados a la dirección multifirma en la funding transaction se denominan a veces "bloqueados en un canal Lightning". Sin embargo, en la práctica, los fondos en un canal Lightning no están "bloqueados" sino "liberados". Los fondos del canal Lightning son más líquidos que los fondos en la blockchain de Bitcoin, ya que pueden gastarse más rápido, más barato y de forma más privada. Hay algunas desventajas de mover fondos a la Lightning Network (como la necesidad de mantenerlos en una billetera "caliente"), pero la idea de "bloquear fondos" en Lightning es engañosa.
==== 

===== Ejemplo de un mal procedimiento de apertura de canales.

Si piensa detenidamente en las direcciones multifirma 2 de 2, se dará cuenta de que poner sus fondos en una dirección de este tipo parece conllevar cierto riesgo. ¿Qué pasa si su socio de canal se niega a firmar una transacción para liberar los fondos? ¿Están atrapados para siempre? Veamos ahora ese escenario y cómo lo evita el protocolo LN.

Alice y Bob quieren crear un payment channel. Cada uno crea un par de claves privadas/públicas y luego intercambian las claves públicas. Ahora, pueden construir una multifirma 2-de-2 con las dos claves públicas, formando la base de su payment channel.

A continuación, Alice construye una transacción de Bitcoin enviando unos cuantos mBTC a la dirección multifirma creada a partir de las claves públicas de Alice y Bob. Si Alice no da ningún paso adicional y simplemente difunde esta transacción, tiene que confiar en que Bob proporcionará su firma para gastar desde la dirección multifirma. Bob, por otro lado, tiene la posibilidad de chantajear a Alice reteniendo su firma y negando a Alice el acceso a sus fondos.

Para evitarlo, Alice tendrá que crear una transacción adicional que gaste desde la dirección multifirma, reembolsando sus mBTC. Alice entonces hace que Bob firme la transacción de reembolso _antes_ de emitir su funding transaction a la red Bitcoin. De esta manera, Alice puede obtener un reembolso incluso si Bob desaparece o no coopera.

La transacción de "reembolso" que protege a Alice es la primera de una clase de transacciones llamadas _transacciones de compromiso_, que examinaremos con más detalle a continuación.

==== Transacción de compromiso.

Una _transacción de compromiso_ es una transacción que paga a cada socio de canal su balance de canal y asegura que los socios de canal no tengan que confiar entre sí. Al firmar una commitment transaction, cada socio del canal se "compromete" con el balance actual y da al otro socio del canal la posibilidad de recuperar sus fondos cuando lo desee.

Al mantener una commitment transaction firmada, cada socio del canal puede obtener sus fondos incluso sin la cooperación del otro socio del canal. Esto les protege contra la desaparición del otro socio del canal, su negativa a cooperar o su intento de engañar violando el protocolo del payment channel.

La commitment transaction que Alice preparó en el ejemplo anterior fue un reembolso de su pago inicial a la dirección de la multifirma. Sin embargo, de forma más general, una commitment transaction divide los fondos del payment channel, pagando a los dos socios del canal según la distribución (balance) que cada uno tiene. Al principio, Alice tiene todo el balance, por lo que se trata de un simple reembolso. Pero a medida que los fondos fluyan de Alice a Bob, intercambiarán firmas para nuevas transacciones de compromiso que representen la nueva distribución del balance, con una parte de los fondos pagados a Alice y otra a Bob.

Supongamos que Alice abre un canal con una capacidad de 100.000 satoshi con Bob.
Inicialmente, Alice posee 100.000 satoshi, la totalidad de los fondos del canal. Así es como funciona el protocolo del payment channel:

. Alice crea un nuevo par de claves privadas/públicas e informa a Bob de que desea abrir un canal a través del mensaje `open_channel` (un mensaje en el protocolo LN).
. Bob también crea un nuevo par de claves privadas/públicas y se compromete a aceptar un canal de Alice, enviando su clave pública a Alice a través del mensaje `accept_channel`.
. Alice crea ahora una funding transaction desde su billetera que envía 100k satoshi a la dirección de la multifirma con un script de bloqueo: +2 <PubKey Alice> <PubKey Bob> 2 CHECKMULTISIG+.
. Alice aún no difunde esta funding transaction pero envía a Bob el ID de la transacción en un mensaje `funding_created` junto con su firma para la commitment transaction de Bob.
. Tanto Alice como Bob crean su versión de una commitment transaction. Esta transacción gastará de la funding transaction y enviará todos los bitcoins a una dirección controlada por Alice.
. Alice y Bob no necesitan intercambiar estas transacciones de compromiso, ya que cada uno sabe cómo se construyen y pueden construir ambas independientemente (porque han acordado un orden canónico de las entradas y salidas). Sólo necesitan intercambiar firmas.
. Bob proporciona una firma para la commitment transaction de Alice y la devuelve a Alice a través del mensaje `funding_signed`.
. Ahora que las firmas se han intercambiado, Alice difundirá la funding transaction a la red Bitcoin.

Siguiendo este protocolo, Alice no renuncia a la propiedad de sus 100k satoshi a pesar de que los fondos se envían a una dirección multifirma 2-de-2 para la que Alice controla sólo una clave.
Si Bob deja de responder a Alice, ésta podrá emitir su commitment transaction y recibir sus fondos de vuelta.
Sus únicos costes son las tasas de las transacciones en la cadena.
Mientras siga el protocolo, éste es su único riesgo al abrir un canal. 

Después de este intercambio inicial, se crean transacciones de compromiso cada vez que cambia el balance del canal. En otras palabras, cada vez que se envía un pago entre Alice y Bob, se crean nuevas transacciones de compromiso y se intercambian firmas. Cada nueva commitment transaction codifica el último balance entre Alicia y Bob.

Si Alice quiere enviar 30k satoshi a Bob, ambos crearían una nueva versión de sus transacciones de compromiso, que ahora pagaría 70k satoshi a Alice y 30k satoshi a Bob. Al codificar un nuevo balance para Alice y Bob, las nuevas transacciones de compromiso son el medio por el que se "envía" un pago a través del canal.

Ahora que entendemos las transacciones de compromiso, veamos algunos de los detalles más sutiles. Puedes notar que este protocolo deja una manera para que Alice o Bob hagan trampa.

==== Engañar con el estado anterior.

¿Cuántas transacciones de compromiso tiene Alice después de pagar 30k satoshi a Bob? Tiene dos: la original que le paga 100k satoshi y la más reciente, que le paga 70k satoshi y a Bob 30k satoshi.

En el protocolo del canal que hemos visto hasta ahora, nada impide a Alice publicar una commitment transaction anterior. Una Alicia tramposa podría publicar la commitment transaction que le otorga 100k satoshi.
Como esa commitment transaction fue firmada por Bob, no puede impedir que Alice la transmita.

Se necesita algún mecanismo para evitar que Alice publique una commitment transaction anterior. Averigüemos ahora cómo se puede lograr esto y cómo permite que la Lightning Network funcione sin requerir ninguna confianza entre Alice y Bob.

Como Bitcoin es resistente a la censura, nadie puede impedir que alguien publique una commitment transaction antigua. Para evitar esta forma de engaño, las transacciones de compromiso se construyen de manera que si se transmite una antigua, el tramposo puede ser castigado. Al hacer que la penalización sea lo suficientemente grande, creamos un fuerte incentivo contra el engaño, y esto hace que el sistema sea seguro.

La forma en que funciona la penalización es dando a la parte engañada la oportunidad de reclamar el balance del tramposo. Así, si alguien intenta hacer trampas emitiendo una commitment transaction antigua, en la que se le paga un balance más alto del que le corresponde, la otra parte puede castigarle tomando _tanto_ su propio balance como el del tramposo. El tramposo lo pierde todo.

[TIP]
====
Puedes notar que si Alice agota su balance de canal casi por completo, podría entonces intentar hacer trampa con poco riesgo. La penalización de Bob no sería tan dolorosa si su balance de canal es bajo. Para prevenir esto, el protocolo Lightning requiere que cada compañero de canal mantenga un balance mínimo en el canal (llamado la _reserva_) para que siempre tengan "piel en el juego".
====

Repasemos de nuevo el escenario de construcción del canal, añadiendo un mecanismo de penalización para protegerlo de las trampas:

. Alice crea un canal con Bob y pone 100k satoshi en él.
. Alice envía 30k satoshi a Bob.
. Alice trata de engañar a Bob de sus 30k satoshi ganados publicando una vieja commitment transaction reclamando los 100k satoshi completos para ella.
. Bob detecta el fraude y castiga a Alice tomando la totalidad de los 100k satoshi para él.
. Bob termina con 100k satoshi, ganando 70k satoshi por pillar a Alice haciendo trampas.
. Alice termina con 0 satoshi.
. Al intentar engañar a Bob con 30k satoshi, pierde los 70k satoshi que poseía.

Con un fuerte mecanismo de penalización, Alice no se ve tentada a hacer trampas publicando una commitment transaction antigua porque se arriesga a perder todo su balance.

[NOTE]
====
En el capítulo 12 de _Mastering Bitcoin_, Andreas Antonopoulos (el coautor de este libro) lo afirma de la siguiente manera:
"Una característica clave de Bitcoin es que una vez que una transacción es válida, sigue siendo válida y no caduca. La única forma de anular una transacción es gastando dos veces sus entradas con otra transacción antes de que sea minada."
====

Ahora que entendemos _por qué_ es necesario un mecanismo de penalización y cómo evitará las trampas, veamos _cómo_ funciona en detalle.

Normalmente, la commitment transaction tiene al menos dos salidas, pagando a cada socio del canal. Nosotros cambiamos esto para añadir un _retraso de bloqueo de tiempo_ y un _secreto de revocación_ a uno de los pagos. El bloqueo de tiempo evita que el propietario de la salida la gaste inmediatamente una vez que la commitment transaction se incluye en un bloque. El secreto de revocación permite a cualquiera de las partes gastar inmediatamente ese pago, saltándose el bloqueo temporal.

Así, en nuestro ejemplo, Bob tiene una commitment transaction que paga a Alice _inmediatamente_, pero su propio pago se retrasa y es revocable. Alice también tiene una commitment transaction, pero la suya es lo contrario: paga a Bob inmediatamente, pero su propio pago se retrasa y es revocable. 

Los dos socios del canal tienen la mitad del secreto de revocación, de modo que ninguno conoce el secreto completo. Si comparten su mitad, el otro socio del canal tiene el secreto completo y puede utilizarlo para ejercer la condición de revocación. Al firmar una nueva commitment transaction, cada socio del canal revoca el compromiso anterior dando a la otra parte su mitad del secreto de revocación.

Examinaremos el mecanismo de revocación con más detalle en <<revocation>>, donde aprenderemos los detalles de cómo se construyen y utilizan los secretos de revocación.

En términos simples, Alice firma la nueva commitment transaction de Bob sólo si Bob ofrece su mitad del secreto de revocación para el compromiso anterior. Bob sólo firma la nueva commitment transaction de Alice si ella le da su mitad del secreto de revocación del compromiso anterior.

Con cada nuevo compromiso, intercambian el secreto de "castigo" necesario que les permite efectivamente _revocar_ la commitment transaction anterior haciendo que no sea rentable transmitirla. Esencialmente, destruyen la capacidad de utilizar los compromisos anteriores mientras firman los nuevos. Lo que queremos decir es que, aunque sigue siendo técnicamente posible utilizar compromisos antiguos, el mecanismo de penalización hace que sea económicamente irracional hacerlo.

El bloqueo temporal se establece en un número de bloques de hasta 2.016 (aproximadamente dos semanas). Si cualquiera de los socios del canal publica una commitment transaction sin cooperar con el otro socio, tendrá que esperar ese número de bloques (por ejemplo, dos semanas) para reclamar su balance. El otro socio del canal puede reclamar su propio balance en cualquier momento. Además, si el compromiso que publicaron fue revocado previamente, el socio del canal puede _también_ reclamar inmediatamente el balance de la parte que hizo la trampa, saltándose el bloqueo de tiempo y castigando al tramposo.

El bloqueo de tiempo es ajustable y puede ser negociado entre los socios del canal. Normalmente, es más largo para los canales de mayor capacidad, y más corto para los canales más pequeños, para alinear los incentivos con el valor de los fondos.

Para cada nueva actualización del balance del canal, hay que crear y guardar nuevas transacciones de compromiso y nuevos secretos de revocación. Mientras un canal permanezca abierto, todos los secretos de revocación _creados_ para el canal deben guardarse porque podrían necesitarse en el futuro. Afortunadamente, los secretos son bastante pequeños y sólo los socios del canal necesitan guardarlos, no toda la red. Además, debido a un mecanismo de derivación inteligente utilizado para derivar los secretos de revocación, sólo necesitamos almacenar el secreto más reciente, porque los secretos anteriores pueden derivarse de él (véase <<revocation_secret_derivation>>).

No obstante, la gestión y el almacenamiento de los secretos de revocación es una de las partes más elaboradas de los nodos Lightning que requieren que los operadores de los nodos mantengan copias de seguridad.

[NOTE]
====
Tecnologías como los servicios de torre de vigilancia o el cambio del protocolo de construcción de canales al protocolo eltoo podrían ser estrategias futuras para mitigar estos problemas y reducir la necesidad de secretos de revocación, transacciones de penalización y copias de seguridad de los canales.
====

Alice puede cerrar el canal en cualquier momento si Bob no responde, reclamando su parte justa del balance.
Después de publicar la _última_ commitment transaction en la cadena, Alice tiene que esperar a que el bloqueo de tiempo expire antes de poder gastar sus fondos de la commitment transaction. Como veremos más adelante, hay una manera más fácil de cerrar un canal sin esperar, siempre y cuando Alice y Bob estén en línea y cooperen para cerrar el canal con la asignación de balance correcta. Pero las transacciones de compromiso almacenadas por cada socio del canal actúan como un seguro contra fallos, asegurando que no pierden fondos si hay un problema con su socio del canal.

==== Anunciar el canal.

Los socios del canal pueden acordar anunciar su canal a toda la Lightning Network, convirtiéndolo en un _canal público_. Para anunciar el canal, utilizan el gossip protocol de la Lightning Network para informar a otros nodos de la existencia, la capacidad y las fees del canal.

Anunciar los canales públicamente permite que otros nodos los utilicen para el enrutamiento de pagos, generando así también fees de enrutamiento para los socios del canal.

Por el contrario, los socios del canal pueden decidir no anunciar el canal, convirtiéndolo en un canal _no anunciado_.


[NOTE]
====
Es posible que escuche el término "private channel" para describir un canal no anunciado. Evitamos usar ese término porque es engañoso y crea una falsa sensación de privacidad. Aunque un canal no anunciado no será conocido por otros mientras esté en uso, su existencia y capacidad serán reveladas cuando el canal se cierre porque esos detalles serán visibles en la cadena en la transacción de liquidación final. Su existencia también puede filtrarse de otras maneras, por lo que evitamos llamarlo "privado".
==== 

Los canales no anunciados se siguen utilizando para enrutar pagos, pero sólo por los nodos que conocen su existencia, o que reciben "pistas de enrutamiento" sobre una ruta que incluye un canal no anunciado.

Cuando un canal y su capacidad se anuncian públicamente mediante el gossip protocol, el anuncio también puede incluir información sobre el canal (metadatos), como sus fees de enrutamiento y la duración del bloqueo temporal.

Cuando los nuevos nodos se unen a la Lightning Network, recogen los anuncios de canales propagados a través del gossip protocol de sus compañeros, construyendo un mapa interno de la Lightning Network. Este mapa puede utilizarse para encontrar rutas de pago, conectando los canales de extremo a extremo.

==== Cerrar el canal.

La mejor manera de cerrar un canal es... ¡no cerrarlo!
La apertura y el cierre de canales requiere una transacción en la cadena, que incurrirá en gastos de transacción.
Así que es mejor mantener los canales abiertos el mayor tiempo posible.
Puedes seguir usando tu canal para hacer y reenviar pagos, siempre y cuando tengas suficiente capacidad en tu extremo del canal.
Pero incluso si envías todo el balance al otro extremo del canal, puedes utilizarlo para recibir pagos de tu socio de canal.
Este concepto de utilizar un canal en una dirección y luego utilizarlo en la dirección opuesta se llama "reequilibrio", y lo examinaremos con más detalle en otro capítulo.
Al reequilibrar un canal, éste puede mantenerse abierto casi indefinidamente y utilizarse para un número esencialmente ilimitado de pagos.


Sin embargo, a veces es conveniente o necesario cerrar un canal. Por ejemplo:

* Desea reducir el balance mantenido en sus canales Lightning por razones de seguridad y desea enviar los fondos a un "cold storage".
* Su socio de canal no responde durante mucho tiempo y ya no puede utilizar el canal.
* El canal no se utiliza con frecuencia porque su socio de canal no es un nodo bien conectado, por lo que desea utilizar los fondos para otro canal con un nodo mejor conectado.
* Su socio de canal ha violado el protocolo, ya sea debido a un error de software o a propósito, lo que le obliga a cerrar el canal para proteger sus fondos.

Hay tres formas de cerrar un payment channel:

* Cierre mutuo (la forma buena)
* Forzar el cierre (la forma mala)
* Violación del protocolo (la forma fea)

Cada uno de estos métodos es útil para diferentes circunstancias, que exploraremos en las siguientes secciones de este capítulo.
Por ejemplo, si su socio de canal está fuera de línea, no podrá seguir "el camino bueno" porque un cierre mutuo no puede hacerse sin un socio cooperante.
Normalmente, su software de LN seleccionará automáticamente el mejor mecanismo de cierre disponible según las circunstancias.

===== Cierre mutuo (the good way).

El cierre mutuo es cuando ambos socios del canal están de acuerdo en cerrar un canal, y es el método preferido de cierre del canal.

Cuando decidas que quieres cerrar un canal, tu nodo LN informará a tu socio de canal sobre tu intención.
Ahora, tanto su nodo como el del socio del canal trabajan juntos para cerrar el canal.
No se aceptarán nuevos intentos de enrutamiento de ninguno de los dos socios del canal, y cualquier intento de enrutamiento en curso se resolverá o se eliminará después de que se agote el tiempo.
La finalización de los intentos de enrutamiento lleva tiempo, por lo que un cierre mutuo también puede tardar en completarse.

Una vez que no hay intentos de enrutamiento pendientes, los nodos cooperan para preparar una _transacción de cierre_.
Esta transacción es similar a la commitment transaction: codifica el último balance de la cadena, pero las salidas NO están gravadas con un bloqueo de tiempo.

Los honorarios de la transacción en la cadena para la transacción de cierre son pagados por el socio del canal que abrió el canal y no por el que inició el procedimiento de cierre.
Utilizando el estimador de honorarios en la cadena, los socios del canal se ponen de acuerdo sobre los honorarios apropiados y ambos firman la transacción de cierre.

Una vez que la transacción de cierre es emitida y confirmada por la red Bitcoin, el canal está efectivamente cerrado y cada socio del canal ha recibido su parte del balance del canal.
A pesar del tiempo de espera, un cierre mutuo es normalmente más rápido que un cierre forzado. 

===== Forzar el cierre (a la mala).

Un cierre forzado es cuando un socio del canal intenta cerrar un canal sin el consentimiento del otro socio del canal.

Esto suele ocurrir cuando uno de los socios del canal es inalcanzable, por lo que un cierre mutuo no es posible.
En este caso, usted iniciaría un cierre forzado para cerrar unilateralmente el canal y "liberar" los fondos.

Para iniciar un cierre forzado, puede simplemente publicar la última commitment transaction que tenga su nodo.
Después de todo, para eso están las transacciones de compromiso, ya que ofrecen una garantía de que no necesitas confiar en tu socio de canal para recuperar el balance de tu canal.

Una vez que usted emite la última commitment transaction a la red Bitcoin y ésta es confirmada, creará dos salidas gastables, una para usted y otra para su socio.
Como hemos comentado anteriormente, la red Bitcoin no tiene forma de saber si esta era la commitment transaction más reciente o una antigua que se publicó para robar a su socio.
Por lo tanto, esta commitment transaction dará una ligera ventaja a su socio.
El socio que inició el cierre forzado tendrá su salida gravada por un bloqueo de tiempo, y la salida del otro socio será gastable inmediatamente.
En el caso de que usted haya emitido una commitment transaction anterior, el retraso del bloqueo de tiempo le da a su socio la oportunidad de disputar la transacción usando el secreto de revocación y castigarlo por hacer trampa.

Al publicar una commitment transaction durante un cierre forzado, las fees en la cadena serán más altas que en un cierre mutuo por varias razones:

. Cuando se negoció la commitment transaction, los socios del canal no sabían a cuánto ascenderían las comisiones en la cadena en el momento futuro en que se emitiera la transacción. Dado que las comisiones no pueden modificarse sin cambiar las salidas de la commitment transaction (que necesita ambas firmas), y dado que el cierre forzado se produce cuando un socio del canal no está disponible para firmar, los desarrolladores del protocolo decidieron ser muy generosos con la tasa de comisión incluida en las transacciones de compromiso. Puede ser hasta cinco veces superior a lo que sugieren los estimadores de comisiones en el momento de negociar la commitment transaction.
. La commitment transaction incluye salidas adicionales para cualquier intento de enrutamiento pendiente de contratos de tiempo bloqueado de hash (HTLC), lo que hace que la commitment transaction sea más grande (en términos de bytes) que una transacción de cierre mutuo. Las transacciones más grandes incurren en más comisiones.
. Cualquier intento de enrutamiento pendiente tendrá que ser resuelto en la cadena, causando transacciones adicionales en la cadena.

[NOTE]
====
Los contratos Hash con bloqueo de tiempo (HTLCs) serán cubiertos en detalle en <<htlcs>>.
Por ahora, asuma que se trata de pagos que se enrutan a través de la Lightning Network, en lugar de pagos realizados directamente entre los dos socios del canal.
Estos HTLCs se llevan como salidas adicionales en las transacciones de compromiso, aumentando así el tamaño de la transacción y las fees en la cadena.
====

En general, no se recomienda un cierre forzado a menos que sea absolutamente necesario.
Sus fondos quedarán bloqueados durante más tiempo y la persona que abrió la cadena tendrá que pagar comisiones más altas.
Además, es posible que tenga que pagar comisiones en la cadena para abortar o liquidar los intentos de enrutamiento aunque no haya abierto el canal.

Si conoce al socio del canal, puede considerar ponerse en contacto con esa persona o empresa para preguntar por qué su nodo Lightning está caído y pedirle que lo reinicie para poder lograr un cierre mutuo del canal.

Deberías considerar un cierre forzado sólo como último recurso.

===== Violación del protocolo (de la forma más fea).

Una violación del protocolo es cuando su socio del canal intenta engañarle, ya sea deliberadamente o no, publicando una commitment transaction obsoleta en la blockchain de Bitcoin, iniciando esencialmente un cierre forzado (deshonesto) por su parte.

Su nodo debe estar en línea y observar los nuevos bloques y transacciones en la blockchain de Bitcoin para detectar esto.

Debido a que el pago de su socio de canal será gravado por un bloqueo de tiempo, su nodo tiene algún tiempo para actuar para detectar una violación del protocolo y publicar una _transacción de castigo_ antes de que el bloqueo de tiempo expire.

Si detecta con éxito la violación del protocolo y aplica la sanción, recibirá todos los fondos del canal, incluidos los de su socio del canal.

En este escenario, el cierre del canal será bastante rápido.
Tendrás que pagar fees en la cadena para publicar la transacción de castigo, pero tu nodo puede establecer estas fees de acuerdo a la estimación de fees y no pagar de más.
Generalmente querrás pagar tasas más altas para garantizar la confirmación lo antes posible.
Sin embargo, como al final recibirás todos los fondos del tramposo, es esencialmente el tramposo quien pagará por esta transacción. 

Si no detecta el incumplimiento del protocolo y el bloqueo temporal expira, sólo recibirá los fondos asignados por la commitment transaction que su socio publicó.
Cualquier fondo que haya recibido después habrá sido robado por su socio.
Si hay algún balance asignado a usted, tendrá que pagar tasas en la cadena para cobrar ese balance.

Al igual que con un cierre forzado, todos los intentos de enrutamiento pendientes también tendrán que ser resueltos en la commitment transaction.

Una ruptura de protocolo puede ejecutarse más rápidamente que un cierre mutuo porque no hay que esperar a negociar un cierre con su socio, y más rápidamente que un cierre forzado porque no hay que esperar a que expire su timelock.

La teoría de los juegos predice que hacer trampas no es una estrategia atractiva porque es fácil detectar a un tramposo, y éste se arriesga a perder _todos_ sus fondos mientras que sólo puede ganar lo que tenía en un estado anterior.
Además, a medida que la Red Relámpago madure y las torres de vigilancia estén ampliamente disponibles, los tramposos podrán ser detectados por un tercero incluso si el socio del canal engañado está desconectado.

Por lo tanto, no recomendamos hacer trampas.
Sin embargo, recomendamos que quien descubra a un tramposo lo castigue quitándole sus fondos.

Entonces, ¿cómo se puede detectar un tramposo o un incumplimiento del protocolo en las actividades cotidianas?
Lo haces ejecutando un software que monitoriza la blockchain pública de Bitcoin en busca de transacciones en la cadena que se correspondan con cualquier commitment transaction para cualquiera de tus canales.
Este software es de tres tipos:

* Un nodo Lightning debidamente mantenido, que funciona 24/7
* Un nodo watchtower de un solo propósito que usted ejecuta para vigilar sus canales
* Un nodo de vigilancia de terceros al que pagas para que vigile tus canales.

Recuerde que la commitment transaction tiene un período de tiempo de espera especificado en un número determinado de bloques, hasta un máximo de 2.016 bloques.
Siempre que ejecute su nodo Lightning una vez antes de que se alcance el periodo de tiempo de espera, éste atrapará todos los intentos de engaño.
No es aconsejable correr este tipo de riesgo; es importante mantener un nodo bien mantenido que funcione continuamente (ver <<continuous_operation>>).

=== Facturas.

La mayoría de los pagos en la Lightning Network comienzan con una invoice, generada por el receptor del pago. En nuestro ejemplo anterior, Bob crea una invoice para solicitar un pago a Alice.

[NOTE]
====
Existe una forma de enviar un pago no solicitado sin invoice, utilizando una solución en el protocolo llamada +keysend+. Examinaremos esto en <<keysend>>.
====

Una invoice es una simple instrucción de pago que contiene información como un identificador de pago único (llamado hash de pago), un destinatario, un importe y una descripción de texto opcional.

La parte más importante de la invoice es el hash de pago, que permite que el pago viaje a través de múltiples canales de forma _atómica_. Atómico, en informática, significa cualquier acción o cambio de estado que se completa con éxito o no se completa en absoluto - no hay posibilidad de un estado intermedio o acción parcial. En la Red Relámpago, eso significa que el pago recorre todo el camino o fracasa por completo. No puede completarse parcialmente de forma que un nodo intermedio en el camino pueda recibir el pago y quedarse con él.
No existe el concepto de "pago parcial" o "pago parcialmente exitoso".

Las facturas no se comunican a través de la Lightning Network. En su lugar, se comunican "fuera de banda", utilizando cualquier otro mecanismo de comunicación. Esto es similar a cómo se comunican las direcciones de Bitcoin a los remitentes fuera de la red de Bitcoin: como un código QR, por correo electrónico o un mensaje de texto. Por ejemplo, Bob puede presentar una invoice Lightning a Alice como un código QR, por correo electrónico o a través de cualquier otro canal de mensajes.

Las facturas suelen estar codificadas como una cadena larga codificada en __bech32__ o como un código QR, para ser escaneado por un monedero Lightning de un smartphone. La invoice contiene la cantidad de bitcoin que se solicita y una firma del destinatario. El remitente utiliza la firma para extraer la clave pública (también conocida como ID del nodo) del destinatario, de modo que el remitente sabe a dónde enviar el pago.

¿Se ha dado cuenta de que esto contrasta con Bitcoin y de que se utilizan términos diferentes? En Bitcoin, el destinatario pasa una dirección al remitente. En Lightning, el destinatario crea una invoice y envía una invoice al remitente. En Bitcoin, el remitente envía fondos a una dirección. En Lightning, el remitente paga una invoice y el pago se dirige al destinatario. Bitcoin se basa en el concepto de "dirección", y Lightning es una red de pagos basada en el concepto de "invoice". En Bitcoin, creamos una "transacción", mientras que en Lightning enviamos un "pago". 

==== Hash de pago y preimagen.

La parte más importante de la invoice es el _hash de pago_. Al construir la invoice, Bob hará un hash de pago de la siguiente manera:

1. Bob elige un número aleatorio _r_. Este número aleatorio se denomina _preimagen_ o _secreto de pago_.
2. Bob utiliza SHA-256 para calcular el hash _H_ de _r_ llamado el _hash de pago_: _H_ = SHA-256(_r_).

[NOTE]
====
El término _preimagen_ proviene de las matemáticas. En cualquier función y = f(x), el conjunto de entradas que producen un determinado valor _y_ se llama la preimagen de _y_. En este caso, la función es el algoritmo hash SHA-256, y cualquier valor _r_ que produzca el hash _H_ se llama preimagen.
====

No se conoce ninguna forma de encontrar la inversa de SHA-256 (es decir, calcular una preimagen a partir de un hash). Sólo Bob conoce el valor _r_, por lo que es el secreto de Bob. Pero una vez que Bob revela _r_, cualquiera que tenga el hash _H_ puede comprobar que _r_ es el secreto correcto, calculando SHA-256(_r_) y viendo que coincide con _H_.

El proceso de pago de la Lightning Network sólo es seguro si _r_ se elige de forma completamente aleatoria y no es predecible. Esta seguridad se basa en el hecho de que las funciones hash no pueden ser invertidas ni forzadas de forma factible y, por tanto, nadie puede encontrar _r_ a partir de _H_.

==== Metadatos adicionales.

Las facturas pueden incluir opcionalmente otros metadatos útiles, como una breve descripción de texto. Si un usuario tiene varias facturas que pagar, puede leer la descripción y recordar de qué se trata la invoice.

La invoice también puede incluir algunas _pistas de enrutamiento_, que permiten al remitente utilizar canales no anunciados para construir una ruta hacia el destinatario. Las pistas de enrutamiento también pueden utilizarse para sugerir canales públicos, por ejemplo, canales que el destinatario sabe que tienen suficiente capacidad de entrada para enrutar el pago.

En caso de que el nodo Lightning del remitente no pueda enviar el pago a través de la Lightning Network, las facturas pueden incluir opcionalmente una dirección Bitcoin en la cadena como alternativa.

[NOTE]
====
Aunque siempre es posible "recurrir" a una transacción de Bitcoin en la cadena, en realidad es mejor abrir un nuevo canal con el destinatario. Si tiene que incurrir en tasas en la cadena para hacer un pago, también podría incurrir en esas tasas para abrir un canal y hacer el pago a través de Lightning. Una vez realizado el pago, te quedas con un canal abierto que tiene liquidez en el lado del destinatario y que puede utilizarse para dirigir los pagos de vuelta a tu nodo Lightning en el futuro. Una transacción en la cadena te da un pago y un canal para su uso futuro.
====


Las facturas Lightning contienen una fecha de caducidad. Dado que el destinatario debe conservar la preimagen _r_ de cada invoice emitida, es útil que las facturas caduquen para no tener que conservar estas preimágenes para siempre. Una vez que una invoice caduca o se paga, el destinatario puede descartar la preimagen.

=== Entrega del pago.

Hemos visto cómo el destinatario crea una invoice que contiene un hash de pago. Este hash de pago se utilizará para mover el pago a través de una serie de canales de pago, desde el emisor hasta el receptor, incluso si no tienen un payment channel directo entre ellos.

En las próximas secciones, nos sumergiremos en las ideas y métodos que se utilizan para entregar un pago a través de la Lightning Network y utilizar todos los conceptos que hemos presentado hasta ahora.

En primer lugar, veamos el protocolo de comunicación de la Lightning Network.

==== El gossip protocol Peer-to-Peer.

Como hemos mencionado anteriormente, cuando se construye un payment channel, los socios del canal tienen la opción de hacerlo público, anunciando su existencia y detalles a toda la Lightning Network.

Los anuncios de los canales se comunican a través de un protocolo _gossip_ de igual a igual. Un protocolo peer-to-peer es un protocolo de comunicaciones en el que cada nodo se conecta a una selección aleatoria de otros nodos de la red, normalmente a través de TCP/IP. Cada uno de los nodos que están directamente conectados (a través de TCP/IP) a tu nodo se llaman tus _peers_. Tu nodo, a su vez, es uno de sus pares. Ten en cuenta que cuando decimos que tu nodo está conectado a otros pares, no queremos decir que tengas canales de pago, sino sólo que estás conectado a través del gossip protocol.

Después de abrir un canal, un nodo puede optar por enviar un anuncio del canal a través del mensaje `channel_announcement` a sus compañeros.
Cada peer valida la información del mensaje `channel_announcement` y verifica que la funding transaction está confirmada en el blockchain de Bitcoin.
Tras la verificación, el nodo reenviará el mensaje de cotilleo a sus propios compañeros, y éstos lo reenviarán a sus compañeros, y así sucesivamente, difundiendo el anuncio por toda la red.
Para evitar una comunicación excesiva, el anuncio del canal sólo es reenviado por cada nodo si no ha reenviado ya ese anuncio previamente. 

El gossip protocol también se utiliza para anunciar información sobre nodos conocidos con el mensaje `node_announcement`.
Para que este mensaje sea reenviado, un nodo tiene que tener al menos un canal público anunciado en el gossip protocol, de nuevo para evitar un tráfico de comunicación excesivo.

Los canales de pago tienen varios metadatos que son útiles para otros participantes de la red.
Estos metadatos se utilizan principalmente para tomar decisiones de enrutamiento.
Como los nodos pueden cambiar ocasionalmente los metadatos de sus canales, esta información se comparte en un mensaje `channel_update`.
Estos mensajes sólo se envían aproximadamente cuatro veces al día (por canal) para evitar una comunicación excesiva.
El gossip protocol también cuenta con una serie de consultas y mensajes para sincronizar inicialmente un nodo con la vista de la red o para actualizar la vista del nodo después de estar desconectado durante un tiempo.

Un reto importante para los participantes de la Red Relámpago es que la información sobre la topología que comparte el gossip protocol es sólo parcial.
Por ejemplo, la capacidad de los canales de pago se comparte en el gossip protocol a través del mensaje [.keep-together]#`channel_announcement`#.
Sin embargo, esta información no es tan útil como la distribución real de la capacidad en términos de equilibrio local entre los dos socios del canal.
Un nodo sólo puede reenviar la cantidad de bitcoin que realmente posee (balance local) dentro de ese canal.

Aunque la Lightning Network podría haber sido diseñada para compartir la información de balance de los canales y una topología precisa, esto no se ha hecho por varias razones:

* Para proteger la privacidad de los usuarios, no grita cada transacción financiera y pago. Las actualizaciones del balance de los canales revelarían que un pago se ha movido por el canal. Esta información podría correlacionarse para revelar todas las fuentes y destinos de los pagos.

* Escalar la cantidad de pagos que se pueden realizar con la Lightning Network. Recuerde que la Red Relámpago se creó en primer lugar porque notificar a todos los participantes sobre cada pago no se escala bien. Por lo tanto, la Red Relámpago no puede diseñarse de forma que comparta las actualizaciones del balance del canal entre los participantes.

* La Red Relámpago es un sistema dinámico. Cambia constantemente y con frecuencia. Se añaden nodos, se apagan otros, cambian los saldos, etc. Aunque todo se comunique siempre, la información será válida sólo durante un corto periodo de tiempo. De hecho, la información suele estar obsoleta en el momento en que se recibe.

Examinaremos los detalles del gossip protocol en un capítulo posterior.

Por ahora, sólo es importante saber que el gossip protocol existe y que se utiliza para compartir información sobre la topología de la Lightning Network.
Esta información de topología es crucial para la entrega de pagos a través de la red de canales de pago.


==== Pathfinding and Routing.

Los pagos en la Lightning Network se envían a lo largo de una _ruta_ formada por canales que enlazan a un participante con otro, desde el origen del pago hasta el destino del mismo. El proceso de encontrar un camino desde el origen hasta el destino se denomina _pathfinding_. El proceso de utilizar esa ruta para realizar el pago se denomina _enrutamiento_.

[NOTE]
====
Una crítica frecuente a la Red Relámpago es que el enrutamiento no está resuelto, o incluso que es un problema "irresoluble". De hecho, el enrutamiento es trivial. La búsqueda de rutas, en cambio, es un problema difícil. Los dos términos se confunden a menudo y es necesario definirlos claramente para identificar qué problema intentamos resolver.
====

Como veremos a continuación, la Lightning Network utiliza actualmente un protocolo _basado en la fuente_ para la búsqueda de rutas y un protocolo _enrutado por cebolla_ para el enrutamiento de los pagos. Basado en la fuente significa que el remitente del pago tiene que encontrar un camino a través de la red hasta el destino previsto. Enrutado en forma de cebolla significa que los elementos de la ruta están en capas (como una cebolla), con cada capa encriptada para que sólo pueda ser vista por un nodo a la vez. Hablaremos del onion routing en la siguiente sección.

=== Source-Based Pathfinding.

Si conociéramos los balances exactos de cada canal, podríamos calcular fácilmente una ruta de pago utilizando cualquiera de los algoritmos estándar de búsqueda de rutas que se enseñan en cualquier clase de informática. Incluso podría resolverse de forma que se optimizasen las tasas pagadas a los nodos por reenviar el pago.

Sin embargo, la información de balance de todos los canales no es ni puede ser conocida por todos los participantes de la red. Necesitamos estrategias de búsqueda de rutas más innovadoras.

Con sólo información parcial sobre la topología de la red, la búsqueda de rutas es un verdadero reto, y se sigue investigando activamente esta parte de la Lightning Network. El hecho de que el problema de la búsqueda de rutas no esté "totalmente resuelto" en la Red Relámpago es un punto importante de crítica hacia la tecnología. 

[NOTE]
====
Una de las críticas más comunes a la búsqueda de rutas en la Lightning Network es que no tiene solución porque es equivalente al _problema del vendedor ambulante_ (TSP), un problema fundamental en la teoría de la complejidad computacional. De hecho, el pathfinding en Lightning no es equivalente al TSP y entra en una clase diferente de problemas. Resolvemos con éxito este tipo de problemas (pathfinding en grafos con información incompleta) cada vez que pedimos a Google que nos dé indicaciones para conducir evitando el tráfico. También resolvemos con éxito este problema cada vez que dirigimos un pago en la Lightning Network.
====

La búsqueda de rutas y el enrutamiento pueden implementarse de diferentes maneras, y en la Lightning Network pueden coexistir múltiples algoritmos de búsqueda de rutas y enrutamiento, al igual que existen múltiples algoritmos de búsqueda de rutas y enrutamiento en Internet. La búsqueda de rutas basada en la fuente es una de las muchas soluciones posibles y tiene éxito a la escala actual de la Lightning Network.

La estrategia de búsqueda de rutas implementada actualmente por los nodos Lightning consiste en probar iterativamente rutas hasta encontrar una que tenga suficiente liquidez para reenviar el pago. Se trata de un proceso iterativo de prueba y error, hasta que se consigue el éxito o no se encuentra ninguna ruta. En la actualidad, el algoritmo no da lugar necesariamente a la ruta con las tasas más bajas. Aunque esto no es óptimo y ciertamente puede mejorarse, incluso esta estrategia simplista funciona bastante bien.

Este "sondeo" lo realiza el nodo Lightning o el monedero y no lo ve directamente el usuario.
El usuario sólo se da cuenta de que el sondeo está teniendo lugar si el pago no se completa al instante.

[NOTE]
====
En Internet, utilizamos el Protocolo de Internet y un algoritmo de reenvío de IP para reenviar los paquetes de Internet desde el remitente hasta el destino. Mientras que estos protocolos tienen la agradable propiedad de permitir a los hosts de internet encontrar de forma colaborativa una ruta para el flujo de información a través de internet, no podemos reutilizar y adoptar este protocolo para el reenvío de pagos en la Lightning Network. A diferencia de Internet, los pagos de Lightning tienen que ser _atómicos_, y los saldos de los canales tienen que seguir siendo _privados_. Además, la capacidad del canal en Lightning cambia con frecuencia, a diferencia de Internet, donde la capacidad de conexión es relativamente estática. Estas limitaciones exigen estrategias novedosas.
====

Por supuesto, la búsqueda de rutas es trivial si queremos pagar a nuestro socio de canal directo y tenemos suficiente balance en nuestro lado del canal para hacerlo. En todos los demás casos, nuestro nodo utiliza la información del gossip protocol para realizar la búsqueda de rutas. Esto incluye los canales de pago públicos conocidos actualmente, los nodos conocidos, la topología conocida (cómo están conectados los nodos conocidos), las capacidades conocidas de los canales y las políticas de fees conocidas establecidas por los propietarios de los nodos.

==== Onion Routing.

La Lightning Network utiliza un _protocolo de enrutamiento cebolla_ similar a la famosa red Tor (The Onion Router).
El protocolo de onion routing utilizado en Lightning se denomina _SPHINX Mix Format_,footnote:[George Danezis e Ian Goldberg, "Sphinx: A Compact and Provably Secure Mix Format", en _IEEE Symposium on Security and Privacy_ (Nueva York: IEEE, 2009), 269-282.] que se explicará en detalle en un capítulo posterior.

[NOTE]
====
El Formato Mixto SPHINX de enrutamiento de cebolla de Lightning sólo es similar al enrutamiento de la red Tor en concepto, pero tanto el protocolo como la implementación son completamente diferentes de los utilizados en la red Tor.
====

Un paquete de pago utilizado para el enrutamiento se llama "cebolla". "footnote:[El término "cebolla" fue utilizado originalmente por el proyecto Tor. Además, la red Tor también se llama la red Onion y el proyecto utiliza una cebolla como su logotipo. El nombre de dominio de primer nivel utilizado por los servicios de Tor en Internet es _onion_].

Utilicemos la analogía de la cebolla para seguir un pago enrutado. En su ruta desde el remitente del pago (pagador) hasta el destino del pago (beneficiario), la cebolla pasa de nodo a nodo a lo largo del camino. El remitente construye toda la cebolla, desde el centro hacia fuera. En primer lugar, el remitente crea la información de pago para el destinatario (final) del pago y la encripta con una capa de cifrado que sólo el destinatario puede descifrar. Luego, el remitente envuelve esa capa con instrucciones para el nodo en la ruta _inmediatamente anterior al destinatario final_ y la encripta con una capa que sólo ese nodo puede descifrar.

Las capas se van construyendo con instrucciones, trabajando hacia atrás hasta que toda la ruta está codificada en capas. El remitente entrega entonces la cebolla completa al primer nodo del camino, que sólo puede leer la capa más externa. Cada nodo pela una capa, encuentra las instrucciones en su interior que revelan el siguiente nodo de la ruta, y pasa la cebolla. Como cada nodo pela una capa, no puede leer el resto de la cebolla. Todo lo que sabe es de dónde viene la cebolla y a dónde va después, sin ninguna indicación de quién es el remitente original o el destinatario final. 

Esto continúa hasta que la cebolla llega al destino del pago (beneficiario). Entonces, el nodo de destino abre la cebolla y descubre que no hay más capas que descifrar y puede leer la información del pago que hay dentro.

[NOTE]
====
A diferencia de una cebolla real, al pelar cada capa, los nodos añaden un poco de relleno encriptado para mantener el mismo tamaño de la cebolla para el siguiente nodo. Como veremos, esto hace imposible que ninguno de los nodos intermedios sepa nada sobre el tamaño (longitud) del camino, cuántos nodos participan en el enrutamiento, cuántos nodos les preceden o cuántos les siguen. Esto aumenta la privacidad al impedir los ataques triviales de análisis de tráfico.
====

El protocolo de onion routing utilizado en Lightning tiene las siguientes propiedades

* Un nodo intermediario sólo puede ver en qué canal ha recibido una cebolla y en qué canal debe reenviarla. Esto significa que ningún nodo de enrutamiento puede saber quién inició el pago y a quién está destinado. Esta es la propiedad más importante, que se traduce en un alto grado de privacidad.

* Las cebollas son lo suficientemente pequeñas como para caber en un solo paquete TCP/IP e incluso en una trama de la capa de enlace (por ejemplo, Ethernet). Esto hace que el análisis del tráfico de los pagos sea significativamente más difícil, aumentando aún más la privacidad.

* Las cebollas se construyen de tal manera que siempre tendrán la misma longitud, independientemente de la posición del nodo de procesamiento a lo largo de la ruta. A medida que se "pela" cada capa, la cebolla se rellena con datos "basura" cifrados para mantener el mismo tamaño de la cebolla. Esto evita que los nodos intermedios conozcan su posición en la ruta.

* Las cebollas tienen un HMAC (código de autenticación de mensajes basado en hash) en cada capa, de modo que se evitan y son prácticamente imposibles las manipulaciones de las cebollas.

* Las cebollas pueden tener hasta unos 26 saltos, o capas de cebolla si se prefiere. Esto permite que las rutas sean lo suficientemente largas. La longitud precisa de la ruta disponible depende de la cantidad de bytes asignados a la carga útil de enrutamiento en cada salto.

* El cifrado de la cebolla para cada salto utiliza diferentes claves de cifrado efímero. Si una clave (en particular, la clave privada de un nodo) se filtra en algún momento, un atacante no puede descifrarlas. En términos más sencillos, las claves nunca se reutilizan para conseguir más seguridad.

* Los errores pueden enviarse de vuelta desde el nodo errante al remitente original, utilizando el mismo protocolo de enrutamiento de cebollas. Las cebollas de error son indistinguibles de las cebollas de enrutamiento para los observadores externos y los nodos intermediarios. El enrutamiento por error permite el método de "sondeo" de prueba y error utilizado para encontrar una ruta que tenga suficiente capacidad para enrutar con éxito un pago.

El enrutamiento de cebollas se examinará en detalle en <<onion_routing>>.

==== Algoritmo de reenvío de pagos.

Una vez que el remitente de un pago encuentra una posible ruta a través de la red y construye una cebolla, el pago es reenviado por cada nodo en la ruta. Cada nodo procesa una capa de la cebolla y la reenvía al siguiente nodo de la ruta.

Cada nodo intermediario recibe un mensaje Lightning llamado `update_add_htlc` con un hash de pago y una cebolla. El nodo intermediario ejecuta una serie de pasos, denominados _algoritmo de reenvío de pagos_:

. El nodo descifra la capa exterior de la cebolla y comprueba la integridad del mensaje.

. Confirma que puede cumplir las indicaciones de enrutamiento, basándose en las fees del canal y la capacidad disponible en el canal de salida.

. Trabaja con su socio de canal en el canal de entrada para actualizar el estado del canal.

. Añade algo de relleno al final de la cebolla para mantenerla con una longitud constante, ya que ha eliminado algunos datos del principio.

. Sigue las pistas de enrutamiento para reenviar el paquete de cebolla modificado en su payment channel saliente enviando también un mensaje `update_add_htlc` que incluye el mismo hash de pago y la cebolla.

. Trabaja con su socio de canal en el canal de salida para actualizar el estado del canal.

Por supuesto, estos pasos se interrumpen y abortan si se detecta un error, y se envía un mensaje de error al emisor del mensaje `update_add_htlc`. El mensaje de error también se formatea como una cebolla y se envía hacia atrás en el canal de entrada.

A medida que el error se propaga hacia atrás en cada canal a lo largo de la ruta, los socios del canal eliminan el pago pendiente, haciendo retroceder el pago en el sentido contrario al que comenzó.

Aunque la probabilidad de que un pago falle es alta si no se liquida rápidamente, un nodo nunca debería iniciar otro intento de pago a lo largo de una ruta diferente antes de que la cebolla vuelva con un error. El remitente pagaría dos veces si los dos intentos de pago finalmente tuvieran éxito. 

=== Cifrado de la comunicación entre pares.

El protocolo LN es principalmente un protocolo peer-to-peer entre sus participantes. Como vimos en las secciones anteriores, hay dos funciones superpuestas en la red, formando dos redes lógicas que juntas son _la Red Relámpago_:

1. Una amplia red peer-to-peer que utiliza un gossip protocol para propagar la información de la topología, donde los peers se conectan aleatoriamente entre sí. Los pares no tienen necesariamente canales de pago entre ellos, por lo que no siempre son compañeros de canal.

2. Una red de canales de pago entre socios del canal. Los socios del canal también cotillean sobre la topología, lo que significa que son nodos pares en el gossip protocol.

Toda la comunicación entre pares se envía a través de mensajes llamados _Mensajes relámpago_. Todos estos mensajes están encriptados, utilizando un marco de comunicaciones criptográfico llamado _Marco de Protocolo de Ruido_. El Marco de Protocolo de Ruido permite la construcción de protocolos de comunicación criptográficos que ofrecen autenticación, encriptación, secreto hacia adelante y privacidad de la identidad. El Noise Protocol Framework también se utiliza en varios sistemas populares de comunicaciones cifradas de extremo a extremo, como WhatsApp, WireGuard e I2P. Puede encontrar más información en https://noiseprotocol.org[en el sitio web de Noise Protocol Framework].

El uso del Noise Protocol Framework en la Lightning Network garantiza que todos los mensajes de la red estén autenticados y cifrados, lo que aumenta la privacidad de la red y su resistencia al análisis del tráfico, la inspección profunda de paquetes y las escuchas. Sin embargo, como efecto secundario, esto hace que el desarrollo y las pruebas de los protocolos sean un poco complicados, ya que no se puede simplemente observar la red con una herramienta de captura de paquetes o de análisis de redes como Wireshark. En su lugar, los desarrolladores tienen que utilizar complementos especializados que descifran el protocolo desde la perspectiva de un nodo, como el https://github.com/nayutaco/lightning-dissector[_lightning dissector_], un complemento de Wireshark.

=== Pensamientos sobre la confianza.
Mientras una persona siga el protocolo y tenga su nodo asegurado, no hay mayor riesgo de perder fondos al participar en la Lightning Network.
Sin embargo, existe el coste de pagar tasas en la cadena al abrir un canal.
Todo coste debe ir acompañado de un beneficio correspondiente.
En nuestro caso, la recompensa para Alice por soportar el coste de abrir un canal es que Alice puede enviar y, después de mover algunas de las monedas al otro extremo del canal, recibir pagos de bitcoin en la Lightning Network en cualquier momento, y que puede ganar comisiones en bitcoin reenviando pagos para otras personas.
Alice sabe que, en teoría, Bob puede cerrar el canal inmediatamente después de abrirlo, lo que supone comisiones de cierre en la cadena para Alice.
Alice necesitará tener una pequeña cantidad de confianza en Bob.
Alice ha estado en el Café de Bob y está claro que Bob está interesado en venderle su café, así que Alice puede confiar en Bob en este sentido.
Hay beneficios mutuos tanto para Alice como para Bob.
Alice decide que la recompensa es suficiente para asumir el coste de la tasa en la cadena para crear un canal con Bob.
Por el contrario, Alice no abrirá un canal a alguien desconocido que acaba de enviarle sin invitación un correo electrónico pidiéndole que abra un nuevo canal.

=== Comparación con Bitcoin.

Aunque la Lightning Network está construida sobre Bitcoin y hereda muchas de sus características y propiedades, existen importantes diferencias que los usuarios de ambas redes deben conocer.

Algunas de estas diferencias son diferencias en la terminología. También hay diferencias arquitectónicas y en la experiencia del usuario. En las próximas secciones, examinaremos las diferencias y similitudes, explicaremos la terminología y ajustaremos nuestras expectativas.

==== Direcciones frente a facturas, transacciones frente a pagos.

En un pago típico con Bitcoin, un usuario recibe una dirección Bitcoin (por ejemplo, escaneando un código QR en una página web, o recibiéndola en un mensaje instantáneo o un correo electrónico de un amigo). A continuación, utiliza su monedero Bitcoin para crear una transacción para enviar fondos a esta dirección.

En la Lightning Network, el receptor de un pago crea una invoice. Una invoice Lightning puede considerarse análoga a una dirección Bitcoin. El destinatario entrega la invoice Lightning al remitente como un código QR o una cadena de caracteres, al igual que una dirección de Bitcoin.

El remitente utiliza su billetera Lightning para pagar la invoice, copiando el texto de la invoice o escaneando el código QR de la misma. Un Lightning payment es análogo a una "transacción" de Bitcoin.

Sin embargo, hay algunas diferencias en la experiencia del usuario. Una dirección de Bitcoin es _reutilizable_. Las direcciones de Bitcoin nunca caducan, y si el propietario de la dirección todavía tiene las claves, los fondos que contiene son siempre accesibles. Un remitente puede enviar cualquier cantidad de bitcoin a una dirección previamente utilizada, y un destinatario puede publicar una única dirección estática para recibir muchos pagos. Aunque esto va en contra de las mejores prácticas por razones de privacidad, es técnicamente posible y, de hecho, bastante común. 

En Lightning, sin embargo, cada invoice sólo puede utilizarse una vez por un importe de pago específico. No se puede pagar más o menos, no se puede volver a utilizar una invoice, y la invoice tiene un tiempo de caducidad incorporado. En Lightning, un destinatario tiene que generar una nueva invoice para cada pago, especificando el importe del pago por adelantado. Hay una excepción a esto, un mecanismo llamado _keysend_, que examinaremos en <<keysend>>.

==== Selección de salidas frente a la búsqueda de un camino.

Para realizar un pago en la red Bitcoin, un emisor necesita consumir una o más salidas de transacción no gastadas (UTXOs).
Si un usuario tiene múltiples UTXOs, él (o más bien su billetera) necesitará seleccionar qué UTXO(s) enviar.
Por ejemplo, un usuario que realiza un pago de 1 BTC puede utilizar una única salida con valor de 1 BTC, dos salidas con valor de 0,25 BTC y 0,75 BTC, o cuatro salidas con valor de 0,25 BTC cada una.

En Lightning, los pagos no requieren el consumo de entradas. En su lugar, cada pago da lugar a una actualización del balance del canal, redistribuyéndolo entre los dos socios del canal. El remitente experimenta esto como un "movimiento" del balance del canal desde su extremo de un canal al otro extremo, a su socio del canal. Los pagos relámpago utilizan una serie de canales para dirigirse del remitente al destinatario. Cada uno de estos canales debe tener capacidad suficiente para enrutar el pago.

Dado que se pueden utilizar muchos canales y rutas posibles para realizar un pago, la elección de canales y rutas del usuario de Lightning es en cierto modo análoga a la elección de UTXO del usuario de Bitcoin.

Con tecnologías como los pagos multitrayectoria atómicos (AMP) y los pagos multiparte (MPP), que revisaremos en capítulos posteriores, se pueden agregar varias rutas de Lightning en un único pago atómico, al igual que se pueden agregar varios UTXO de Bitcoin en una única transacción atómica de Bitcoin.

==== Salidas de cambio en Bitcoin frente a sin cambio en Lightning.

Para realizar un pago en la red Bitcoin, el remitente necesita consumir una o más salidas de transacción no gastadas (UTXOs). Los UTXOs sólo pueden ser gastados en su totalidad; no pueden ser divididos y gastados parcialmente. Por lo tanto, si un usuario desea gastar 0,8 BTC, pero sólo tiene un UTXO de 1 BTC, tiene que gastar todo el UTXO de 1 BTC enviando 0,8 BTC al destinatario y 0,2 BTC de vuelta a sí mismo como cambio. El pago de cambio de 0,2 BTC crea un nuevo UTXO llamado "salida de cambio".

En Lightning, la funding transaction gasta algunos UTXO de Bitcoin, creando un UTXO multifirma para abrir el canal. Una vez que el bitcoin está bloqueado dentro de ese canal, se pueden enviar porciones de él de un lado a otro dentro del canal, sin necesidad de crear ningún cambio.
Esto se debe a que los socios del canal simplemente actualizan el balance del canal y sólo crean un nuevo UTXO cuando el canal es eventualmente cerrado usando la transacción de cierre del canal.

==== Tasas de minería frente a tasas de enrutamiento.

En la red Bitcoin, los usuarios pagan tasas a los mineros para que sus transacciones sean incluidas en un bloque.
Estas fees se pagan al minero que mina ese bloque en particular.
El importe de la tarifa se basa en el _tamaño_ de la transacción en _bytes_ que la transacción está utilizando en un bloque, así como la rapidez con la que el usuario quiere que esa transacción sea minada.
Dado que los mineros suelen minar primero las transacciones más rentables, un usuario que quiera que su transacción sea minada inmediatamente pagará una tarifa _más alta_ por byte, mientras que un usuario que no tenga prisa pagará una tarifa _más baja_ por byte.

En la Lightning Network, los usuarios pagan tasas a otros usuarios (nodos intermediarios) para que encaucen los pagos a través de sus canales.
Para enrutar un pago, un nodo intermediario tendrá que mover fondos en dos o más canales de su propiedad, así como transmitir los datos para el pago del remitente. Por lo general, el usuario de enrutamiento cobrará al remitente en función del _valor_ del pago, habiendo establecido una _tarifa_ mínima (una tarifa prorrateada proporcional al valor del pago). Por tanto, los pagos de mayor valor costarán más de enrutar, y se forma un mercado de liquidez, en el que los diferentes usuarios cobran diferentes fees por enrutar a través de sus canales.

==== Tarifas variables en función del tráfico frente a las fees anunciadas.

Peso del bloque.

Si hay más transacciones en la cola (llamada _mempool_) de las que pueden caber en un bloque, se empezarán a extraer las transacciones que paguen las tasas más altas por unidad (bytes) de _peso de transacción_.
Así, cuando hay muchas transacciones en la cola, los usuarios tienen que pagar una tasa más alta para ser incluidos en el siguiente bloque, o tienen que esperar hasta que haya menos transacciones en la cola.
Esto conduce naturalmente a la aparición de un mercado de fees en el que los usuarios pagan en función de la urgencia con la que necesitan que su transacción se incluya en el siguiente bloque. 

El recurso escaso en la red Bitcoin es el espacio en los bloques. Los usuarios de Bitcoin compiten por el espacio en los bloques, y el mercado de fees de Bitcoin se basa en el espacio disponible en los bloques. Los recursos escasos en la Lightning Network son la _liquidez de los canales_ (capacidad de los fondos disponibles para el enrutamiento en los canales) y la _conectividad de los canales_ (a cuántos nodos bien conectados pueden llegar los canales). Los usuarios de Lightning compiten por la capacidad y la conectividad; por tanto, el mercado de fees de Lightning se rige por la capacidad y la conectividad.

En la Lightning Network, los usuarios pagan tasas a los usuarios que enrutan sus pagos. Enrutar un pago, en términos económicos, no es más que proporcionar y asignar capacidad al remitente. Naturalmente, los enrutadores que cobran tasas más bajas por la misma capacidad serán más atractivos para enrutar. Por lo tanto, existe un mercado de fees en el que los enrutadores compiten entre sí por las fees que cobran por enrutar los pagos a través de sus canales.

==== Transacciones públicas de Bitcoin frente a pagos privados de Lightning.

En la red Bitcoin, cada transacción es visible públicamente en la blockchain de Bitcoin. Aunque las direcciones implicadas son seudónimas y no suelen estar vinculadas a una identidad, siguen siendo vistas y validadas por todos los demás usuarios de la red.
Además, las empresas de vigilancia de la blockchain recopilan y analizan estos datos en masa y los venden a partes interesadas como empresas privadas, gobiernos y agencias de inteligencia.

En cambio, los pagos de LN son casi completamente privados. Normalmente, sólo el remitente y el destinatario conocen el origen, el destino y el importe de un pago concreto. Además, es posible que el receptor ni siquiera conozca el origen del pago. Como los pagos se enrutan en forma de cebolla, los usuarios que enrutan el pago sólo conocen el importe del mismo, y no pueden determinar ni el origen ni el destino.

En resumen, las transacciones de Bitcoin se difunden públicamente y se almacenan para siempre. Los pagos de Lightning se ejecutan entre unos pocos pares seleccionados, y la información sobre ellos se almacena de forma privada sólo hasta que se cierra el canal. Crear herramientas de vigilancia y análisis masivo equivalentes a las utilizadas en Bitcoin será mucho más difícil en Lightning.

==== Esperar las confirmaciones frente a la liquidación instantánea.

En la red Bitcoin, las transacciones sólo se liquidan una vez que se han incluido en un bloque, en cuyo caso se dice que están "confirmadas" en ese bloque. A medida que se minan más bloques, la transacción adquiere más "confirmaciones" y se considera más segura.

En la Lightning Network, las confirmaciones sólo importan para abrir y cerrar canales en la cadena. Una vez que una funding transaction ha alcanzado un número adecuado de confirmaciones (por ejemplo, 3), los socios del canal lo consideran abierto. Como el bitcoin en el canal está asegurado por un contrato inteligente que gestiona ese canal, los pagos se liquidan _instantáneamente_ una vez recibidos por el destinatario final.
En términos prácticos, la liquidación instantánea significa que los pagos tardan sólo unos segundos en ejecutarse y liquidarse. Al igual que con Bitcoin, los pagos con Lightning no son reversibles.

Por último, cuando el canal se cierra, se realiza una transacción en la red Bitcoin; una vez confirmada esa transacción, el canal se considera cerrado.

==== Envío de cantidades arbitrarias frente a restricciones de capacidad.

En la red Bitcoin, un usuario puede enviar cualquier cantidad de bitcoin que posea a otro usuario, sin restricciones de capacidad. Una sola transacción puede teóricamente enviar hasta 21 millones de bitcoin como pago.

En la Lightning Network, un usuario sólo puede enviar la cantidad de bitcoin que exista actualmente en su lado de un canal concreto a un socio del canal. Por ejemplo, si un usuario posee un canal con 0,4 BTC en su lado, y otro canal con 0,2 BTC en su lado, entonces el máximo que puede enviar con un pago es 0,4 BTC. Esto es cierto independientemente de la cantidad de bitcoin que el usuario tenga actualmente en su billetera de Bitcoin.

Los pagos multiparte (MPP) son una función que, en el ejemplo anterior, permite al usuario combinar sus canales de 0,4 BTC y 0,2 BTC para enviar un máximo de 0,6 BTC con un solo pago. Los MPP se están probando actualmente en toda la Lightning Network y se espera que estén ampliamente disponibles y se utilicen cuando se termine este libro. Para más detalles sobre el MPP, véase <<mpp>>.

Si el pago se enruta, cada nodo de enrutamiento a lo largo de la ruta de enrutamiento debe tener canales con una capacidad al menos igual a la cantidad de pago que se enruta. Esto debe ser así para cada uno de los canales por los que se encamina el pago. La capacidad del canal de menor capacidad de una ruta establece el límite superior de la capacidad de toda la ruta.

Por tanto, la capacidad y la conectividad son recursos críticos y escasos en la Lightning Network. 

==== Incentivos para los pagos de gran valor frente a los de pequeño valor.

La estructura de fees en Bitcoin es independiente del valor de la transacción.
Una transacción de 1 millón de dólares tiene la misma tarifa que una transacción de 1 dólar en Bitcoin, asumiendo un tamaño de transacción similar, en bytes (más específicamente bytes "virtuales" después de SegWit [protocolo de Testigos Segregados]).
En Lightning la comisión es una comisión de base fija más un porcentaje del valor de la transacción.
Por lo tanto, en Lightning la comisión de pago aumenta con el valor del pago.
Estas estructuras de comisiones opuestas crean diferentes incentivos y conducen a un uso diferente en relación con el valor de la transacción.
Una transacción de mayor valor será más barata en Bitcoin; por lo tanto, los usuarios preferirán Bitcoin para transacciones de gran valor. Del mismo modo, en el otro extremo de la escala, los usuarios preferirán Lightning para las transacciones de pequeño valor.

==== Usando el Blockchain como un libro de contabilidad frente a un sistema judicial.

En la red Bitcoin, cada transacción se registra finalmente en un bloque de la blockchain.
El blockchain forma así una historia completa de cada transacción desde la creación de Bitcoin, y una forma de auditar completamente cada bitcoin existente.
Una vez que una transacción se incluye en la blockchain, es definitiva.
Por lo tanto, no pueden surgir disputas y no hay ninguna ambigüedad en cuanto a la cantidad de bitcoin que controla una dirección concreta en un punto determinado de la blockchain.

En la Lightning Network, el balance de un canal en un momento determinado sólo lo conocen los dos socios del canal, y sólo se hace visible para el resto de la red cuando se cierra el canal.
Cuando el canal se cierra, el balance final del canal se envía a la blockchain de Bitcoin, y cada socio recibe su parte del bitcoin en ese canal.
Por ejemplo, si el balance inicial era de 1 BTC pagado por Alice, y Alice hizo un pago de 0,3 BTC a Bob, entonces el balance final del canal es de 0,7 BTC para Alice y 0,3 BTC para Bob.
Si Alice intenta hacer trampa enviando el estado de apertura del canal a la blockchain de Bitcoin, con 1 BTC para Alice y 0 BTC para Bob, entonces Bob puede tomar represalias enviando el verdadero estado final del canal, así como creando una transacción de penalización que le da todos los bitcoin en el canal.
Para la Lightning Network, la blockchain de Bitcoin actúa como un sistema judicial.
Como un juez robótico, Bitcoin registra los saldos iniciales y finales de cada canal y aprueba las penalizaciones si una de las partes intenta hacer trampa.

==== Offline Versus Online, Asíncrono Versus Síncrono.

Cuando un usuario de Bitcoin envía fondos a una dirección de destino, no necesita saber nada sobre el destinatario. El destinatario puede estar fuera de línea o en línea, y no se necesita ninguna interacción entre el remitente y el destinatario. La interacción es entre el remitente y la blockchain de Bitcoin. Recibir bitcoin en la blockchain de Bitcoin es una actividad _pasiva_ y _asíncrona_ que no requiere ninguna interacción por parte del receptor ni que éste esté conectado en ningún momento. Las direcciones de Bitcoin pueden incluso generarse fuera de línea y nunca se "registran" en la red de Bitcoin. Sólo el gasto de bitcoin requiere interacción.

En Lightning, el receptor debe estar en línea para completar el pago antes de que expire.
El destinatario debe gestionar un nodo o tener a alguien que gestione un nodo en su nombre (un tercero custodio). Para ser precisos, ambos nodos, el del remitente y el del destinatario, deben estar en línea en el momento del pago y deben coordinarse. La recepción de un Lightning payment es una actividad _activa_ y _sincrónica_ entre el remitente y el destinatario, sin la participación de la mayor parte de la Lightning Network o de la red Bitcoin (excepto los nodos intermediarios de enrutamiento, si los hay).

La naturaleza sincrónica y siempre en línea de la Lightning Network es probablemente la mayor diferencia en la experiencia del usuario, y esto a menudo confunde a los usuarios que están acostumbrados a Bitcoin.

==== Satoshis Versus Millisatoshis.

En la red Bitcoin, la cantidad más pequeña es un _satoshi_, que no puede dividirse más. Lightning es un poco más flexible, y los nodos Lightning trabajan con _millisatoshis_ (milésimas de satoshi). Esto permite enviar pagos minúsculos a través de Lightning. Se puede enviar un solo pago en milisatoshis a través de un payment channel, una cantidad tan pequeña que debería caracterizarse adecuadamente como un _nanopago_.

La unidad de milisatoshi no puede, por supuesto, liquidarse en la blockchain de Bitcoin con esa granularidad. Cuando se cierra el canal, los saldos se redondean al satoshi más cercano. Pero a lo largo de la vida de un canal, son posibles millones de nanopagos a niveles de milisatoshi. La Lightning Network rompe la barrera de los micropagos.

=== Puntos en común de Bitcoin y Lightning.

Aunque la Lightning Network difiere de Bitcoin en varios aspectos, incluyendo la arquitectura y la experiencia del usuario, está construida a partir de Bitcoin y conserva muchas de las características principales de Bitcoin. 

==== Unidad monetaria.

Tanto la red Bitcoin como la Lightning Network utilizan la misma unidad monetaria: el bitcoin. Los pagos de Lightning utilizan el mismo bitcoin que las transacciones de Bitcoin. Como implicación, al ser la misma unidad monetaria, el límite monetario es el mismo: menos de 21 millones de bitcoin. De los 21 millones de bitcoin totales de Bitcoin, algunos ya están asignados a direcciones de 2 de 2 multifirmas como parte de los canales de pago en la Lightning Network.

==== Irreversibilidad y finalidad de los pagos.

Tanto las transacciones de Bitcoin como los pagos de Lightning son irreversibles e inmutables. No existe una operación de "deshacer" o "devolución de cargos" para ninguno de los dos sistemas. Como remitente de cualquiera de los dos, tienes que actuar con responsabilidad, pero también, como destinatario tienes garantizada la finalidad de tus transacciones.

==== Confianza y riesgo de contrapartida.

Al igual que con Bitcoin, Lightning sólo requiere que el usuario confíe en las matemáticas, en la encriptación y en que el software no tenga ningún fallo crítico. Ni Bitcoin ni Lightning requieren que el usuario confíe en una persona, una empresa, una institución o un gobierno.
Dado que Lightning se asienta sobre Bitcoin y se apoya en Bitcoin como su capa base subyacente, está claro que el modelo de seguridad de Lightning se reduce a la seguridad de Bitcoin. Esto significa que Lightning ofrece, en líneas generales, la misma seguridad que Bitcoin en la mayoría de las circunstancias, con sólo una ligera reducción de la seguridad en algunas circunstancias limitadas.

==== Funcionamiento sin permisos.

Tanto Bitcoin como Lightning pueden ser utilizados por cualquier persona con acceso a Internet y al software adecuado, por ejemplo, nodo y monedero.
Ninguna de las dos redes requiere que los usuarios obtengan permiso, investigación o autorización de terceros, empresas, instituciones o un gobierno. Los gobiernos pueden prohibir Bitcoin o Lightning dentro de su jurisdicción, pero no pueden impedir su uso global.

==== Código abierto y sistema abierto.
Tanto Bitcoin como Lightning son sistemas de software de código abierto construidos por una comunidad global descentralizada de voluntarios, disponibles bajo licencias abiertas. Ambos se basan en protocolos abiertos e interoperables que funcionan como sistemas y redes abiertas. Globales, abiertos y gratuitos.

=== Conclusión.

En este capítulo hemos visto cómo funciona realmente la Lightning Network y todos sus componentes. Hemos examinado cada paso en la construcción, operación y cierre de un canal. Hemos visto cómo se enrutan los pagos y, finalmente, hemos comparado Lightning con Bitcoin y hemos analizado sus diferencias y puntos en común.

En los próximos capítulos volveremos a tratar todos estos temas, pero con mucho más detalle. 


[[set_up_a_lightning_node]]
== Software del nodo Lightning.

Como hemos visto en capítulos anteriores, un nodo Lightning es un sistema informático que participa en la Lightning Network. La Red Relámpago no es un producto ni una empresa; es un conjunto de estándares abiertos que definen una línea de base para la interoperabilidad. Como tal, el software de los nodos Lightning ha sido creado por diversas empresas y grupos de la comunidad. La gran mayoría del software Lightning es de _código abierto_, lo que significa que el código fuente es abierto y tiene una licencia que permite la colaboración, el intercambio y la participación de la comunidad en el proceso de desarrollo. Del mismo modo, las implementaciones de nodos Lightning que presentaremos en este capítulo son todas de código abierto y se desarrollan en colaboración.

A diferencia de Bitcoin, donde el estándar está definido por una _implementación de referencia_ en software (Bitcoin Core), en Lightning el estándar está definido por una serie de documentos de estándares llamados _Basis of Lightning Technology_ (_BOLT_), que se encuentran en el repositorio https://github.com/lightningnetwork/lightning-rfc[_lightning-rfc_].

No existe una implementación de referencia de la Lightning Network, pero hay varias implementaciones competidoras, compatibles con BOLT e interoperables, desarrolladas por diferentes equipos y organizaciones. Los equipos que desarrollan software para la Lightning Network también contribuyen al desarrollo y la evolución de los estándares BOLT.

Otra diferencia importante entre el software de los nodos Lightning y el software de los nodos Bitcoin es que los nodos Lightning no necesitan operar al ritmo de las normas de consenso y pueden tener una funcionalidad ampliada más allá de la línea base de las BOLT. Por lo tanto, diferentes equipos pueden perseguir varias características experimentales que, si tienen éxito y se despliegan ampliamente, pueden convertirse en parte de los BOLTs más adelante.

[role="pagebreak-before"]
En este capítulo, aprenderá a configurar cada uno de los paquetes de software para las implementaciones de nodos Lightning más populares. Los hemos presentado en orden alfabético para destacar que, en general, no preferimos ni respaldamos uno sobre otro. Cada uno tiene sus puntos fuertes y débiles, y la elección de uno dependerá de diversos factores. Dado que se desarrollan en diferentes lenguajes de programación (por ejemplo, Go, C, etc.), su elección también puede depender de su nivel de familiaridad y experiencia con un lenguaje y un conjunto de herramientas de desarrollo específicos.

=== Entorno de desarrollo de rayos.

Si es un desarrollador, querrá configurar un entorno de desarrollo con todas las herramientas, bibliotecas y software de apoyo para escribir y ejecutar software de Lightning. En este capítulo altamente técnico, recorreremos ese proceso paso a paso. Si el material se vuelve demasiado denso o no estás configurando un entorno de desarrollo, entonces no dudes en pasar al siguiente capítulo, que es menos técnico.

==== Usando la línea de comandos.

Los ejemplos en este capítulo, y más ampliamente en la mayor parte de este libro, utilizan un terminal de línea de comandos. Esto significa que usted escribe comandos en una terminal y recibe respuestas de texto. Además, los ejemplos se demuestran en un sistema operativo basado en el núcleo de Linux y el sistema de software GNU, específicamente la última versión estable a largo plazo de Ubuntu (Ubuntu 20.04 LTS). La mayoría de los ejemplos pueden ser replicados en otros sistemas operativos como Windows o macOS, con pequeñas modificaciones en los comandos. La mayor diferencia entre los sistemas operativos es el _gestor de paquetes_ que instala las distintas librerías de software y sus requisitos previos. En los ejemplos dados, utilizaremos +apt+, que es el gestor de paquetes de Ubuntu. En macOS, un gestor de paquetes comúnmente utilizado para el desarrollo de código abierto es https://brew.sh[Homebrew], al que se accede mediante el comando +brew+.

En la mayoría de los ejemplos aquí, vamos a construir el software directamente desde el código fuente. Si bien esto puede ser bastante desafiante, nos da el mayor poder y control. Puedes optar por utilizar contenedores Docker, paquetes precompilados u otros mecanismos de instalación si te quedas atascado.

[TIP]
====
En muchos de los ejemplos de este capítulo utilizaremos la interfaz de línea de comandos del sistema operativo (también conocida como _shell_), a la que se accede a través de una aplicación _terminal_. El shell mostrará primero un prompt como indicador de que está listo para tu comando. A continuación, escriba un comando y pulse la tecla Enter, a lo que el shell responde con algún texto y un nuevo prompt para su siguiente comando. El prompt puede tener un aspecto diferente en su sistema, pero en los siguientes ejemplos se indica con un símbolo +$+. En los ejemplos, cuando veas un texto después de un símbolo +$+, no escribas el símbolo +$+ sino el comando que le sigue inmediatamente. A continuación, pulse la tecla Intro para ejecutar el comando. En los ejemplos, las líneas que siguen a cada comando son las respuestas del sistema operativo a ese comando. Cuando veas el siguiente prefijo +$+, sabrás que es un nuevo comando y deberás repetir el proceso.
==== 

Para mantener la coherencia, utilizamos el shell +bash+ en todos los ejemplos de línea de comandos. Aunque otros shells se comportarán de forma similar, y podrás ejecutar todos los ejemplos sin él, algunos de los scripts del shell están escritos específicamente para el shell +bash+ y pueden requerir algunos cambios o personalizaciones para ejecutarse en otro shell. Por coherencia, puedes instalar el shell +bash+ en Windows y macOS, y viene instalado por defecto en la mayoría de los sistemas Linux.

==== Descarga del repositorio del libro.

Todos los ejemplos de código están disponibles en el repositorio online del libro. Dado que el repositorio se mantendrá actualizado en la medida de lo posible, deberías buscar siempre la última versión en el repositorio online en lugar de copiarla del libro impreso o del ebook.

Puede descargar el repositorio como un paquete ZIP visitando https://github.com/lnbook/lnbook[GitHub] y seleccionando el botón verde de Código de la derecha.


También puede utilizar el comando +git+ para crear un clon del repositorio con control de versiones en su ordenador local. Git es un sistema de control de versiones distribuido que es utilizado por la mayoría de los desarrolladores para colaborar en el desarrollo de software y hacer un seguimiento de los cambios en los repositorios de software. Descargue e instale +git+ siguiendo las instrucciones https://git-scm.com[del Proyecto Git].


Para hacer una copia local del repositorio en tu ordenador, ejecuta el comando +git+ de la siguiente manera

[[git-clone-lnbook]]
----
$ git clone https://github.com/lnbook/lnbook.git
----

Ahora tienes una copia completa del repositorio de libros en una carpeta llamada +lnbook+. Querrás cambiar al directorio recién descargado ejecutando

[[cd-lnbook]]
----
$ cd lnbook
----

Todos los ejemplos posteriores asumirán que estás ejecutando comandos desde esta carpeta.

=== Contenedores Docker.

Muchos desarrolladores utilizan un _contenedor_, que es un tipo de máquina virtual, para instalar un sistema operativo preconfigurado y aplicaciones con todas las dependencias necesarias. Gran parte del software de Lightning también puede instalarse utilizando un sistema de contenedores como _Docker_ que se encuentra en https://docker.com[la página de inicio de Docker]. Las instalaciones en contenedores son mucho más fáciles, especialmente para aquellos que no están acostumbrados a un entorno de línea de comandos.

El repositorio del libro contiene una colección de contenedores Docker que pueden utilizarse para configurar un entorno de desarrollo consistente para practicar y replicar los ejemplos en cualquier sistema. Como el contenedor es un sistema operativo completo que se ejecuta con una configuración consistente, puedes estar seguro de que los ejemplos funcionarán en tu ordenador sin necesidad de preocuparte por las dependencias, las versiones de las bibliotecas o las diferencias de configuración.

Los contenedores Docker suelen estar optimizados para ser pequeños, es decir, que ocupen el mínimo espacio en disco. Sin embargo, en este libro estamos utilizando contenedores para _estandarizar_ el entorno y hacerlo consistente para todos los lectores. Además, estos contenedores no están pensados para ejecutar servicios en segundo plano. Por el contrario, están pensados para probar los ejemplos y aprender interactuando con el software. Por estas razones, los contenedores son bastante grandes y vienen con muchas herramientas y utilidades de desarrollo. Normalmente, se utiliza la distribución Alpine para los contenedores de Linux debido a su reducido tamaño. Sin embargo, proporcionamos contenedores construidos en Ubuntu porque más desarrolladores están familiarizados con Ubuntu, y esta familiaridad es más importante para nosotros que el tamaño.

La instalación y el uso de Docker y sus comandos se detallan en <<appendix_docker>>. Si no estás familiarizado con Docker, ahora es un buen momento para revisar rápidamente esa sección.

Puedes encontrar las últimas definiciones de contenedores y configuraciones de construcción en el repositorio del libro bajo la carpeta _code/docker_. Cada contenedor está en una carpeta separada, como se puede ver en lo siguiente:

[[tree]]
----
$ tree -F --charset=asciii code/docker
----

[[docker-dir-list]]
----
code/docker
|-- bitcoind/
|   |-- bashrc
|   |-- bitcoind/
|   |   |-- bitcoin.conf
|   |   `-- keys/
|   |       |-- demo_address.txt
|   |       |-- demo_mnemonic.txt
|   |       `-- demo_privkey.txt
|   |-- bitcoind-entrypoint.sh
|   |-- cli
|   |-- Dockerfile
|   `-- mine.sh*
|-- c-lightning/
|   |-- bashrc
|   |-- cli
|   |-- c-lightning-entrypoint.sh
|   |-- devkeys.pem
|   |-- Dockerfile
|   |-- fund-c-lightning.sh
|   |-- lightningd/
|   |   `-- config
|   |-- logtail.sh
|   `-- wait-for-bitcoind.sh
|-- eclair/
|   |-- bashrc
|   |-- cli
|   |-- Dockerfile
|   |-- eclair/
|   |   `-- eclair.conf
|   |-- eclair-entrypoint.sh
|   |-- logtail.sh
|   `-- wait-for-bitcoind.sh
|-- lnd/
|   |-- bashrc
|   |-- cli
|   |-- Dockerfile
|   |-- fund-lnd.sh
|   |-- lnd/
|   |   `-- lnd.conf
|   |-- lnd-entrypoint.sh
|   |-- logtail.sh
|   `-- wait-for-bitcoind.sh
|-- check-versions.sh
|-- docker-compose.yml
|-- Makefile
`-- run-payment-demo.sh*
----

Como veremos en las próximas secciones, puedes construir estos contenedores localmente, o puedes sacarlos del repositorio del libro en https://hub.docker.com/orgs/lnbook[_Docker Hub_]. Las siguientes secciones asumirán que has instalado Docker y estás familiarizado con el uso básico del comando +docker+.

=== Bitcoin Core y Regtest.

La mayoría de las implementaciones del nodo Lightning necesitan acceso a un nodo Bitcoin completo para funcionar.

La instalación de un nodo Bitcoin completo y la sincronización del blockchain de Bitcoin está fuera del alcance de este libro y es un esfuerzo relativamente complejo en sí mismo. Si quiere intentarlo, consulte https://github.com/bitcoinbook/bitcoinbook[_Mastering Bitcoin_], "Capítulo 3: Bitcoin Core: La Implementación de Referencia", que discute la instalación y operación de un nodo Bitcoin.

Un nodo Bitcoin puede funcionar en modo `regtest`, donde el nodo crea una blockchain local simulada de Bitcoin para propósitos de prueba. En los siguientes ejemplos, utilizaremos el modo +regtest+ para permitirnos demostrar Lightning sin tener que sincronizar un nodo Bitcoin ni arriesgar ningún fondo. 

El contenedor para Bitcoin Core es +bitcoind+. Está configurado para ejecutar Bitcoin Core en modo +regtest+ y para minar 6 nuevos bloques cada 10 segundos. Su puerto de llamada a procedimiento remoto (RPC) está expuesto en el puerto 18443 y es accesible para llamadas RPC con el nombre de usuario +regtest+ y la contraseña +regtest+. También se puede acceder con un shell interactivo y ejecutar comandos +bitcoin-cli+ localmente.

==== Construyendo el contenedor de Bitcoin Core.

Vamos a preparar el contenedor +bitcoind+. La forma más fácil es sacar el último contenedor de _Docker Hub_:

[source,bash]
----
$ docker pull lnbook/bitcoind
Using default tag: latest
latest: Pulling from lnbook/bitcoind
35807b77a593: Pull complete
e1b85b9c5571: Pull complete
[...]
288f1cc78a00: Pull complete
Digest: sha256:861e7e32c9ad650aa367af40fc5acff894e89e47aff4bd400691ae18f1b550e2
Status: Downloaded newer image for lnbook/bitcoind:latest
docker.io/lnbook/bitcoind:latest

----

Alternativamente, puedes construir el contenedor tú mismo desde la definición del contenedor local que está en _code/docker/bitcoind/Dockerfile_.

[NOTE]
====
No necesitas construir el contenedor si has usado el comando +pull+ previamente para sacarlo de Docker Hub.
====

Construir el contenedor localmente utilizará un poco menos de su ancho de banda de red, pero tomará más de su tiempo de CPU para construir. Usamos el comando +docker build+ para construirlo:

[source,bash]
----
$ cd code/docker
$ docker run -it --name bitcoind lnbook/bitcoind
Starting bitcoind...
Bitcoin Core starting
Waiting for bitcoind to start
bitcoind started
================================================
Imported demo private key
Bitcoin address:  2NBKgwSWY5qEmfN2Br4WtMDGuamjpuUc5q1
Private key:  cSaejkcWwU25jMweWEewRSsrVQq2FGTij1xjXv4x1XvxVRF1ZCr3
================================================
================================================
Balance: 0.00000000
================================================
Mining 101 blocks to unlock some bitcoin
[
  "34c744207fd4dd32b70bac467902bd8d030fba765c9f240a2e98f15f05338964",
  "64d82721c641c378d79b4ff2e17572c109750bea1d4eddbae0b54f51e4cdf23e",

 [...]

  "7a8c53dc9a3408c9ecf9605b253e5f8086d67bbc03ea05819b2c9584196c9294",
  "39e61e50e34a9bd1d6eab51940c39dc1ab56c30b21fc28e1a10c14a39b67a1c3",
  "4ca7fe9a55b0b767d2b7f5cf4d51a2346f035fe8c486719c60a46dcbe33de51a"
]
Mining 6 blocks every 10 seconds
Balance: 50.00000000
[
  "5ce76cc475e40515b67e3c0237d1eef597047a914ba3f59bbd62fc3691849055",
  "1ecb27a05ecfa9dfa82a7b26631e0819b2768fe5e6e56c7a2e1078b078e21e9f",
  "717ceb8b6c329d57947c950dc5668fae65bddb7fa03203984da9d2069e20525b",
  "185fc7cf3557a6ebfc4a8cdd1f94a8fa08ed0c057040cdd68bfb7aee2d5be624",
  "59001ae237a3834ebe4f6e6047dcec8fd67df0352ddc70b6b02190f982a60384",
  "754c860fe1b9e0e7292e1de96a65eaa78047feb4c72dbbde2a1d224faa1499dd"
]

----

Como puedes ver, +bitcoind+ arranca y mina 101 bloques simulados para iniciar la cadena. Esto se debe a que bajo las reglas de consenso de Bitcoin, el bitcoin recién minado no es gastable hasta que hayan transcurrido 100 bloques. Al minar 101 bloques, hacemos que la base de monedas del primer bloque sea gastable. Después de esa actividad minera inicial, se minan 6 nuevos bloques cada 10 segundos para que la cadena siga avanzando.

Por ahora, no hay transacciones. Pero tenemos algún bitcoin de prueba que ha sido minado en la billetera y está disponible para gastar. Cuando conectemos algunos nodos Lightning a esta cadena, enviaremos algunos bitcoin a sus billeteras para poder abrir algunos canales Lightning entre los nodos Lightning.

===== Interactuando con el contenedor del núcleo de bitcoin.

Mientras tanto, también podemos interactuar con el contenedor +bitcoind+ enviándole comandos de shell. El contenedor envía un archivo de registro a la terminal, mostrando el proceso de minería del proceso +bitcoind+. Para interactuar con la shell podemos emitir comandos en otra terminal, utilizando el comando +docker exec+. Como previamente hemos nombrado al contenedor en ejecución con el argumento +nombre+, podemos referirnos a él con ese nombre cuando ejecutemos el comando +docker exec+. Primero, vamos a ejecutar un shell interactivo +bash+:

----
$ docker exec -it bitcoind /bin/bash
root@e027fd56e31a:/bitcoind# ps x
  PID TTY      STAT   TIME COMMAND
    1 pts/0    Ss+    0:00 /bin/bash /usr/local/bin/mine.sh
    7 ?        Ssl    0:03 bitcoind -datadir=/bitcoind -daemon
   97 pts/1    Ss     0:00 /bin/bash
  124 pts/0    S+     0:00 sleep 10
  125 pts/1    R+     0:00 ps x
root@e027fd56e31a:/bitcoind#
----

La ejecución de la shell interactiva nos sitúa "dentro" del contenedor. Se inicia la sesión como usuario +root+, como podemos ver por el prefijo +root@+ en el nuevo prompt del shell +root@e027fd56e31a:/bitcoind#+. Si ejecutamos el comando +ps x+ para ver qué procesos se están ejecutando, vemos que tanto +bitcoind+ como el script +mine.sh+ se están ejecutando en segundo plano. Para salir de este intérprete de comandos, presione Ctrl-D o escriba *+exit+*, y regresará al símbolo del sistema operativo.

En lugar de ejecutar un shell interactivo, también podemos emitir un único comando que se ejecute dentro del contenedor. Por comodidad, el comando +bitcoin-cli+ tiene un alias "cli" que pasa la configuración correcta. Así que vamos a ejecutarlo para preguntar a Bitcoin Code sobre el blockchain. Ejecutamos +cli getblockchaininfo+:

[source,bash]
----
$ docker exec bitcoind cli getblockchaininfo
{
  "chain": "regtest",
  "blocks": 131,
  "headers": 131,
  "bestblockhash": "2cf57aac35365f52fa5c2e626491df634113b2f1e5197c478d57378e5a146110",

[...]

  "warnings": ""
}

----


El comando +cli+ en el contenedor +bitcoind+ nos permite emitir comandos RPC al nodo Bitcoin Core y obtener resultados codificados en JavaScript Object Notation (JSON).

Además, todos nuestros contenedores Docker tienen un codificador/decodificador JSON de línea de comandos llamado +jq+ preinstalado. +jq+ nos ayuda a procesar datos con formato JSON a través de la línea de comandos o desde dentro de los scripts. Puedes enviar la salida JSON de cualquier comando a +jq+ utilizando el carácter +|+. Este carácter, así como esta operación, se llama "pipe". Apliquemos un +pipe+ y +jq+ al comando anterior de la siguiente manera:

[source,bash]
----
$ docker exec bitcoind bash -c "cli getblockchaininfo | jq .blocks"
197
----

+jq .blocks+ indica al decodificador JSON de +jq+ que extraiga el campo +blocks+ del resultado de [.keep-together]#+getblockchaininfo+#. En nuestro caso, extrae e imprime el valor de 197 que podríamos utilizar en un comando posterior.

Como verás en las siguientes secciones, podemos ejecutar varios contenedores al mismo tiempo y luego interactuar con ellos individualmente. Podemos emitir comandos para extraer información como la clave pública del nodo Lightning o para realizar acciones como abrir un canal Lightning a otro nodo. Los comandos +docker run+ y +docker exec+, junto con +jq+ para la decodificación de JSON, son todo lo que necesitamos para construir una Lightning Network que funcione y que mezcle muchas implementaciones de nodos diferentes. Esto nos permite probar diversos experimentos en nuestro propio ordenador 

=== El proyecto c-lightning Lightning Node.

`c-lightning` es una implementación ligera, altamente personalizable y compatible con los estándares del protocolo LN, desarrollada por Blockstream como parte del Proyecto Elements. El proyecto es de código abierto y se desarrolla de forma colaborativa en https://github.com/ElementsProject/lightning[GitHub].

En las siguientes secciones, construiremos un contenedor Docker que ejecuta un nodo `c-lightning` que se conecta al contenedor +bitcoind+ que construimos anteriormente. También mostraremos cómo configurar y construir el software `c-lightning` directamente desde el código fuente.

==== Construyendo c-lightning como un contenedor Docker.

La distribución del software `c-lightning` tiene un contenedor Docker, pero está diseñado para ejecutar `c-lightning` en sistemas de producción y junto a un nodo +bitcoind+. Utilizaremos un contenedor algo más simple configurado para ejecutar `c-lightning` con fines de demostración.

Vamos a sacar el contenedor `c-lightning` del repositorio Docker Hub del libro:

[source,bash]
----
$ docker pull lnbook/c-lightning
Using default tag: latest
latest: Pulling from lnbook/c-lightning

[...]

Digest: sha256:bdefcefe8a9712e7b3a236dcc5ab12d999c46fd280e209712e7cb649b8bf0688
Status: Downloaded image for lnbook/c-lightning:latest
docker.io/lnbook/c-lightning:latest

----

Alternativamente, podemos construir el contenedor Docker `c-lightning` desde los archivos del libro que descargaste previamente en un directorio llamado +lnbook+. Como antes, utilizaremos el comando +docker build+ en el subdirectorio +code/docker+. Etiquetaremos la imagen del contenedor con la etiqueta +lnbook/c-lightning+, así:

[source,bash]
----
$ cd code/docker
$ docker build -t lnbook/c-lightning c-lightning
Sending build context to Docker daemon  91.14kB
Step 1/34 : ARG OS=ubuntu
Step 2/34 : ARG OS_VER=focal
Step 3/34 : FROM ${OS}:${OS_VER} as os-base
 ---> fb52e22af1b0

 [...]

Step 34/34 : CMD ["/usr/local/bin/logtail.sh"]
 ---> Running in 8d3d6c8799c5
Removing intermediate container 8d3d6c8799c5
 ---> 30b6fd5d7503
Successfully built 30b6fd5d7503
Successfully tagged lnbook/c-lightning:latest

----

Nuestro contenedor ya está construido y listo para ser ejecutado. Sin embargo, antes de ejecutar el contenedor `c-lightning`, tenemos que iniciar el contenedor +bitcoind+ en otra terminal porque `c-lightning` depende de +bitcoind+. También necesitaremos configurar una red Docker que permita que los contenedores se conecten entre sí como si residieran en la misma red de área local.

[TIP]
====
Los contenedores Docker pueden "hablar" entre sí a través de una red de área local virtual gestionada por el sistema Docker. Cada contenedor puede tener un nombre personalizado, y otros contenedores pueden usar ese nombre para resolver su dirección IP y conectarse fácilmente a él.
====

==== Configuración de una red Docker.

Una vez configurada una red Docker, Docker activará la red en nuestro ordenador local cada vez que Docker se inicie, por ejemplo, después de reiniciar. Así que sólo tenemos que configurar una red una vez utilizando el comando +docker network create+. El nombre de la red en sí no es importante, pero tiene que ser único en nuestro ordenador. Por defecto, Docker tiene tres redes llamadas +host+, +bridge+ y +none+. Nosotros llamaremos a nuestra nueva red +lnbook+ y la crearemos así:

[source,bash]
----
$ docker network create lnbook
ad75c0e4f87e5917823187febedfc0d7978235ae3e88eca63abe7e0b5ee81bfb
$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
7f1fb63877ea        bridge              bridge              local
4e575cba0036        host                host                local
ad75c0e4f87e        lnbook              bridge              local
ee8824567c95        none                null                local
----

Como puedes ver, ejecutando +docker network ls+ nos da un listado de las redes Docker. Nuestra red +lnbook+ ha sido creada. Podemos ignorar el ID de la red, porque se gestiona automáticamente.

==== Ejecutando los contenedores bitcoind y c-lightning.

El siguiente paso es iniciar los contenedores +bitcoind+ y `c-lightning` y conectarlos a la red +lnbook+. Para ejecutar un contenedor en una red específica, debemos pasar el argumento [.keep-together]#+network+# a +docker run+. Para facilitar que los contenedores se encuentren entre sí, también daremos un nombre a cada uno con el argumento +nombre+. Iniciamos +bitcoind+ así:

[source,bash]
----
$ docker run -it --network lnbook --name bitcoind lnbook/bitcoind
----

Deberías ver que +bitcoind+ se inicia y empieza a minar bloques cada 10 segundos. Déjalo funcionando y abre una nueva ventana de terminal para iniciar `c-lightning`. Usamos un comando similar de +docker run+ con los argumentos +red+ y +nombre+ para iniciar `c-lightning` como sigue:

[source,bash]
----
$ docker run -it --network lnbook --name c-lightning lnbook/c-lightning
Waiting for bitcoind to start...
Waiting for bitcoind to mine blocks...
Starting c-lightning...
2021-09-12T13:14:50.434Z UNUSUAL lightningd: Creating configuration directory /lightningd/regtest
Startup complete
Funding c-lightning wallet
8a37a183274c52d5a962852ba9f970229ea6246a096ff1e4602b57f7d4202b31
lightningd: Opened log file /lightningd/lightningd.log
lightningd: Creating configuration directory /lightningd/regtest
lightningd: Opened log file /lightningd/lightningd.log

----

El contenedor `c-lightning` se inicia y se conecta al contenedor +bitcoind+ a través de la red Docker. En primer lugar, nuestro nodo `c-lightning` esperará a que +bitcoind+ se inicie, y luego esperará hasta que +bitcoind+ haya minado algunos bitcoins en su billetera. Finalmente, como parte del inicio del contenedor, un script enviará un comando RPC al nodo +bitcoind+, que crea una transacción que financia el monedero de `c-lightning` con 10 BTC de prueba. Ahora nuestro nodo `c-lightning` no sólo se está ejecutando, sino que incluso tiene algunos bitcoin de prueba para jugar.

Como demostramos con el contenedor +bitcoind+, podemos emitir comandos a nuestro contenedor `c-lightning` en otra terminal para extraer información, abrir canales, etc. El comando que nos permite emitir instrucciones de línea de comandos al nodo `c-lightning` se llama +lightning-cli+. Este comando +lightning-cli+ también tiene el alias +cli+ dentro de este contenedor. Para obtener la información del nodo `c-lightning`, utilice el siguiente comando +docker exec+ en otra ventana de terminal:

[source,bash]
----
$ docker exec c-lightning cli getinfo
{
   "id": "026ec53cc8940df5fed5fa18f8897719428a15d860ff4cd171fca9530879c7499e",
   "alias": "IRATEARTIST",
   "color": "026ec5",
   "num_peers": 0,
   "num_pending_channels": 0,

[...]

   "version": "0.10.1",
   "blockheight": 221,
   "network": "regtest",
   "msatoshi_fees_collected": 0,
   "fees_collected_msat": "0msat",
   "lightning-dir": "/lightningd/regtest"
}

----

Ahora tenemos nuestro primer nodo Lightning funcionando en una red virtual y comunicándose con una blockchain de Bitcoin de prueba. Más adelante en este capítulo pondremos en marcha más nodos y los conectaremos entre sí para realizar algunos pagos con Lightning.

En la siguiente sección también veremos cómo descargar, configurar y compilar `c-lightning` directamente desde el código fuente. Este es un paso opcional y avanzado que te enseñará a utilizar las herramientas de compilación y te permitirá hacer modificaciones en el código fuente de [.keep-together]#`c-lightning`#. Con este conocimiento puedes escribir algo de código, arreglar algunos errores, o crear un plug-in para `c-lightning`.

[NOTE]
====
Si no estás planeando sumergirte en el código fuente o en la programación de un nodo Lightning, puedes saltarte la siguiente sección por completo. El contenedor Docker que acabamos de construir es suficiente para la mayoría de los ejemplos del libro.
====

==== Instalación de c-lightning desde el código fuente.

Los desarrolladores de `c-lightning` han proporcionado instrucciones detalladas para construir `c-lightning` desde el código fuente. Vamos a seguir las instrucciones https://github.com/ElementsProject/lightning/blob/master/doc/INSTALL.md[de GitHub].

==== Instalación de las bibliotecas y paquetes necesarios.

Estas instrucciones de instalación asumen que está construyendo `c-lightning` en un sistema Linux o similar con herramientas de construcción GNU. Si no es el caso, busque las instrucciones para su sistema operativo en el repositorio del Proyecto Elements.

El primer paso común es la instalación de las bibliotecas de prerrequisitos. Utilizamos el gestor de paquetes +apt+ para instalarlas:

[source,bash]
----
$ sudo apt-get update

Get:1 http://security.ubuntu.com/ubuntu bionic-security InRelease [88.7 kB]
Hit:2 http://eu-north-1b.clouds.archive.ubuntu.com/ubuntu bionic InRelease
Get:3 http://eu-north-1b.clouds.archive.ubuntu.com/ubuntu bionic-updates InRelease [88.7 kB]

[...]

Fetched 18.3 MB in 8s (2,180 kB/s)
Reading package lists... Done

$ sudo apt-get install -y \
  autoconf automake build-essential git libtool libgmp-dev \
  libsqlite3-dev python python3 python3-mako net-tools zlib1g-dev \
  libsodium-dev gettext

Reading package lists... Done
Building dependency tree
Reading state information... Done
The following additional packages will be installed:
  autotools-dev binutils binutils-common binutils-x86-64-linux-gnu cpp cpp-7 dpkg-dev fakeroot g++ g++-7 gcc gcc-7 gcc-7-base libalgorithm-diff-perl

 [...]

Setting up libsigsegv2:amd64 (2.12-2) ...
Setting up libltdl-dev:amd64 (2.4.6-14) ...
Setting up python2 (2.7.17-2ubuntu4) ...
Setting up libsodium-dev:amd64 (1.0.18-1) ...

[...]
$
----

Tras unos minutos y mucha actividad en pantalla, habrás instalado todos los paquetes y bibliotecas necesarios. Muchas de estas bibliotecas también son utilizadas por otros paquetes de Lightning y son necesarias para el desarrollo de software en general.

==== Copiar el código fuente de c-lightning.

A continuación, copiaremos la última versión de `c-lightning` del repositorio de código fuente. Para ello, utilizaremos el comando +git clone+, que clona una copia controlada de la versión en tu máquina local, permitiéndote así mantenerla sincronizada con los cambios posteriores sin tener que descargar todo el repositorio de nuevo:

[source,bash]
----
$ git clone --recurse https://github.com/ElementsProject/lightning.git
Cloning into 'lightning'...
remote: Enumerating objects: 24, done.
remote: Counting objects: 100% (24/24), done.
remote: Compressing objects: 100% (22/22), done.
remote: Total 53192 (delta 5), reused 5 (delta 2), pack-reused 53168
Receiving objects: 100% (53192/53192), 29.59 MiB | 19.30 MiB/s, done.
Resolving deltas: 100% (39834/39834), done.

$ cd lightning

----

Ahora tenemos una copia de `c-lightning` clonada en la subcarpeta _lightning_, y hemos utilizado el comando +cd+ (cambiar directorio) para entrar en esa subcarpeta.

==== Compilación del código fuente de c-lightning.

A continuación, utilizamos un conjunto de _build scripts_ que suelen estar disponibles en muchos proyectos de código abierto. Estos scripts de compilación utilizan los comandos +configure+ y +make+, que nos permiten:

* Seleccionar las opciones de compilación y comprobar las dependencias necesarias (+configure+)
* Construir e instalar los ejecutables y librerías (+make+)

Ejecutando +configure+ con la opción +help+ nos mostrará todas las opciones disponibles:

----
$ ./configure --help
Usage: ./configure [--reconfigure] [setting=value] [options]

Options include:
  --prefix= (default /usr/local)
    Prefix for make install
  --enable/disable-developer (default disable)
    Developer mode, good for testing
  --enable/disable-experimental-features (default disable)
    Enable experimental features
  --enable/disable-compat (default enable)
    Compatibility mode, good to disable to see if your software breaks
  --enable/disable-valgrind (default (autodetect))
    Run tests with Valgrind
  --enable/disable-static (default disable)
    Static link sqlite3, gmp and zlib libraries
  --enable/disable-address-sanitizer (default disable)
    Compile with address-sanitizer
----


No necesitamos cambiar ninguna de las opciones por defecto para este ejemplo. Por lo tanto, ejecutamos [.keep-together]#+configure+# de nuevo sin ninguna opción para utilizar los valores por defecto:

----
$ ./configure

Compiling ccan/tools/configurator/configurator...done
checking for python3-mako... found
Making autoconf users comfortable... yes
checking for off_t is 32 bits... no
checking for __alignof__ support... yes

[...]

Setting COMPAT... 1
PYTEST not found
Setting STATIC... 0
Setting ASAN... 0
Setting TEST_NETWORK... regtest
$
----

A continuación, utilizamos el comando +make+ para construir las bibliotecas, componentes y ejecutables del proyecto `c-lightning`. Esta parte tardará varios minutos en completarse y utilizará mucho la CPU y el disco de tu ordenador. ¡Espere algo de ruido de los ventiladores! Ejecuta +make+:

[source,bash]
----
$ make

cc -DBINTOPKGLIBEXECDIR="\"../libexec/c-lightning\"" -Wall -Wundef -Wmis...

[...]

cc   -Og  ccan-asort.o ccan-autodata.o ccan-bitmap.o ccan-bitops.o ccan-...

----

Si todo va bien, no verás ningún mensaje de +ERROR+ que detenga la ejecución del comando anterior. El paquete de software `c-lightning` ha sido compilado desde el código fuente, y ahora estamos listos para instalar los componentes ejecutables que creamos en el paso anterior:

----
$ sudo make install

mkdir -p /usr/local/bin
mkdir -p /usr/local/libexec/c-lightning
mkdir -p /usr/local/libexec/c-lightning/plugins
mkdir -p /usr/local/share/man/man1
mkdir -p /usr/local/share/man/man5
mkdir -p /usr/local/share/man/man7
mkdir -p /usr/local/share/man/man8
mkdir -p /usr/local/share/doc/c-lightning
install cli/lightning-cli lightningd/lightningd /usr/local/bin
[...]
----

Para verificar que los comandos +lightningd+ y +lightning-cli+ se han instalado correctamente, pediremos a cada ejecutable su información de versión:

[source,bash]
----
$ lightningd --version
v0.10.1-34-gfe86c11
$ lightning-cli --version
v0.10.1-34-gfe86c11
----

La versión consiste en la última versión de lanzamiento (v0.10.1), seguida del número de cambios desde el lanzamiento (34), y finalmente un hash que identifica exactamente la revisión (fe86c11). Es posible que vea una versión diferente a la mostrada anteriormente, ya que el software sigue evolucionando mucho después de la publicación de este libro. Sin embargo, independientemente de la versión que vea, el hecho de que los comandos se ejecuten y respondan con la información de la versión significa que ha logrado construir el software `c-lightning`.

=== El proyecto del nodo Lightning Network Daemon.

El Lightning Network Daemon (LND) es una implementación completa de un nodo LN de Lightning Labs. El proyecto LND proporciona una serie de aplicaciones ejecutables, incluyendo +lnd+ (el demonio en sí) y +lncli+ (la utilidad de línea de comandos). LND cuenta con varios servicios de cadena backend enchufables, incluyendo btcd (un nodo completo), +bitcoind+ (Bitcoin Core) y Neutrino (un nuevo cliente ligero experimental). LND está escrito en el lenguaje de programación Go. El proyecto es de código abierto y se desarrolla de forma colaborativa en https://github.com/LightningNetwork/lnd[GitHub].

En las próximas secciones construiremos un contenedor Docker para ejecutar LND, construiremos LND desde el código fuente y aprenderemos a configurar y ejecutar LND. 

==== El contenedor Docker LND.

Podemos sacar el contenedor Docker de ejemplo de LND del repositorio Docker Hub del libro:

[source,bash]
----
$ docker pull lnbook/lnd
Using default tag: latest
latest: Pulling from lnbook/lnd
35807b77a593: Already exists
e1b85b9c5571: Already exists
52f9c252546e: Pull complete

[...]

Digest: sha256:e490a0de5d41b781c0a7f9f548c99e67f9d728f72e50cd4632722b3ed3d85952
Status: Downloaded newer image for lnbook/lnd:latest
docker.io/lnbook/lnd:latest

----

Alternativamente, podemos construir el contenedor LND localmente. El contenedor se encuentra en _code/docker/lnd_. Cambiamos el directorio de trabajo a _code/docker_ y ejecutamos el comando +docker build+:

[source,bash]
----
$ cd code/docker
$ docker build -t lnbook/lnd lnd
Sending build context to Docker daemon  9.728kB
Step 1/29 : FROM golang:1.13 as lnd-base
 ---> e9bdcb0f0af9
Step 2/29 : ENV GOPATH /go

[...]

Step 29/29 : CMD ["/usr/local/bin/logtail.sh"]
 ---> Using cache
 ---> 397ce833ce14
Successfully built 397ce833ce14
Successfully tagged lnbook/lnd:latest

----

Nuestro contenedor ya está listo para funcionar. Al igual que el contenedor `c-lightning` que construimos anteriormente, el contenedor LND también depende de una instancia de Bitcoin Core en ejecución. Como antes, necesitamos iniciar el contenedor +bitcoind+ en otro terminal y conectar LND a él a través de una red Docker. Ya hemos configurado una red Docker llamada +lnbook+ y la usaremos de nuevo aquí.

[TIP]
====
Normalmente, cada operador de nodo ejecuta su propio nodo Lightning y su propio nodo Bitcoin en su propio servidor. Para nosotros, un solo contenedor +bitcoind+ puede servir a muchos nodos Lightning. En nuestra red simulada podemos ejecutar varios nodos Lightning, todos conectados a un único nodo Bitcoin en modo +regtest+.
====

==== Ejecutando los contenedores bitcoind y LND.

Como antes, iniciamos el contenedor +bitcoind+ en un terminal y LND en otro. Si ya tienes el contenedor +bitcoind+ en marcha, no necesitas reiniciarlo. Simplemente déjalo funcionando y sáltate el siguiente paso. Para iniciar +bitcoind+ en la red de +lnbook+, usamos +docker run+ así:

[source,bash]
----
$ docker run -it --network lnbook --name bitcoind lnbook/bitcoind
----

A continuación, iniciamos el contenedor LND que acabamos de construir. Como hemos hecho antes, tenemos que adjuntarlo a la red +lnbook+ y darle un nombre:

[source,bash]
----
$ docker run -it --network lnbook --name lnd lnbook/lnd
Waiting for bitcoind to start...
Waiting for bitcoind to mine blocks...
Starting lnd...
Startup complete
Funding lnd wallet
{"result":"dbd1c8e2b224e0a511c11efb985dabd84d72d935957ac30935ec4211d28beacb","error":null,"id":"lnd-run-container"}
[INF] LTND: Version: 0.13.1-beta commit=v0.13.1-beta, build=production, logging=default, debuglevel=info
[INF] LTND: Active chain: Bitcoin (network=regtest)
[INF] RPCS: Generating TLS certificates...

----

El contenedor LND se inicia y se conecta al contenedor +bitcoind+ a través de la red Docker. En primer lugar, nuestro nodo LND esperará a que +bitcoind+ se inicie, y luego esperará hasta que +bitcoind+ haya minado algunos bitcoins en su billetera. Finalmente, como parte del arranque del contenedor, un script enviará un comando RPC al nodo +bitcoind+, creando así una transacción que financia el monedero de LND con 10 BTC de prueba.

Como hemos demostrado anteriormente, podemos emitir comandos a nuestro contenedor en otro terminal para extraer información, abrir canales, etc. El comando que nos permite emitir instrucciones de línea de comandos al demonio +lnd+ se llama +lncli+. Una vez más, en este contenedor hemos proporcionado el alias +cli+ que ejecuta +lncli+ con todos los parámetros adecuados. Obtengamos la información del nodo utilizando el comando +docker exec+ en otra ventana de terminal:

[source,bash]
----
$ docker exec lnd cli getinfo
{
    "version": "0.13.1-beta commit=v0.13.1-beta",
    "commit_hash": "596fd90ef310cd7abbf2251edaae9ba4d5f8a689",
    "identity_pubkey": "02d4545dccbeda29a10f44e891858940f4f3374b75c0f85dcb7775bb922fdeaa14",

[...]

}
----

Ahora tenemos otro nodo Lightning ejecutándose en la red +lnbook+ y comunicándose con +bitcoind+. Si todavía está ejecutando el contenedor `c-lightning`, entonces ahora hay dos nodos en ejecución. Todavía no están conectados entre sí, pero los conectaremos pronto.

Si lo desea, puede ejecutar cualquier combinación de nodos LND y `c-lightning` en la misma Lightning Network. Por ejemplo, para ejecutar un segundo nodo de LND, deberá ejecutar el comando +docker run+ con un nombre de contenedor diferente, de la siguiente manera

[source,bash]
----
$ docker run -it --network lnbook --name lnd2 lnbook/lnd
----

En el comando anterior, iniciamos otro contenedor LND, nombrándolo +lnd2+. Los nombres dependen de usted, siempre que sean únicos. Si no proporcionas un nombre, Docker construirá un nombre único combinando al azar dos palabras en inglés como "naughty_einstein". Este fue el nombre que Docker eligió para nosotros cuando escribimos este párrafo. ¡Qué curioso!

En la siguiente sección veremos cómo descargar y compilar LND directamente desde el código fuente. Este es un paso opcional y avanzado que te enseñará a utilizar las herramientas de compilación del lenguaje Go y te permitirá hacer modificaciones en el código fuente de LND. Con estos conocimientos podrás escribir algo de código o arreglar algunos errores.

[NOTE]
====
Si no tienes pensado sumergirte en el código fuente o en la programación de un nodo Lightning, puedes saltarte la siguiente sección por completo. El contenedor Docker que acabamos de construir es suficiente para la mayoría de los ejemplos del libro.
==== 

==== Instalación de LND desde el código fuente.

En esta sección construiremos LND desde cero. LND está escrito en el lenguaje de programación Go. Si quiere saber más sobre Go, busque +golang+ en lugar de +go+ para evitar resultados irrelevantes. Al estar escrito en Go y no en C o C++, utiliza un marco de trabajo de "construcción" diferente al de las autotools/make de GNU que vimos utilizar en `c-lightning` anteriormente. Sin embargo, no te preocupes, es bastante fácil de instalar y utilizar las herramientas golang, y vamos a mostrar cada paso aquí. Go es un lenguaje fantástico para el desarrollo colaborativo de software porque produce un código muy consistente, preciso y fácil de leer independientemente del número de autores. Go está enfocado y es "minimalista" de una manera que fomenta la consistencia a través de las versiones del lenguaje. Como lenguaje compilado, también es bastante eficiente. Vamos a sumergirnos.

Seguiremos las instrucciones de instalación que se encuentran en https://github.com/lightningnetwork/lnd/blob/master/docs/INSTALL.md[documentación del proyecto LND].

En primer lugar, instalaremos el paquete +golang+ y las bibliotecas asociadas. Necesitamos estrictamente la versión 1.13 de Go o posterior. Los paquetes oficiales del lenguaje Go se distribuyen como binarios desde https://golang.org/dl[el proyecto Go]. Para mayor comodidad, también están empaquetados como paquetes Debian disponibles a través del comando +apt+. Puede seguir las instrucciones https://golang.org/dl[del Proyecto Go] o utilizar los siguientes comandos +apt+ en un sistema Linux Debian/Ubuntu como se describe en https://github.com/golang/go/wiki/Ubuntu[página wiki de GitHub sobre el lenguaje Go]:

[source,bash]
----
$ sudo apt install golang-go
----

Comprueba que tienes la versión correcta instalada y lista para usar ejecutando:

[source,bash]
----
$ go version
go version go1.13.4 linux/amd64
----

Tenemos la versión 1.13.4, así que estamos listos para... ¡Ir! A continuación, tenemos que decirle a cualquier programa dónde encontrar el código Go. Esto se logra estableciendo la variable de entorno +GOPATH+. Normalmente el código Go se encuentra en un directorio llamado _gocode_ directamente en el directorio personal del usuario. Con los siguientes dos comandos establecemos el +GOPATH+ de forma consistente y nos aseguramos de que su shell lo añade al +PATH+ de su ejecutable. Tenga en cuenta que el directorio personal del usuario se denomina +~+ en el shell.

[source,bash]
----
$ export GOPATH=~/gocode
$ export PATH=$PATH:$GOPATH/bin
----

Para evitar tener que establecer estas variables de entorno cada vez que abra un shell, puede añadir esas dos líneas al final de su archivo de configuración del shell +bash+ _.bashrc_ en su directorio personal, utilizando el editor de su elección.

==== Copiar el código fuente de LND.

Como ocurre con muchos proyectos de código abierto hoy en día, el código fuente de LND se encuentra en GitHub (www.github.com_). El comando +go get+ puede recuperarlo directamente utilizando el protocolo Git:

[source,bash]
----
$ go get -d github.com/lightningnetwork/lnd
----

Una vez que +go get+ termine, tendrá un subdirectorio en +GOPATH+ que contiene el código fuente de LND.

==== Compilación del código fuente de LND.

LND utiliza el sistema de compilación +make+. Para construir el proyecto, cambiamos de directorio al código fuente de LND y luego usamos +make+ así

[source,bash]
----
$ cd $GOPATH/src/github.com/lightningnetwork/lnd
$ make && make install
----

Después de varios minutos tendrás dos nuevos comandos, +lnd+ y +lncli+, instalados. Pruébalos y comprueba su versión para asegurarte de que están instalados:

[source,bash]
----
$ lnd --version
lnd version 0.10.99-beta commit=clock/v1.0.0-106-gc1ef5bb908606343d2636c8cd345169e064bdc91
$ lncli --version
lncli version 0.10.99-beta commit=clock/v1.0.0-106-gc1ef5bb908606343d2636c8cd345169e064bdc91
----

Es probable que veas una versión diferente a la mostrada anteriormente, ya que el software sigue evolucionando mucho después de la publicación de este libro. Sin embargo, independientemente de la versión que vea, el hecho de que los comandos se ejecuten y le muestren la información de la versión significa que ha logrado construir el software LND.

=== El proyecto Eclair Lightning Node.

Eclair (relámpago en francés) es una implementación en Scala de la Lightning Network realizada por ACINQ. Eclair es también uno de los monederos móviles Lightning más populares y pioneros, que utilizamos para demostrar un Lightning payment en <<getting-started>>. En esta sección examinamos el proyecto de servidor Eclair, que ejecuta un nodo Lightning. Eclair es un proyecto de código abierto y se puede encontrar en https://github.com/ACINQ/eclair[GitHub].

En las próximas secciones construiremos un contenedor Docker para ejecutar Eclair, como hicimos anteriormente con `c-lightning` y LND. También construiremos Eclair directamente desde el código fuente.

==== El contenedor Docker de Eclair.

Vamos a sacar el contenedor Eclair del libro desde el repositorio Docker Hub:

[source,bash]
----
$ docker pull lnbook/eclair
Using default tag: latest
latest: Pulling from lnbook/eclair
35807b77a593: Already exists
e1b85b9c5571: Already exists

[...]

c7d5d5c616c2: Pull complete
Digest: sha256:17a3d52bce11a62381727e919771a2d5a51da9f91ce2689c7ecfb03a6f028315
Status: Downloaded newer image for lnbook/eclair:latest
docker.io/lnbook/eclair:latest

----

Alternativamente, podemos construir el contenedor localmente, en su lugar. A estas alturas, ¡ya eres casi un experto en las operaciones básicas de Docker! En esta sección repetiremos muchos de los comandos vistos anteriormente para construir el contenedor Eclair. El contenedor se encuentra en _code/docker/eclair_. Comenzamos en una terminal cambiando el directorio de trabajo a _code/docker_ y emitiendo el comando +docker build+:

[source,bash]
----
$ cd code/docker
$ docker build -t lnbook/eclair eclair
Sending build context to Docker daemon  11.26kB
Step 1/27 : ARG OS=ubuntu
Step 2/27 : ARG OS_VER=focal
Step 3/27 : FROM ${OS}:${OS_VER} as os-base
 ---> fb52e22af1b0

[...]

Step 27/27 : CMD ["/usr/local/bin/logtail.sh"]
 ---> Running in fe639120b726
Removing intermediate container fe639120b726
 ---> e6c8fe92a87c
Successfully built e6c8fe92a87c
Successfully tagged lnbook/eclair:latest

----

Nuestra imagen ya está lista para funcionar. El contenedor Eclair también depende de una instancia de Bitcoin Core en ejecución. Como antes, necesitamos iniciar el contenedor +bitcoind+ en otro terminal y conectar Eclair a él a través de una red Docker. Ya hemos configurado una red Docker llamada +lnbook+, y la reutilizaremos aquí.

Una diferencia notable entre Eclair y LND o `c-lightning` es que Eclair no contiene un monedero de bitcoin separado, sino que se basa directamente en el monedero de bitcoin de Bitcoin Core. Recordemos que usando LND financiamos su monedero de bitcoin ejecutando una transacción para transferir bitcoin desde el monedero de Bitcoin Core al monedero de bitcoin de LND. Este paso no es necesario usando Eclair. Cuando se ejecuta Eclair, el monedero de Bitcoin Core se utiliza directamente como fuente de fondos para abrir canales. Como resultado, a diferencia de los contenedores LND o `c-lightning`, el contenedor Eclair no contiene un script para transferir bitcoin a su monedero en el arranque.

==== Ejecutando los contenedores bitcoind y Eclair.

Como antes, iniciamos el contenedor +bitcoind+ en un terminal y el contenedor Eclair en otro. Si ya tienes el contenedor +bitcoind+ funcionando, no necesitas reiniciarlo. Simplemente déjalo funcionando y sáltate el siguiente paso. Para iniciar +bitcoind+ en la red +lnbook+, usamos +docker run+ así:

[source,bash]
----
$ docker run -it --network lnbook --name bitcoind lnbook/bitcoind
----

A continuación, iniciamos el contenedor Eclair que acabamos de construir. Tendremos que adjuntarlo a la red +lnbook+ y darle un nombre, al igual que hicimos con los otros contenedores:

[source,bash]
----
$ docker run -it --network lnbook --name eclair lnbook/eclair
Waiting for bitcoind to start...
Waiting for bitcoind to mine blocks...
Starting eclair...
Eclair node started
INFO  o.b.Secp256k1Context - secp256k1 library successfully loaded
INFO  fr.acinq.eclair.Plugin - loading 0 plugins
INFO  a.e.slf4j.Slf4jLogger - Slf4jLogger started
INFO  fr.acinq.eclair.Setup - hello!
INFO  fr.acinq.eclair.Setup - version=0.4.2 commit=52444b0

[...]

----

El contenedor Eclair se inicia y se conecta al contenedor +bitcoind+ a través de la red Docker. Primero, nuestro nodo Eclair esperará a que +bitcoind+ se inicie, y luego esperará hasta que +bitcoind+ haya minado algunos bitcoins en su billetera.

Como hemos demostrado anteriormente, podemos emitir comandos a nuestro contenedor en otro terminal para extraer información, abrir canales, etc. El comando que nos permite emitir instrucciones de línea de comandos al demonio +eclair+ se llama +eclair-cli+. Al igual que antes, en este contenedor hemos proporcionado un útil alias a +eclair-cli+, llamado simplemente +cli+, que ofrece los argumentos y parámetros necesarios. Usando el comando +docker exec+ en otra ventana de terminal, obtenemos la información del nodo desde Eclair:

[source,bash]
----
$ docker exec eclair cli getinfo
{
  "version": "0.4.2-52444b0",
  "nodeId": "02fa6d5042eb8098e4d9c9d99feb7ebc9e257401ca7de829b4ce757311e0301de7",
  "alias": "eclair",
  "color": "#49daaa",
  "features": {

[...]

  },
  "chainHash": "06226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f",
  "network": "regtest",
  "blockHeight": 779,
  "publicAddresses": [],
  "instanceId": "01eb7a68-5db0-461b-bdd0-29010df40d73"
}

----

Ahora tenemos otro nodo Lightning ejecutándose en la red +lnbook+ y comunicándose con +bitcoind+. Se puede ejecutar cualquier número y cualquier combinación de nodos Lightning en la misma Lightning Network. Puede coexistir cualquier número de nodos Eclair, LND y `c-lightning`. Por ejemplo, para ejecutar un segundo nodo Eclair, deberá emitir el comando +docker run+ con un nombre de contenedor diferente, como sigue

[source,bash]
----
$ docker run -it --network lnbook --name eclair2 lnbook/eclair
----

En el comando anterior iniciamos otro contenedor Eclair llamado +eclair2+.

En la siguiente sección también veremos cómo descargar y compilar Eclair directamente desde el código fuente. Este es un paso opcional y avanzado que te enseñará a utilizar las herramientas de compilación de los lenguajes Scala y Java y te permitirá realizar modificaciones en el código fuente de Eclair. Con este conocimiento, puedes escribir algo de código o arreglar algunos errores.

[NOTE]
====
Si no estás planeando sumergirte en el código fuente o en la programación de un nodo Lightning, puedes saltarte la siguiente sección por completo. El contenedor Docker que acabamos de construir es suficiente para la mayoría de los ejemplos del libro.
====

==== Instalación de Eclair desde el código fuente.

En esta sección construiremos Eclair desde cero. Eclair está escrito en el lenguaje de programación Scala, que se compila utilizando el compilador de Java. Para ejecutar Eclair, primero necesitamos instalar Java y sus herramientas de compilación. Seguiremos las instrucciones que se encuentran en https://github.com/ACINQ/eclair/blob/master/BUILD.md[el documento _BUILD.md_] del proyecto Eclair.

El compilador de Java necesario es parte de OpenJDK 11. También necesitaremos un marco de construcción llamado Maven, versión 3.6.0 o superior.

En un sistema Debian/Ubuntu Linux, podemos utilizar el comando +apt+ para instalar tanto OpenJDK 11 como Maven, como se muestra a continuación:

[source,bash]
----
$ sudo apt install openjdk-11-jdk maven
----

Comprueba que tienes la versión correcta instalada ejecutando:

[source,bash]
----
$ javac -version
javac 11.0.7
$ mvn -v
Apache Maven 3.6.1
Maven home: /usr/share/maven
Java version: 11.0.7, vendor: Ubuntu, runtime: /usr/lib/jvm/java-11-openjdk-amd64

----

Tenemos OpenJDK 11.0.7 y Maven 3.6.1, así que estamos listos.

==== Copiando el código fuente de Eclair.

El código fuente de Eclair está en GitHub. El comando +git clone+ puede crear una copia local para nosotros. Cambiemos a nuestro directorio principal y ejecutémoslo allí:

[source,bash]
----
$ cd ~
$ git clone https://github.com/ACINQ/eclair.git

----

Una vez que +git clone+ termine, tendrás un subdirectorio +eclair+ que contiene el código fuente del servidor Eclair.

==== Compilación del código fuente de Eclair.

Eclair utiliza el sistema de compilación +Maven+. Para construir el proyecto, cambiamos el directorio de trabajo al código fuente de Eclair y luego usamos +mvn package+ así

[source,bash]
----
$ cd eclair
$ mvn package
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Build Order:
[INFO]
[INFO] --------------------< fr.acinq.eclair:eclair_2.13 >---------------------
[INFO] Building eclair_2.13 0.4.3-SNAPSHOT                                [1/4]
[INFO] --------------------------------[ pom ]---------------------------------

[...]


[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  01:06 min
[INFO] Finished at: 2020-12-12T09:43:21-04:00
[INFO] ------------------------------------------------------------------------

----


Después de varios minutos, la construcción del paquete Eclair debería completarse. Sin embargo, la acción "paquete" también ejecutará pruebas, y algunas de ellas se conectan a Internet y podrían fallar. Si quieres omitir las pruebas, añade +-DskipTests+ al comando.

Ahora, descomprime y ejecuta el paquete de construcción siguiendo las https://github.com/ACINQ/eclair#installing-eclair[instrucciones para instalar Eclair] de GitHub.

Enhorabuena. Has construido Eclair desde el código fuente y estás listo para codificar, probar, corregir errores y contribuir a este proyecto.

=== Construyendo una red completa de diversos nodos Lightning.

Nuestro ejemplo final, presentado en esta sección, reunirá todos los contenedores que hemos construido para formar una Lightning Network hecha de diversas implementaciones de nodos (LND, `c-lightning`, Eclair). Compondremos la red conectando los nodos entre sí y abriendo canales de un nodo a otro. Como paso final, enrutaremos un pago a través de estos canales.

En este ejemplo, construiremos una Lightning Network de demostración formada por cuatro nodos Lightning llamados Alice, Bob, Chan y Dina. Conectaremos a Alice con Bob, a Bob con Chan y a Chan con Dina. Esto se muestra en <<alice_bob_chan_dina_network_demo>>.

[[alice_bob_chan_dina_network_demo]]
.A small demonstration network of four nodes
image::images/mtln_1002.png["A small demonstration network of four nodes"]

Por último, haremos que Dina cree una invoice y que Alice la pague. Como Alice y Dina no están conectadas directamente, el pago será enrutado como un HTLC a través de todos los canales de pago.

==== Usando docker-compose para orquestar contenedores Docker.

Para que este ejemplo funcione, utilizaremos una herramienta de orquestación de contenedores que está disponible como un comando llamado +docker-compose+. Este comando nos permite especificar una aplicación compuesta por varios contenedores y ejecutar la aplicación lanzando todos los contenedores que cooperan juntos.

En primer lugar, vamos a instalar +docker-compose+. Las https://docs.docker.com/compose/install[instrucciones] dependen de tu sistema operativo.

Una vez que hayas completado la instalación, puedes verificar tu instalación ejecutando `docker-compose` de la siguiente manera:

[source,bash]
----
$ docker-compose version
docker-compose version 1.21.0, build unknown
[...]

----

Los comandos más comunes de +docker-compose+ que utilizaremos son +up+ y +down+, por ejemplo, +docker-compose up+.

==== Configuración de +docker-compose+.

El archivo de configuración de +docker-compose+ se encuentra en el directorio _code/docker_ y se llama _docker-compose.yml_. Contiene una especificación para una red y cada uno de los cuatro contenedores. La parte superior tiene el siguiente aspecto

----
version: "3.3"
networks:
  lnnet:

services:
  bitcoind:
    container_name: bitcoind
    build:
        context: bitcoind
    image: lnbook/bitcoind:latest
    networks:
      - lnnet
    expose:
      - "18443"
      - "12005"
      - "12006"

  Alice:
    container_name: Alice
----

El fragmento anterior define una red llamada +lnnet+ y un contenedor llamado +bitcoind+ que se adjuntará a la red +lnnet+. El contenedor es el mismo que construimos al principio de este capítulo. Exponemos tres de los puertos del contenedor, lo que nos permite enviarle comandos y monitorizar bloques y transacciones. A continuación, la configuración especifica un contenedor LND llamado "Alice". Más adelante también verás especificaciones para contenedores llamados "Bob" (`c-lightning`), "Chan" (Eclair), y "Dina" (LND de nuevo).

Dado que todas estas diversas implementaciones siguen la especificación BOLT y han sido ampliamente probadas para su interoperabilidad, no tienen ninguna dificultad para trabajar juntas para construir una Lightning Network.

==== Inicio de la Lightning Network de ejemplo.

Antes de empezar, debemos asegurarnos de que no estamos ejecutando ya ninguno de los contenedores. Si un nuevo contenedor comparte el mismo nombre que uno que ya se está ejecutando, entonces fallará el lanzamiento. Utilice +docker ps+, +docker stop+ y +docker rm+ según sea necesario para detener y eliminar cualquier contenedor que se esté ejecutando actualmente.

[TIP]
====
Dado que utilizamos los mismos nombres para estos contenedores Docker orquestados, es posible que tengamos que "limpiar" para evitar cualquier conflicto de nombres.
====

[role="pagebreak-before"]
Para iniciar el ejemplo, cambiamos al directorio que contiene el archivo de configuración _docker-compose.yml_ y emitimos el comando +docker-compose up+:

[source,bash]
----
$ cd code/docker
$ docker-compose up
Creating Chan     ... done
Creating Dina     ... done
Creating bitcoind ... done
Creating Bob      ... done
Creating Alice    ... done
Attaching to Chan, Dina, Alice, bitcoind, Bob
Alice       | Waiting for bitcoind to start...
Bob         | Waiting for bitcoind to start...
Dina        | Waiting for bitcoind to start...
Chan        | Waiting for bitcoind to start...
bitcoind    | Starting bitcoind...
bitcoind    | Waiting for bitcoind to start
bitcoind    | bitcoind started
bitcoind    | ================================================

[...]

Chan        | Starting eclair...
Dina        | Starting lnd...
Chan        | Eclair node started
Alice       | ...Waiting for bitcoind to mine blocks...
Bob         | ...Waiting for bitcoind to mine blocks...
Alice       | Starting lnd...
Bob         | Starting c-lightning...

[...]

----
Tras el arranque, verás todo un flujo de archivos de registro a medida que cada nodo arranca e informa de su progreso. Puede parecer bastante desordenado en tu pantalla, pero cada línea de salida está precedida por el nombre del contenedor, como se ha visto anteriormente. Si quieres ver los registros de un solo contenedor, puedes hacerlo en otra ventana de terminal utilizando el comando +docker-compose logs+ con la bandera +f+ (_follow_) y el nombre del contenedor específico:

[source,bash]
----
$ docker-compose logs -f Alice
----

==== Abrir canales y enrutar un pago.

Ahora nuestra Lightning Network debería estar funcionando. Como vimos en las secciones anteriores de este capítulo, podemos emitir comandos a un contenedor Docker en ejecución con el comando +docker exec+. Independientemente de que hayamos iniciado el contenedor con +docker run+ o hayamos iniciado un montón de ellos con +docker-compose up+, podemos seguir accediendo a los contenedores individualmente utilizando los comandos Docker.

La demo de pago está contenida en un script de Bash llamado +run-payment-demo.sh+. Para ejecutar esta demo debes tener el shell Bash instalado en tu ordenador. La mayoría de los sistemas Linux y similares a Unix (por ejemplo, macOS) tienen +bash+ preinstalado. Los usuarios de Windows pueden instalar el subsistema de Windows para Linux y utilizar una distribución de Linux como Ubuntu para obtener un comando +bash+ nativo en su ordenador.

Vamos a ejecutar el script para ver su efecto, y luego veremos cómo funciona internamente. Usamos +bash+ para ejecutarlo como un comando:

----
$ cd code/docker
$ bash run-payment-demo.sh
Starting Payment Demo
======================================================

Waiting for nodes to startup
- Waiting for bitcoind startup...
- Waiting for bitcoind mining...
- Waiting for Alice startup...
- Waiting for Bob startup...
- Waiting for Chan startup...
- Waiting for Dina startup...
All nodes have started
======================================================

Getting node IDs
- Alice:  0335e200756e156f1e13c3b901e5ed5a28b01a3131cd0656a27ac5cc20d4e71129
- Bob:    033e9cb673b641d2541aaaa821c3f9214e8a11ada57451ed5a0eab2a4afbce7daa
- Chan:   02f2f12182f56c9f86b9aa7d08df89b79782210f0928cb361de5138364695c7426
- Dina: 02d9354cec0458e0d6dee5cfa56b83040baddb4ff88ab64960e0244cc618b99bc3
======================================================

[...]

Setting up connections and channels
- Alice to Bob
- Open connection from Alice node to Bob's node

- Create payment channel Alice->Bob


[...]

Get 10k sats invoice from Dina
- Dina invoice:
lnbcrt100u1psnuzzrpp5rz5dg4wy27973yr7ehwns5ldeusceqdaq0hguu8c29n4nsqkznjsdqqcqzpgxqyz5vqsp5vdpehw33fljnmmexa6ljk55544f3syd8nfttqlm3ljewu4r0q20q9qyyssqxh5nhkpjgfm47yxn4p9ecvndz7zddlsgpufnpyjl0kmnq227tdujlm0acdv39hcuqp2vhs40aav70c9yp0tee6tgzk8ut79mr877q0cpkjcfvr
======================================================

Attempting payment from Alice to Dina
Successful payment!

----


Como puedes ver en la salida, el script primero obtiene los IDs de los nodos (claves públicas) para cada uno de los cuatro nodos. A continuación, conecta los nodos y establece un canal de 1.000.000 satoshi desde cada nodo al siguiente de la red. Finalmente, emite una invoice de 10.000 satoshis desde el nodo de Dina y paga la invoice desde el nodo de Alice.

[TIP]
====
Si el script falla, puedes intentar ejecutarlo de nuevo desde el principio. O puedes emitir manualmente los comandos que se encuentran en el script uno por uno y ver los resultados.
====

Hay mucho que revisar en ese script, pero a medida que vayas entendiendo la tecnología subyacente, más y más de esa información se volverá clara. Te invitamos a revisar este ejemplo más adelante.

Por supuesto, puedes hacer mucho más con esta red de prueba que un pago de tres canales y cuatro nodos. He aquí algunas ideas para sus experimentos:

* Crear una red más compleja lanzando muchos más nodos de diferentes tipos. Edite el archivo _docker-compose.yml_ y copie las secciones, renombrando los contenedores según sea necesario.

* Conecta los nodos en topologías más complejas: rutas circulares, hub-and-spoke, o malla completa.

* Ejecute muchos pagos para agotar la capacidad del canal. A continuación, ejecuta pagos en la dirección opuesta para reequilibrar los canales. Observa cómo se adapta el algoritmo de enrutamiento.

* Cambia las fees de los canales para ver cómo el algoritmo de enrutamiento negocia múltiples rutas y qué optimizaciones aplica. ¿Es mejor una ruta larga y barata que una ruta corta y cara?

* Ejecutar un pago circular desde un nodo hacia sí mismo para reequilibrar sus propios canales. Ver cómo afecta eso a todos los demás canales y nodos.

* Genera cientos o miles de pequeñas facturas en un bucle y luego págalas lo más rápido posible en otro bucle. Mida cuántas transacciones por segundo puede exprimir de esta red de prueba.

[TIP]
====
https://lightningpolar.com[Lightning Polar] te permite visualizar la red con la que has estado experimentando usando Docker
====

=== Conclusión.

En este capítulo hemos visto varios proyectos que implementan las especificaciones BOLT. Construimos contenedores para ejecutar una Lightning Network de ejemplo y aprendimos a construir cada proyecto desde el código fuente. Ahora estás listo para explorar más y profundizar. 



[[operating_ln_node]]
[[node_operations]]
== Operar un nodo de la Lightning Network.

Después de haber leído hasta aquí, probablemente hayas configurado un monedero Lightning. En este capítulo, llevaremos las cosas un paso más allá y configuraremos un nodo Lightning completo. Además de configurar uno, aprenderemos cómo operarlo y mantenerlo en el tiempo.

Hay muchas razones por las que podrías querer configurar tu propio nodo Lightning. Entre ellas:

* Para ser un participante completo y activo en la Lightning Network, no sólo un usuario final.
* Para gestionar una tienda de comercio electrónico o recibir ingresos a través de los pagos de Lightning
* Para obtener ingresos por las fees de enrutamiento de Lightning o por el alquiler de la liquidez del canal
* Desarrollar nuevos servicios, aplicaciones o complementos para la Lightning Network
* Para aumentar su privacidad financiera mientras utiliza Lightning
* Para utilizar algunas aplicaciones construidas sobre Lightning, como las aplicaciones de mensajería instantánea potenciadas por Lightning
* Para la libertad financiera, la independencia y la soberanía

El funcionamiento de un nodo de LN tiene costes asociados. Se necesita un ordenador, una conexión permanente a Internet, mucho espacio en disco y mucho tiempo.
Los costes operativos incluirán los gastos de electricidad.

Pero las habilidades que aprenderás de esta experiencia son valiosas y pueden aplicarse también a una variedad de otras tareas.

¡Empecemos!

[NOTE]
====
Es importante que establezcas tus propias expectativas correctamente en base a hechos precisos.
Si planeas operar un nodo Lightning _solamente_ para obtener ingresos ganando fees de enrutamiento, por favor haz tu tarea diligentemente primero. Dirigir un negocio rentable operando un nodo Lightning definitivamente _no_ es fácil. Calcule todos sus costes iniciales y continuos en una hoja de cálculo. Estudie detenidamente las estadísticas de LN.
¿Cuál es el volumen de pagos actual? ¿Cuál es el volumen por nodo? ¿Cuáles son las fees medias actuales de enrutamiento? Consulte los foros y pida consejo o comentarios a otros miembros de la comunidad que ya hayan adquirido experiencia en el mundo real. Forme su propia opinión educada sólo
_después_ de haber realizado este ejercicio de diligencia debida. La mayoría de las personas no encontrarán su motivación para dirigir un nodo en el beneficio económico, sino en otra parte.
====

=== Elección de la plataforma.

Hay muchas maneras de ejecutar un nodo Lightning, que van desde un pequeño mini PC alojado en su casa o un servidor dedicado, a un servidor alojado en la nube. El método que elijas dependerá de los recursos que tengas y del dinero que quieras gastar.

[[continuous_operation]]
==== ¿Por qué es importante la fiabilidad para ejecutar un nodo Lightning?

En Bitcoin, el hardware no es particularmente importante a menos que uno esté ejecutando específicamente un nodo de minería.
El software del nodo de Bitcoin Core puede ejecutarse en cualquier máquina que cumpla sus requisitos mínimos y no necesita estar en línea para recibir pagos, sólo para enviarlos.
Si un nodo de Bitcoin se cae durante un periodo de tiempo prolongado, el usuario puede simplemente reiniciar el nodo, y una vez que se conecte al resto de la red, volverá a sincronizar el blockchain.

En Lightning, sin embargo, el usuario necesita estar conectado tanto para enviar como para recibir pagos. Si el nodo de Lightning está desconectado, no puede recibir ningún pago de nadie y, por lo tanto, sus facturas abiertas no pueden cumplirse.
Además, los canales abiertos de un nodo sin conexión no pueden utilizarse para enrutar los pagos. Sus socios de canal se darán cuenta de que está desconectado y no podrán ponerse en contacto con usted para encaminar un pago. Si estás fuera de línea con demasiada frecuencia, pueden considerar que el bitcoin bloqueado en sus canales contigo es una capacidad infrautilizada, y pueden cerrar esos canales. Ya hemos hablado del caso de un ataque de protocolo en el que tu socio de canal intenta engañarte enviando una commitment transaction anterior. Si usted está fuera de línea y sus canales no están siendo monitoreados, entonces el intento de robo podría tener éxito, y usted no tendrá ningún recurso una vez que el bloqueo de tiempo expire.
Por lo tanto, la fiabilidad del nodo es extremadamente importante para un nodo Lightning.

También están los problemas de fallos de hardware y pérdida de datos. En Bitcoin, un fallo de hardware puede ser un problema trivial si el usuario tiene una copia de seguridad de su frase mnemónica o de sus claves privadas. El monedero de Bitcoin y el bitcoin dentro del monedero pueden ser fácilmente restaurados desde las claves privadas en un nuevo ordenador. La mayor parte de la información puede volver a descargarse de la blockchain.

En cambio, en Rayo la información sobre los canales del usuario, incluyendo las transacciones de compromiso y los secretos de revocación, no son conocidos públicamente y sólo se almacenan en el hardware del usuario individual.
Por lo tanto, los fallos de software y hardware en la Lightning Network pueden provocar fácilmente la pérdida de fondos. 

==== Tipos de nodos hardware Lightning.

Existen tres tipos principales de nodos hardware Lightning:

Ordenadores de uso general:: Un nodo LN puede ejecutarse en un ordenador doméstico o portátil con Windows, macOS o Linux. Normalmente se ejecuta junto a un nodo Bitcoin.
Hardware dedicado:: Un nodo Lightning también puede ejecutarse en hardware dedicado como una Raspberry Pi, Rock64 o un mini PC. Esta configuración suele ejecutar una pila de software, incluyendo un nodo Bitcoin y otras aplicaciones. Esta configuración es popular porque el hardware se dedica a ejecutar y mantener el nodo Lightning únicamente y suele configurarse con un "ayudante" de instalación.
Hardware preconfigurado:: Un nodo LN también puede ejecutarse en un hardware construido específicamente seleccionado y configurado para ello. Esto incluiría soluciones de nodo Lightning "listas para usar" que pueden adquirirse como un kit o un sistema llave en mano.

==== Funcionamiento en la "nube".

Los servicios de servidores privados virtuales (VPS) y de computación en la nube, como Microsoft Azure, Google Cloud, Amazon Web Services (AWS) o DigitalOcean, son bastante asequibles y pueden configurarse muy rápidamente. Un nodo Lightning puede alojarse por entre 20 y 40 dólares al mes en un servicio de este tipo.

Sin embargo, como dice el refrán, "la nube es sólo el ordenador de otras personas". Utilizar estos servicios significa ejecutar tu nodo en los ordenadores de otras personas. Esto conlleva las correspondientes ventajas y desventajas. Las principales ventajas son la comodidad, la eficiencia, el tiempo de actividad y, posiblemente, el coste. El operador de la nube gestiona y dirige el nodo en un alto grado, proporcionándole automáticamente comodidad y eficiencia. Proporcionan un excelente tiempo de actividad y disponibilidad, a menudo mucho mejor que lo que un individuo puede conseguir en casa. Si se tiene en cuenta que sólo el coste de la electricidad para hacer funcionar un servidor en muchos países occidentales ronda los 10 dólares al mes, y se añade a ello el coste del ancho de banda de la red y del propio hardware, la oferta de VPS se vuelve económicamente competitiva. Por último, con un VPS no necesitas espacio para un PC en casa y no tienes problemas de ruido o calor del PC.
Por otro lado, hay varias desventajas notables. Un nodo Lightning que se ejecuta en la "nube" siempre será menos seguro y menos privado que uno que se ejecuta en tu propio ordenador. Además, estos servicios de computación en la nube están muy centralizados. La gran mayoría de los nodos de Bitcoin y Lightning que se ejecutan en dichos servicios se encuentran en un puñado de centros de datos en Virginia, Sunnyvale, Seattle, Londres y Frankfurt. Cuando las redes o los centros de datos de estos proveedores tienen problemas de servicio, esto afecta a miles de nodos en las llamadas redes "descentralizadas".

Si tienes la posibilidad y la capacidad de ejecutar un nodo en tu propio ordenador en casa o en tu oficina, entonces esto puede ser preferible a ejecutarlo en la nube. Sin embargo, si ejecutar su propio servidor no es una opción, por supuesto considere ejecutar uno en un VPS.

==== Ejecutar un nodo en casa.

Si tienes una conexión a Internet de capacidad razonable en casa o en tu oficina, puedes ejecutar un nodo Lightning allí. Cualquier conexión de "banda ancha" es suficiente para ejecutar un nodo ligero, y una conexión rápida también le permitirá ejecutar un nodo completo de Bitcoin.

Aunque puede ejecutar un nodo Lightning (e incluso un nodo Bitcoin) en su ordenador portátil, se convertirá en algo molesto muy rápidamente. Estos programas consumen los recursos de tu ordenador y necesitan funcionar las 24 horas del día. Sus aplicaciones de usuario, como su navegador o su hoja de cálculo, competirán con los servicios de fondo de Lightning por los recursos de su ordenador. En otras palabras, tu navegador y otras cargas de trabajo del escritorio se ralentizarán.
Y cuando su aplicación de procesamiento de textos congele su ordenador portátil, su nodo Lightning también se caerá, dejándole sin poder recibir transacciones y potencialmente vulnerable a ataques. Además, nunca debes apagar tu portátil.
Todo esto combinado da como resultado una configuración que no es ideal. Lo mismo ocurrirá con su PC de escritorio personal de uso diario.

En su lugar, la mayoría de los usuarios optarán por ejecutar un nodo en un ordenador dedicado.
Afortunadamente, no es necesario un ordenador de clase "servidor" para hacerlo.
Puede ejecutar un nodo Lightning en un ordenador de placa única, como una Raspberry Pi o en un mini PC (normalmente comercializado como PC de cine en casa).
Se trata de ordenadores sencillos que suelen utilizarse como centro de automatización del hogar o servidor multimedia.
Son relativamente baratos en comparación con un PC o un portátil.
La ventaja de un dispositivo dedicado como plataforma para los nodos Lightning y Bitcoin es que puede funcionar de forma continua, silenciosa y discreta en su red doméstica, escondido detrás de su router o televisión.
Nadie sabrá que esta pequeña caja es en realidad parte de un sistema bancario global.

[WARNING]
====
No se recomienda operar un nodo en un sistema operativo de 32 bits y/o en una CPU de 32 bits, porque el software del nodo puede tener problemas de recursos, causando una caída y posiblemente una pérdida de fondos.
==== 

==== ¿Qué hardware se necesita para ejecutar un nodo Lightning?

Como mínimo, se requiere lo siguiente para ejecutar un nodo Lightning:

CPU:: Se necesita suficiente potencia de procesamiento para ejecutar un nodo Bitcoin, que descargará y validará continuamente nuevos bloques. El usuario también debe tener en cuenta la descarga inicial de bloques (IBD) al configurar un nuevo nodo Bitcoin, que puede tardar desde varias horas hasta varios días. Se recomienda una CPU de 2 o 4 núcleos.

RAM:: Un sistema con 2 GB de RAM _apenas_ funcionará con los nodos Bitcoin y Lightning. Funcionará mucho mejor con al menos 4 GB de RAM. El IBD será especialmente difícil con menos de 4 GB de RAM. Más de 8 GB de RAM es innecesario porque la CPU es el mayor cuello de botella para este tipo de servicios, debido a las operaciones criptográficas como la validación de firmas.

Unidad de almacenamiento:: Puede ser una unidad de disco duro (HDD) o una unidad de estado sólido (SSD).
Un SSD será significativamente más rápido (pero más caro) para ejecutar un nodo.
La mayor parte del almacenamiento se utiliza para el blockchain de Bitcoin, que tiene un tamaño de cientos de gigabytes.
Una compensación justa (coste por complejidad) es comprar un pequeño SSD para arrancar el sistema operativo, y un disco duro más grande para almacenar grandes objetos de datos (principalmente bases de datos).

[NOTE]
====
Las Raspberry Pis son una opción común para ejecutar software de nodo, debido al coste y la disponibilidad de piezas.
El sistema operativo que se ejecuta en el dispositivo suele arrancar desde una tarjeta digital segura (SD).
Para la mayoría de los casos de uso, esto no es un problema, pero Bitcoin Core es notorio por ser pesado en E/S.
Deberías asegurarte de colocar el blockchain de Bitcoin y el directorio de datos de Lightning en una unidad diferente porque la E/S intensiva a largo plazo puede hacer que la tarjeta SD falle.
====

Conexión a Internet:: Se necesita una conexión a Internet fiable para descargar nuevos bloques de Bitcoin, así como para comunicarse con otros pares de Lightning. Durante el funcionamiento, el uso de datos estimado oscila entre 10 y 100 GB al mes, dependiendo de la configuración. Al arrancar, un nodo de Bitcoin completo descarga la blockchain completa.

Fuente de alimentación:: Se requiere una fuente de alimentación fiable porque los nodos Lightning necesitan estar en línea en todo momento. Un fallo de alimentación hará que los pagos en curso fallen. En el caso de los nodos de enrutamiento de alto rendimiento, es útil contar con un sistema de alimentación ininterrumpida (SAI) en caso de que se produzcan cortes de energía.
Lo ideal es conectar también el router de Internet a este SAI.

Copia de seguridad:: Las copias de seguridad son cruciales porque un fallo puede provocar la pérdida de datos y, por tanto, de fondos.
Deberá considerar algún tipo de solución de copia de seguridad de los datos. Podría ser una copia de seguridad automatizada basada en la nube en un servidor o servicio web que usted controle. También puede ser una copia de seguridad local automatizada, como un segundo disco duro. Para obtener los mejores resultados, se pueden combinar las copias de seguridad locales y remotas.

==== Cambiar la configuración del servidor en la nube.

Cuando se alquila un servidor en la nube, a menudo es rentable cambiar la configuración entre dos fases de funcionamiento. Se necesitará una CPU más rápida y un almacenamiento más rápido durante el IBD (por ejemplo, el primer día). Después de que la blockchain se haya sincronizado, los requisitos de velocidad de la CPU y el almacenamiento son mucho menores, por lo que el rendimiento puede reducirse a un nivel más rentable.

Por ejemplo, en la nube de Amazon, utilizaríamos una memoria RAM de 8&ndash;16 GB, una CPU de 8 núcleos (por ejemplo, t3-large o m3.large) y un SSD más rápido de 400 GB (1000+ operaciones de entrada/salida por segundo [IOPS] provisionadas) para el IBD, reduciendo su tiempo a sólo 6-8 horas. Una vez completado esto, cambiaríamos la instancia del servidor a una CPU de 2 GB de RAM y 2 núcleos (por ejemplo, t3.small) y el almacenamiento a un disco duro de 1 TB de uso general. Esto costará más o menos lo mismo que si se ejecuta en el servidor más lento todo el tiempo, pero se pondrá en marcha en menos de un día en lugar de tener que esperar casi una semana para el IBD.

===== Almacenamiento permanente de datos (disco).

Si utilizas un mini PC o alquilas un servidor, el almacenamiento puede ser la parte más cara, costando tanto como el ordenador y la conectividad (datos) sumados.

Veamos las diferentes opciones disponibles. En primer lugar, hay dos tipos principales de discos, los HDD y los SSD. Los HDD son más baratos y los SSD son más rápidos, pero ambos cumplen su función.

Las unidades SSD más rápidas disponibles en la actualidad utilizan la interfaz Non-Volatile Memory Express (NVMe). Las SSD NVMe son más rápidas en máquinas de gama alta, pero también más costosas.
Las SSD tradicionales basadas en SATA son más baratas, pero no tan rápidas. Las unidades SSD SATA tienen un rendimiento suficiente para la configuración de su nodo.
Los ordenadores más pequeños quizá no puedan aprovechar las SSD NVMe.
Por ejemplo, la Raspberry Pi 4 no puede beneficiarse de ellas debido al limitado ancho de banda de su puerto USB.

Para elegir el tamaño, fijémonos en la blockchain de Bitcoin. En agosto de 2021, su tamaño es de 360 GB, incluyendo el índice de transacciones, y crece aproximadamente 60 GB al año. Si quieres tener algo de margen disponible para el crecimiento futuro o para instalar otros datos en tu nodo, compra al menos una unidad de 512 GB, o mejor aún, una unidad de 1 TB. 

[[helpers]]
=== Usando un instalador o ayudante.

Instalar un nodo Lightning o un nodo Bitcoin puede ser desalentador si no estás familiarizado con un entorno de línea de comandos. Por suerte, hay varios proyectos que hacen "ayudantes", es decir, software que instala y configura los distintos componentes por ti. Usted todavía tendrá que aprender algunos conjuros de línea de comandos para interactuar con su nodo, pero la mayor parte del trabajo inicial se hace por usted.

==== RaspiBlitz.

Uno de los "ayudantes" más populares y completos es _RaspiBlitz_ (<<RaspiBlitz>>), un proyecto construido por Christian Rotzoll. Está pensado para ser instalado en una Raspberry Pi 4. RaspiBlitz viene con un kit de hardware recomendado que puedes construir en cuestión de horas o como mucho un fin de semana. Si asistes a un "hackathon" de Lightning en tu ciudad, es probable que veas a muchas personas trabajando en su configuración de RaspiBlitz, intercambiando consejos y ayudándose mutuamente. Puedes encontrar el proyecto RaspiBlitz en https://github.com/rootzoll/raspiblitz[GitHub].

Además de un nodo Bitcoin y Lightning, RaspiBlitz puede instalar un número de servicios adicionales, tales como:

* Tor (se ejecuta como servicio oculto)
* ElectRS (servidor de Electrum en Rust)
* Servidor BTCPay (procesador de pagos de criptomonedas)
* BTC RPC Explorer (explorador de la blockchain de Bitcoin)
* Ride The Lightning (GUI de gestión de nodos Lightning)
* LNbits (sistema de cuentas/monederos Lightning)
* Specter Desktop (monedero multisig Trezor, Ledger, Coldcard y Specter-DIY)
* lndmanage (interfaz de línea de comandos para la gestión avanzada de canales)
* Loop (servicio de swaps submarinos)
* JoinMarket (servicio CoinJoin)

[[RaspiBlitz]]
.A RaspiBlitz node
image::images/mtln_0501.png[]

==== Mynode.

https://mynodebtc.com[_myNode_] es otro popular proyecto de "ayuda" de código abierto que incluye mucho software relacionado con Bitcoin. Es fácil de instalar: se "flashea" el instalador en una tarjeta SD y se arranca el mini PC desde la tarjeta SD. No necesitas ningún monitor para usar myNode porque las herramientas administrativas son accesibles remotamente desde un navegador. Si tu mini PC no tiene monitor, ratón o teclado, puedes administrarlo desde otro ordenador o incluso desde tu smartphone. Una vez instalado, vaya a http://mynode.local y cree un monedero y un nodo Lightning en dos clics.

Además de un nodo Bitcoin y Lightning, myNode puede instalar opcionalmente una variedad de servicios adicionales, como:

* Ride The Lightning (interfaz gráfica de gestión de nodos Lightning)
* OpenVPN (red privada virtual [VPN] para la gestión remota o el monedero)
* lndmanage (interfaz de línea de comandos para la gestión avanzada de canales)
* BTC RPC Explorer (un explorador de blockchain de Bitcoin)

==== Umbrel.

Famoso por su UX/UI (mostrado en <<umbrel>>), _Umbrel_ proporciona una forma muy fácil y accesible de poner en marcha tu nodo Bitcoin y Lightning en poco tiempo, especialmente para los principiantes. Una característica muy distintiva es que Umbrel utiliza Neutrino/SPV durante el IBD para que puedas empezar a utilizar tu nodo al instante. Una vez que Bitcoin Core está completamente sincronizado en segundo plano, cambia automáticamente y desactiva el modo SPV. Umbrel OS es compatible con la Raspberry Pi 4 y también se puede instalar en cualquier sistema operativo basado en Linux o en una máquina virtual en macOS o Windows. También puede conectar cualquier billetera que soporte Bitcoin Core P2P, Bitcoin Core RPC, el protocolo Electrum o lndconnect.

No hay necesidad de esperar a un día lluvioso&mdash;puede ir directamente a https://getumbrel.com[Umbrel] para aprender más.

[[umbrel]]
.The Umbrel web interface
image::images/mtln_0502.png["The Umbrel web interface"]

Además de un nodo Bitcoin y Lightning, Umbrel introdujo la Umbrel App Store, donde se pueden instalar fácilmente servicios adicionales, como:

* Lightning Terminal (interfaz para gestionar la liquidez del canal, Loop In y Loop Out)
* Ride The Lightning (interfaz gráfica de gestión del nodo Lightning)
* Specter Desktop (coordinador de vigilancia para monederos Bitcoin multifirma y de clave única)
* BTCPay Server (procesador de pagos de criptomonedas)
* BTC RPC Explorer (explorador de la blockchain de Bitcoin)
* ThunderHub (monitoriza y gestiona su nodo)
* Sphinx Relay (gestión de la conectividad y el almacenamiento para el chat de Sphinx)
* mempool.space (visualizador de mempool y explorador de bloques)
* LNbits (sistema de cuentas/monederos Lightning)

Umbrel está actualmente en fase beta y no se considera seguro.

==== Servidor BTCPay.

Aunque no se diseñó inicialmente como un "ayudante" de instalación, la plataforma de comercio electrónico y pagos _BTCPay Server_ tiene un sistema de instalación increíblemente sencillo que utiliza contenedores Docker y +docker-compose+ para instalar un nodo Bitcoin, un nodo Lightning y una pasarela de pagos, entre otros muchos servicios. Se puede instalar en una gran variedad de plataformas de hardware, desde una simple Raspberry Pi 4 (4 GB recomendados) hasta un mini PC o un viejo ordenador portátil, de sobremesa o servidor. 

https://btcpayserver.org[BTCPay Server] es una plataforma de comercio electrónico con todas las características de auto-alojamiento y auto-custodia que se puede integrar con muchas plataformas de comercio electrónico, como WordPress WooCommerce y otros. La instalación del nodo completo es sólo un paso de la instalación de la plataforma de comercio electrónico.
Aunque originalmente se desarrolló como un reemplazo característica por característica del servicio de pago comercial _BitPay_ y la API, ha evolucionado más allá de eso para ser una plataforma completa para los servicios de BTC y Lightning relacionados con el comercio electrónico. Para muchos vendedores o tiendas es una solución llave en mano para el comercio electrónico.

Además de un nodo de Bitcoin y Lightning, BTCPay Server también puede instalar una variedad de servicios, incluyendo:

* `c-lightning` o nodo Lightning LND
* Soporte para Litecoin
* Soporte para Monero
* Servidor Spark (monedero web `c-lightning`)
* Servidor Charge (API de comercio electrónico de `c-lightning`)
* Ride The Lightning (interfaz gráfica de usuario para la gestión del nodo Lightning)
* Muchos forks de BTC
* BTCTransmuter (servicio de automatización de acciones de eventos para el intercambio de divisas)

El número de servicios y características adicionales está creciendo rápidamente, por lo que la lista anterior es sólo un pequeño subconjunto de lo que está disponible en la plataforma del servidor BTCPay.

==== Bitcoin Node o Lightweight Lightning.

Una elección crítica para su configuración será la elección del nodo Bitcoin y su configuración. Bitcoin Core, la implementación de referencia, es la opción más común pero no la única disponible. Una opción alternativa es _btcd_, que es una implementación en lenguaje Go de un nodo Bitcoin. btcd soporta algunas características que son útiles para ejecutar un nodo LND Lightning y que no están disponibles en Bitcoin Core.

Una segunda consideración es si va a ejecutar un nodo Bitcoin _archival_ con una copia completa del blockchain (unos 350 GB a mediados de 2021) o un blockchain _pruned_ que sólo mantiene los bloques más recientes. Un blockchain podado puede ahorrarte algo de espacio en disco, pero seguirás necesitando descargar el blockchain completo al menos una vez (durante el IBD). Por lo tanto, no le ahorrará ningún tráfico de red. El uso de un nodo podado para ejecutar un nodo Lightning es todavía una capacidad experimental y podría no soportar toda la funcionalidad. Sin embargo, mucha gente está ejecutando un nodo así con éxito.

Por último, también tiene la opción de no ejecutar un nodo Bitcoin en absoluto. En su lugar, puede operar el nodo LND Lightning en modo "ligero", utilizando el Protocolo Neutrino para recuperar la información de la blockchain de los nodos Bitcoin públicos operados por otros. Funcionar así significa que está tomando recursos de la red Bitcoin sin ofrecer ninguno a cambio. En cambio, está ofreciendo sus recursos y contribuyendo a la comunidad LN. En el caso de los nodos Lightning más pequeños, esto suele reducir el tráfico de la red en comparación con el funcionamiento de un nodo Bitcoin completo.

Tenga en cuenta que el funcionamiento de un nodo Bitcoin le permite dar soporte a otros servicios, además de un nodo Lightning y por encima de él. Estos otros servicios pueden requerir un nodo Bitcoin de archivo (no podado) y a menudo no pueden funcionar sin un nodo Bitcoin. Considere por adelantado qué otros servicios puede querer ejecutar ahora o en el futuro para tomar una decisión informada sobre el tipo de nodo Bitcoin que seleccione.

La conclusión para esta decisión es: si puede permitirse un disco de más de 500 GB, ejecute un nodo Bitcoin de archivo completo. Estará contribuyendo con recursos al sistema Bitcoin y ayudando a otros que no pueden permitírselo. Si no puede permitirse un disco tan grande, ejecute un nodo podado. Si no puede permitirse el disco o el ancho de banda incluso para un nodo podado, ejecute un nodo LND ligero sobre Neutrino.

==== Elección del sistema operativo.

El siguiente paso es seleccionar un sistema operativo para su nodo. La gran mayoría de los servidores de Internet funcionan con alguna variante de Linux. Linux es la plataforma elegida para Internet porque es un potente sistema operativo de código abierto. Sin embargo, Linux tiene una empinada curva de aprendizaje y requiere estar familiarizado con un entorno de línea de comandos. A menudo resulta intimidante para los nuevos usuarios.

En última instancia, la mayoría de los servicios pueden ejecutarse en cualquier sistema operativo POSIX moderno, que incluye macOS, Windows y, por supuesto, Linux. Tu elección debería estar motivada más por tu familiaridad y comodidad con un sistema operativo y por tus objetivos de aprendizaje. Si quieres ampliar tus conocimientos y aprender a manejar un sistema Linux, esta es una gran oportunidad para hacerlo con un proyecto específico y un objetivo claro. Si sólo quieres poner en marcha un nodo, sigue con lo que sabes.

Hoy en día, muchos servicios también se entregan en forma de contenedores, normalmente basados en el sistema Docker. Estos contenedores pueden desplegarse en una variedad de sistemas operativos, abstrayendo el SO subyacente. No obstante, es posible que tengas que aprender algunos comandos de la CLI de Linux, ya que la mayoría de los contenedores ejecutan alguna variante de Linux en su interior. 

=== Elija su implementación de nodos Lightning.

Al igual que con la elección del sistema operativo, la elección de la implementación del nodo Lightning debería depender principalmente de su familiaridad con el lenguaje de programación y las herramientas de desarrollo utilizadas por los proyectos. Aunque hay algunas pequeñas diferencias en las características entre las distintas implementaciones de nodos, éstas son relativamente menores, y la mayoría de las implementaciones convergen en los estándares comunes definidos por los BOLT.

Por otro lado, la familiaridad con el lenguaje de programación y el sistema de compilación es una buena base para elegir un nodo. Esto se debe a que la instalación, la configuración, el mantenimiento continuo y la resolución de problemas implican la interacción con las diversas herramientas utilizadas por el sistema de compilación. Esto incluye:

* Make, Autotools, y utilidades GNU para `c-lightning`.
* Utilidades Go para LND
* Java/Maven para Eclair

El lenguaje de programación influye no sólo en la elección del sistema de compilación, sino también en muchos otros aspectos del programa. Cada lenguaje de programación viene con toda una filosofía de diseño y afecta a muchos otros aspectos, como:

* El formato y la sintaxis de los archivos de configuración
* Ubicación de los archivos (en el sistema de archivos)
* Argumentos de la línea de comandos y su sintaxis
* Formato de los mensajes de error
* Bibliotecas de requisitos previos
* Interfaces de llamada a procedimientos remotos

Cuando elige su nodo Lightning, también está eligiendo todas las características mencionadas. Por lo tanto, su familiaridad con estas herramientas y filosofías de diseño facilitará la ejecución de un nodo. O más difícil, si aterrizas en un dominio desconocido.

Por otro lado, si se trata de tu primera incursión en la línea de comandos y el entorno de servidores/servicios, te encontrarás con que no estás familiarizado con ninguna implementación y tendrás la oportunidad de aprender algo completamente nuevo. En ese caso, es posible que quieras decidir en base a otros factores, como:

* La calidad de los foros de soporte y las salas de chat
* Calidad de la documentación
* Grado de integración con otras herramientas que desee ejecutar

Como consideración final, puede querer examinar el rendimiento y la fiabilidad de las diferentes implementaciones de nodos. Esto es especialmente importante si va a utilizar este nodo en un entorno de producción y espera un tráfico intenso y requisitos de alta fiabilidad. Este podría ser el caso si planea ejecutar el sistema de pago de una tienda en él.

=== Instalar un nodo Bitcoin o Lightning.

¿Has decidido no utilizar un "ayudante" de instalación y en su lugar sumergirte en la línea de comandos de un sistema operativo Linux? Es una decisión valiente, e intentaremos ayudarte a que funcione. Si prefieres no intentar hacerlo manualmente, considera usar una aplicación que te ayude a instalar el software del nodo o una solución basada en contenedores, como se describe en <<helpers>>.

[WARNING]
====
Esta sección profundizará en el tema avanzado de la administración del sistema desde la línea de comandos. La administración de Linux es su propio conjunto de habilidades que está fuera del alcance de este libro. Es un tema complicado y hay muchas trampas. Proceda con precaución.
====

En las siguientes secciones describiremos brevemente cómo instalar y configurar un nodo Bitcoin y Lightning en un sistema operativo Linux. Deberá revisar las instrucciones de instalación de las aplicaciones específicas del nodo Bitcoin y Lightning que haya decidido utilizar. Normalmente puede encontrarlas en un archivo llamado _INSTALL_ o en el subdirectorio _docs_ de cada proyecto. Sólo describiremos algunos de los pasos comunes que se aplican a todos estos servicios, y las instrucciones que ofrecemos serán necesariamente incompletas.

==== Servicios de fondo.

Para quienes están acostumbrados a ejecutar aplicaciones en su escritorio o smartphone, una aplicación siempre tiene una interfaz gráfica de usuario, aunque a veces se ejecute en segundo plano. Sin embargo, las aplicaciones de los nodos Bitcoin y Lightning son muy diferentes. Estas aplicaciones no tienen una interfaz gráfica de usuario incorporada. En su lugar, se ejecutan como servicios de fondo _sin cabeza_, lo que significa que siempre están operando en segundo plano y no interactúan con el usuario directamente.

Esto puede crear cierta confusión a los usuarios que no están acostumbrados a ejecutar servicios en segundo plano. ¿Cómo saber si un servicio de este tipo se está ejecutando? ¿Cómo se inicia y se detiene? ¿Cómo se interactúa con él? Las respuestas a estas preguntas dependen del sistema operativo que utilices. Por ahora asumiremos que estás usando alguna variante de Linux y las responderemos en ese contexto. 

==== Aislamiento de procesos.

Los servicios en segundo plano suelen ejecutarse bajo una cuenta de usuario específica para aislarlos del sistema operativo y de los demás. Por ejemplo, Bitcoin Core está configurado para ejecutarse como usuario +bitcoin+. Deberá utilizar la línea de comandos para crear un usuario para cada uno de los servicios que ejecute.

Además, si ha conectado una unidad externa, tendrá que decirle al sistema operativo que reubique el directorio de inicio del usuario en esa unidad. Esto se debe a que un servicio como Bitcoin Core creará archivos bajo el directorio personal del usuario. Si lo está configurando para descargar la blockchain completa de Bitcoin, estos archivos ocuparán varios cientos de gigabytes. Aquí, asumimos que has conectado el disco externo y que está ubicado en la ruta _/external_drive/_ del sistema operativo.

En la mayoría de los sistemas Linux puedes crear un nuevo usuario con el comando +useradd+, así:

----
$ sudo useradd -m -d /external_drive/bitcoin -s /dev/null bitcoin
----

Las banderas +m+ y +d+ crean el directorio de inicio del usuario como se especifica en _/unidad_externa/bitcoin_ en este caso. La bandera +s+ asigna el shell interactivo del usuario. En este caso, lo ponemos a _/dev/null_ para deshabilitar el uso del shell interactivo. El último argumento es el nombre de usuario del nuevo usuario +bitcoin+.

==== Inicio del nodo.

Para los servicios de los nodos Bitcoin y Lightning, la "instalación" también implica la creación de un llamado _script de inicio_ para asegurarse de que el nodo se inicie cuando el ordenador arranque. El arranque y el apagado de los servicios en segundo plano son gestionados por un proceso del sistema operativo, que en Linux se llama +init+ o +systemd+. Normalmente puedes encontrar un script de inicio del sistema en el subdirectorio +contrib+ de cada proyecto. Por ejemplo, si estás en un sistema operativo Linux moderno que utiliza +systemd+, encontrarás un script llamado _bitcoind.service_ que puede iniciar y detener el servicio del nodo Bitcoin Core.

Aquí hay un ejemplo de cómo es el script de inicio de un nodo Bitcoin, tomado del repositorio de código de Bitcoin Core:

.From bitcoin/contrib/init/bitcoind.service
----
[Unit]
Description=Bitcoin daemon
After=network.target

[Service]
ExecStart=/usr/bin/bitcoind -daemon \
                            -pid=/run/bitcoind/bitcoind.pid \
                            -conf=/etc/bitcoin/bitcoin.conf \
                            -datadir=/var/lib/bitcoind

# Make sure the config directory is readable by the service user
PermissionsStartOnly=true
ExecStartPre=/bin/chgrp bitcoin /etc/bitcoin

# Process management
####################

Type=forking
PIDFile=/run/bitcoind/bitcoind.pid
Restart=on-failure
TimeoutStopSec=600

# Directory creation and permissions
####################################

# Run as bitcoin:bitcoin
User=bitcoin
Group=bitcoin

# /run/bitcoind
RuntimeDirectory=bitcoind
RuntimeDirectoryMode=0710

# /etc/bitcoin
ConfigurationDirectory=bitcoin
ConfigurationDirectoryMode=0710

# /var/lib/bitcoind
StateDirectory=bitcoind
StateDirectoryMode=0710

[...]

[Install]
WantedBy=multi-user.target
----

Como usuario root, instale el script copiándolo en la carpeta del servicio +systemd+ _/lib/systemd/system/_ y luego recargue +systemd+:

----
$ sudo systemctl daemon-reload
----

[role="pagebreak-before"]
A continuación, habilita el servicio:

----
$ sudo systemctl enable bitcoind
----

Ahora puede iniciar y detener el servicio. No lo inicies todavía, ya que no hemos configurado el nodo Bitcoin.

----
$ sudo systemctl start bitcoind
$ sudo systemctl stop bitcoind
----

==== Configuración del nodo.

Para configurar su nodo, necesita crear y referenciar un archivo de configuración. Por convención, este archivo suele crearse en _/etc_, bajo un directorio con el nombre del programa. Por ejemplo, las configuraciones de Bitcoin Core y LND suelen almacenarse en _/etc/bitcoin/bitcoin.conf_ y
_/etc/lnd/lnd.conf_, respectivamente.

Estos archivos de configuración son archivos de texto en los que cada línea expresa una opción de configuración y su valor. Se asumen valores por defecto para cualquier cosa que no esté definida en el archivo de configuración. Puede ver qué opciones se pueden establecer en la configuración de dos maneras. En primer lugar, ejecutando la aplicación de nodos con un argumento +help+ se mostrarán las opciones que se pueden definir en la línea de comandos. Estas mismas opciones se pueden definir en el archivo de configuración. En segundo lugar, normalmente se puede encontrar un archivo de configuración de ejemplo, con todas las opciones por defecto, en el repositorio de código del software.

Puedes encontrar un ejemplo de archivo de configuración en cada una de las imágenes Docker que utilizamos en <<set_up_a_lightning_node>>. Por ejemplo, el archivo _code/docker/bitcoind/bitcoind/bitcoin.conf_:

.Configuration file for docker bitcoind (code/docker/bitcoind/bitcoind/bitcoin.conf)
----
include::code/docker/bitcoind/bitcoind/bitcoin.conf[]
----

Ese archivo de configuración en particular configura Bitcoin Core para operar como un nodo de +registro+ y proporciona un nombre de usuario y una contraseña débiles para el acceso remoto, por lo que no debería usarlo para la configuración de su nodo. Sin embargo, sirve para ilustrar la sintaxis de un archivo de configuración y puedes hacer ajustes en él en el contenedor Docker para experimentar con diferentes opciones. Mira si puedes usar el comando +bitcoind -help+ para entender qué hace cada una de las opciones en el contexto de la red Docker que construimos en <<set_up_a_lightning_node>>.

A menudo, los valores predeterminados son suficientes, y con unas pocas modificaciones su software de nodo puede ser configurado rápidamente. Para tener un nodo Bitcoin Core funcionando con una personalización mínima, sólo necesitas cuatro líneas de configuración:

[source, subs="quotes"]
----
server=1
daemon=1
txindex=1
rpcuser=_USERNAME_
rpcpassword=_PASSWORD_
----

Incluso la opción +txindex+ no es estrictamente necesaria, aunque asegurará que su nodo Bitcoin cree un índice de todas las transacciones, lo cual es necesario para algunas aplicaciones. La opción +txindex+ no es necesaria para ejecutar un nodo Lightning.

Un nodo Lightning `c-lightning` que se ejecuta en el mismo servidor también requiere sólo unas pocas líneas en la configuración:

[source, subs="quotes"]
----
network=mainnet
bitcoin-rpcuser=_USERNAME_
bitcoin-rpcpassword=_PASSWORD_
----

En general, es una buena idea minimizar la cantidad de personalización de estos sistemas. La configuración por defecto está cuidadosamente diseñada para soportar los despliegues más comunes. Si modifica un valor por defecto, puede causar problemas más adelante o reducir el rendimiento de su nodo. En resumen, ¡modifique sólo cuando sea necesario!

==== Configuración de la red.

La configuración de la red normalmente no es un problema cuando se configura una nueva aplicación. Sin embargo, las redes peer-to-peer como Bitcoin y Lightning Network presentan algunos desafíos únicos para la configuración de la red.

En un servicio centralizado, su ordenador se conecta a los "grandes servidores" de alguna corporación, y no al revés. En realidad, tu conexión a Internet está configurada bajo el supuesto de que eres simplemente un consumidor de servicios proporcionados por otros. Pero en un sistema peer-to-peer, cada peer consume de y proporciona servicios a otros nodos. Si está ejecutando un nodo Bitcoin o Lightning en su casa, está proporcionando un servicio a otros ordenadores en Internet. Su servicio de Internet por defecto no está configurado para permitirle ejecutar servidores y puede necesitar alguna configuración adicional para permitir que otros lleguen a su nodo.

Si quiere ejecutar un nodo de Bitcoin o Lightning, necesita hacer posible que otros nodos en Internet se conecten a usted. Eso significa habilitar las conexiones TCP entrantes al puerto Bitcoin (puerto 8333 por defecto) o al puerto Lightning (puerto 9735 por defecto). Mientras que se puede ejecutar un nodo Bitcoin sin conectividad entrante, no se puede hacer eso con un nodo Lightning. Un nodo Lightning debe ser accesible a otros desde fuera de su red.

Por defecto, el router de internet de tu casa no espera conexiones entrantes desde el exterior, y de hecho las conexiones entrantes están bloqueadas. La dirección IP de tu router de Internet es la única dirección IP accesible desde el exterior, y todos los ordenadores que funcionan dentro de tu red doméstica comparten esa única dirección IP. Esto se consigue gracias a un mecanismo llamado _Traducción de direcciones de red_ (_NAT_), que permite a tu router de internet actuar como intermediario para todas las conexiones salientes. Si quieres permitir una conexión entrante, tienes que configurar el _reenvío de puertos_, que indica a tu router de Internet que las conexiones entrantes en puertos específicos deben ser reenviadas a ordenadores específicos dentro de la red. Puedes hacerlo manualmente cambiando la configuración de tu router de Internet o, si tu router lo soporta, a través de un mecanismo de reenvío de puertos automático llamado _Universal Plug and Play_ (_UPnP_).

Un mecanismo alternativo al reenvío de puertos es habilitar The Onion Router (Tor), que proporciona una especie de superposición de red privada virtual que permite conexiones entrantes a una _dirección de cebolla_. Si ejecuta Tor, no necesita hacer el reenvío de puertos o habilitar las conexiones entrantes a los puertos de Bitcoin o Lightning. Si ejecuta sus nodos usando Tor, todo el tráfico va a través de Tor y no se usan otros puertos.

Veamos diferentes maneras de hacer posible que otros se conecten a su nodo. Veremos estas alternativas en orden, de la más fácil a la más difícil.

===== ¡Sólo funciona!.

Existe la posibilidad de que tu proveedor de servicios de Internet o tu router estén configurados para soportar UPnP por defecto y todo funcione automáticamente. Vamos a probar este enfoque primero, por si acaso tenemos suerte.

Asumiendo que ya tienes un nodo Bitcoin o Lightning funcionando, vamos a probar y ver si son accesibles desde el exterior.

[NOTE]
====
Para que esta prueba funcione, tienes que tener un nodo Bitcoin o Lightning (o ambos) funcionando en tu red doméstica. Si tu router soporta UPnP, el tráfico entrante será automáticamente reenviado a los puertos correspondientes en el ordenador que ejecuta el nodo.
====

Puedes utilizar algunos sitios web muy populares y útiles para averiguar cuál es tu dirección IP externa y si permite y reenvía las conexiones entrantes a un puerto conocido. Aquí hay dos que son fiables:

* https://canyouseeme.org[]
* https://www.whatismyip.com/port-scanner[]

Por defecto, estos servicios sólo permiten comprobar las conexiones entrantes a la dirección IP desde la que te estás conectando. Esto se hace para evitar que uses el servicio para escanear las redes y ordenadores de otras personas. Verás la dirección IP externa de tu router y un campo para introducir un número de puerto. Si no has cambiado los puertos por defecto en la configuración de tu nodo, prueba con el puerto 8333 (Bitcoin) y/o 9735 (Lightning).

En <<ln_port_check>> puede ver el resultado de la comprobación del puerto 9735 en un servidor que ejecuta Lightning, utilizando la herramienta de escáner de puertos _whatismyip.com_. Muestra que el servidor está aceptando conexiones entrantes al puerto de Lightning. Si ves un resultado como este, ¡estás listo!

[[ln_port_check]]
.Checking for incoming port 9735
image::images/mtln_0503.png[]

===== Reenvío automático de puertos mediante UPnP.

A veces, incluso si su router de Internet soporta UPnP, puede estar desactivado por defecto. En ese caso, debe cambiar la configuración de su router de Internet desde su interfaz de administración web:

. Conéctese al sitio web de configuración de su router de Internet. Normalmente, esto puede hacerse conectándose a la _dirección de la puerta de enlace_ de su red doméstica mediante un navegador web. Puedes encontrar la dirección de la puerta de enlace mirando la configuración IP de cualquier ordenador de tu red doméstica. Suele ser la primera dirección de una de las redes no enrutables, como 192.168.0.1 o 10.0.0.1. Comprueba también todas las pegatinas de tu router en busca de la _dirección de puerta de enlace_. Una vez encontrada, abra un navegador e introduzca la dirección IP en el cuadro de URL/búsqueda del navegador, por ejemplo, "192.168.0.1" o "http://192.168.0.1".

. Busque el nombre de usuario y la contraseña del administrador para el panel de configuración web del router. Esto suele estar escrito en una pegatina en el propio router y puede ser tan simple como "admin" y "password". Una rápida búsqueda en la web para su ISP y el modelo de router también puede ayudarle a encontrar esta información.

. Encuentre un ajuste para UPnP y actívelo.

Reinicie su nodo Bitcoin y/o Lightning y repita la prueba de puerto abierto con uno de los sitios web que utilizamos en la sección anterior.

===== Usando Tor para las conexiones entrantes.

El Onion Router_ (_Tor_) es una VPN con la propiedad especial de que encripta las comunicaciones entre saltos, de forma que ningún nodo intermediario puede determinar el origen o destino de un paquete. Tanto los nodos de Bitcoin como los de Lightning soportan la operación sobre Tor, lo que permite operar un nodo sin revelar su dirección IP o su ubicación. Por lo tanto, proporciona un alto nivel de privacidad a su tráfico de red. Una ventaja añadida de ejecutar Tor es que, al funcionar como una VPN, resuelve el problema del reenvío de puertos de su router de Internet. Las conexiones entrantes se reciben a través del túnel de Tor, y su nodo puede ser encontrado a través de una _dirección de ionización_ generada ad hoc en lugar de una dirección IP.

Activar Tor requiere dos pasos. Primero, debe instalar el router Tor y el proxy en su ordenador. Segundo, debe habilitar el uso del proxy Tor en su configuración de Bitcoin o Lightning.

Para instalar Tor en un sistema Linux Ubuntu que utilice el gestor de paquetes +apt+, ejecute

----
sudo apt install tor
----

A continuación, configuramos nuestro nodo Lightning para que utilice Tor para su conectividad externa. Aquí hay un ejemplo de configuración para LND:

----
[Tor]
tor.active=true
tor.v3=true
tor.streamisolation=true
listen=localhost
----

Esto habilitará Tor (+tor.active+), establecerá un servicio de cebolla v3 (+tor.v3=true+), utilizará un flujo de cebolla diferente para cada conexión (+tor.streamisolation+), y restringirá la escucha de conexiones sólo al host local, para evitar la filtración de su dirección IP (listen=localhost).

Puede comprobar si Tor está correctamente instalado y funcionando ejecutando un simple comando de una línea. Este comando debería funcionar en la mayoría de los sabores de Linux:

----
curl --socks5 localhost:9050 --socks5-hostname localhost:9050 -s https://check.torproject.org/ | cat | grep -m 1 Congratulations | xargs
----

Si todo funciona correctamente, la respuesta de este comando debería ser +"Enhorabuena. Este navegador está configurado para usar Tor".

Debido a la naturaleza de Tor, no puede utilizar fácilmente un servicio externo para comprobar si su nodo es accesible a través de una dirección cebolla. Sin embargo, debería ver su dirección cebolla Tor en los registros de su nodo Lightning. Es una larga cadena de letras y números seguida del sufijo +.onion+. Su nodo debería ser ahora accesible desde Internet, ¡con la ventaja añadida de la privacidad!

===== Reenvío manual de puertos.

Este es el proceso más complejo y requiere un poco de habilidad técnica. Los detalles dependen del tipo de router de internet que tengas, la configuración y las políticas de tu proveedor de servicios, y un montón de otros contextos. Pruebe UPnP o Tor primero, antes de intentar este mecanismo mucho más difícil. 

Los pasos básicos son los siguientes:

. Encuentre la dirección IP del ordenador en el que se encuentra su nodo. Suele ser asignada dinámicamente por el protocolo de configuración dinámica de host (DHCP) y suele estar en algún lugar del rango 192.168.x.x o 10.x.x.

. Busca la dirección de control de acceso al medio (MAC) de la interfaz de red de tu nodo. Puede encontrarla en la configuración de Internet de ese ordenador.

. Asigna una dirección IP estática a tu nodo para que sea siempre la misma. Puedes utilizar la dirección IP que tiene actualmente. En su router de Internet, busque "Arrendamientos estáticos" bajo la configuración DHCP. Asigna la dirección MAC a la dirección IP que has seleccionado. Ahora tu nodo siempre tendrá esa dirección IP asignada. Alternativamente, puedes mirar la configuración DHCP de tu router y averiguar cuál es su rango de direcciones DHCP. Selecciona una dirección no utilizada _fuera_ del rango de direcciones DHCP. A continuación, en el servidor, configure la red para dejar de usar DHCP y codifique la dirección IP no DHCP seleccionada en la configuración de red del sistema operativo.

. Por último, configure el "Port Forwarding" en su router de Internet para dirigir el tráfico entrante en puertos específicos a la dirección IP seleccionada de su servidor.

Una vez que haya terminado de reconfigurar, repita la comprobación de puertos utilizando uno de los sitios web de las secciones anteriores

=== Seguridad de su nodo.

Un nodo Lightning es, por definición, una _cartera caliente_. Eso significa que los fondos (tanto dentro como fuera de la cadena) controlados por un nodo Lightning están directamente controlados por claves que se cargan en la memoria del nodo o se almacenan en el disco duro del nodo. Si un nodo Lightning se ve comprometido, es trivial crear transacciones dentro o fuera de la cadena para drenar sus fondos. Por lo tanto, es muy importante que lo protejas del acceso no autorizado.

La seguridad es un esfuerzo holístico, lo que significa que hay que asegurar cada capa de un sistema. Como dice el refrán: la cadena es tan fuerte como el eslabón más débil. Este es un concepto importante en la seguridad de la información, y lo aplicaremos a nuestro nodo.

A pesar de todas las medidas de seguridad que tomará, recuerde que la Lightning Network es una tecnología experimental en fase inicial y es probable que haya fallos explotables en el código de cualquier proyecto que utilice. No pongas más dinero del que estés dispuesto a perder en la Lightning Network.


==== Seguridad del sistema operativo.

La seguridad de un sistema operativo es un tema muy amplio que va más allá del alcance de este libro. Sin embargo, podemos establecer algunos principios básicos.

Para asegurar tu sistema operativo, estos son algunos de los principales elementos a tener en cuenta: 

Procedencia:: Empieza por asegurarte de que estás descargando la imagen correcta del sistema operativo, y verifica las firmas o sumas de comprobación antes de instalarlo. Extiende esto a cualquier software que instales. Comprueba dos veces cualquier fuente o URL desde la que realices la descarga. Comprueba la integridad y la corrección del software descargado mediante la verificación de la firma y la suma de comprobación.
Mantenimiento:: Asegúrese de mantener su sistema operativo actualizado. Activa la instalación automática diaria o semanal de las actualizaciones de seguridad.
Mínimos privilegios: establezca usuarios para procesos específicos y déles el mínimo acceso necesario para ejecutar un servicio. No ejecute procesos con privilegios de administrador (por ejemplo, +root+).
Aislamiento de procesos:: Utilice las funciones del sistema operativo para aislar los procesos entre sí.
Permisos del sistema de archivos:: Configura el sistema de archivos con cuidado, siguiendo el principio de mínimos privilegios. No hagas que los archivos puedan ser leídos o escritos por todo el mundo.
Autenticación fuerte:: Utilice contraseñas fuertes generadas aleatoriamente o, siempre que sea posible, autenticación de clave pública. Por ejemplo, es más seguro utilizar Secure Shell (SSH) con un par de claves criptográficas en lugar de una contraseña.
Autenticación de dos factores (2FA):: Utiliza la autenticación de dos factores siempre que sea posible, incluido el segundo factor universal (U2F) con llaves de seguridad de hardware. Esto se aplica a todos los servicios externos que puedas utilizar, como tu proveedor de servicios en la nube. También puedes aplicarlo a tu propia configuración, como tu propia configuración de SSH. Utiliza 2FA también para los servicios indirectos. Por ejemplo, digamos que utilizas un servicio en la nube. Le diste a tu proveedor de servicios en la nube una dirección de correo electrónico, así que también deberías proteger tu dirección de correo electrónico con 2FA.
Copia de seguridad:: Haz copias de seguridad de tu sistema, y asegúrate de proteger las copias de seguridad también con encriptación. Realiza estas copias de seguridad periódicamente. Al menos una vez, comprueba que puedes restaurar tu copia de seguridad y que ésta es completa y accesible. Si es posible, mantén una copia de tus copias de seguridad en un disco diferente para evitar que un solo fallo del disco duro destruya _tanto_ tu nodo activo como tus copias de seguridad.
Gestión de la vulnerabilidad y la exposición:: Utilice el escaneo remoto para asegurarse de que ha minimizado la superficie de ataque de su sistema. Cierre los servicios o puertos innecesarios. Instale sólo el software y los paquetes que realmente necesite y utilice. Desinstale los paquetes que ya no utilice. Se recomienda que _no_ utilice su ordenador de nodo para actividades que no sean de nodo y que pueda realizar en otro de sus ordenadores. Especialmente, si puedes, no utilices tu ordenador de nodo para navegar por Internet o leer tu correo electrónico.

Esta es una lista de las medidas de seguridad más básicas. No es en absoluto exhaustiva.

==== Acceso al nodo.

Su nodo Lightning expondrá una API de llamada a procedimiento remoto (RPC). Esto significa que su nodo puede ser controlado de forma remota mediante comandos enviados a un puerto TCP específico. El control de acceso a esa API RPC se consigue mediante alguna forma de autenticación de usuario. Dependiendo del tipo de nodo Lightning que configure, esto se hará mediante autenticación de nombre de usuario/contraseña o mediante un mecanismo llamado _macaroon_ de autenticación. Como su nombre indica, un macarrón es un tipo de cookie más sofisticado. A diferencia de una cookie, está firmada criptográficamente y puede expresar un conjunto de capacidades de acceso.

Por ejemplo, LND utiliza macarrones para conceder acceso a la API RPC. Por defecto, el software de LND crea tres macarrones con diferentes niveles de acceso, denominados +admin+, +invoice+ y +sólo lectura+. Dependiendo del macaroon que copie y utilice en su cliente RPC, tendrá acceso de _sólo lectura_, acceso de _factura_ (que incluye las capacidades de sólo lectura), o acceso de _admin_, que le da el control total. También hay una función +bakery+ de macarrones en LND que puede construir macarrones con cualquier combinación de capacidades con un control muy fino.

Si utiliza un modelo de autenticación de nombre de usuario/contraseña, asegúrese de seleccionar una contraseña larga y aleatoria. No tendrás que escribir esta contraseña a menudo, porque se almacenará en los archivos de configuración. Por lo tanto, debes elegir una que no pueda ser adivinada. Muchos de los ejemplos que verás incluyen contraseñas mal elegidas, y a menudo la gente las copia en sus propios sistemas, facilitando el acceso a cualquiera. No lo hagas. Utiliza un gestor de contraseñas para generar una contraseña alfanumérica larga y aleatoria. Dado que algunos caracteres especiales como +$?/!*\%`"'+ pueden interferir con la línea de comandos, es mejor evitarlos para las contraseñas que se utilizarán en un entorno de shell. Para evitar problemas, utilice contraseñas alfanuméricas largas y aleatorias.

Una secuencia alfanumérica simple de más de 12 caracteres y generada aleatoriamente suele ser suficiente. Si planea almacenar grandes cantidades de dinero en su nodo Lightning y le preocupan los ataques remotos de fuerza bruta, seleccione una longitud de contraseña de más de 20 caracteres para que dichos ataques sean prácticamente inviables. 

=== Copias de seguridad del nodo y del canal.

Una consideración muy importante cuando se ejecuta un nodo Lightning es el tema de las copias de seguridad. A diferencia de un monedero de Bitcoin, donde una frase mnemotécnica BIP-39 puede recuperar todo el estado del monedero, en Lightning este _no_ es el caso.

Los monederos de Lightning sí utilizan una copia de seguridad de la frase mnemónica BIP-39, pero sólo para el monedero de la cadena. Sin embargo, debido a la forma en que se construyen los canales, la frase mnemotécnica _no_ es suficiente para restaurar un nodo Lightning. Se necesita una capa adicional de copias de seguridad, que se denomina _copia de seguridad del canal estático_ (_SCB_). Sin un SCB, el operador de un nodo Lightning puede perder _todos_ los fondos que están en los canales si pierde el almacén de datos del nodo Lightning.

[WARNING]
====
No financie los canales hasta que haya puesto en marcha un sistema para hacer una copia de seguridad continua del estado de sus canales. Sus copias de seguridad deben ser trasladadas "fuera del sitio" a un sistema y ubicación diferentes de su nodo, para que puedan sobrevivir a una variedad de fallas del sistema (pérdida de energía, corrupción de datos, etc.) o desastres naturales (inundación, incendio, etc.).
====

Los SCB no son una panacea. En primer lugar, es necesario hacer una copia de seguridad del estado de cada canal cada vez que hay una nueva commitment transaction. En segundo lugar, restaurar a partir de una copia de seguridad de un canal es peligroso. Si no tienes la _última_ commitment transaction y accidentalmente emites un compromiso antiguo (revocado), tu compañero de canal asumirá que estás tratando de hacer trampa y reclamará todo el balance del canal con una transacción de penalización. Para asegurarte de que estás cerrando el canal, necesitas hacer un _cierre cooperativo_. Pero un peer malicioso podría engañar a tu nodo para que emita un compromiso antiguo y revocado durante ese cierre cooperativo, y así engañarte haciendo que tu nodo intente hacer trampa inadvertidamente.

Además, las copias de seguridad de tus canales deben estar encriptadas para mantener tu privacidad y la seguridad de tu canal. De lo contrario, cualquiera que encuentre las copias de seguridad no sólo puede ver todos tus canales, sino que también podría utilizar las copias de seguridad para cerrar todos tus canales de forma que entregue el balance a tus compañeros de canal. En otras palabras, una persona maliciosa que tenga acceso a tus respaldos puede hacer que pierdas todos los fondos de tu canal.

Puedes ver que los SCBs no son una salvaguarda infalible. Son un compromiso débil porque cambian un tipo de riesgo (corrupción o pérdida de datos) por otro tipo de riesgo (persona maliciosa). Para restaurar desde un SCB, tienes que interactuar con tus compañeros de canal y esperar que no intenten engañarte dándote un compromiso antiguo o engañando a tu nodo para que emita un compromiso revocado y así poder penalizarte. A pesar de las debilidades del SCB, los SCBs tienen sentido y deberías realizarlos. Si no realizas SCBs y pierdes los datos de tu nodo, perderás los fondos de tu canal para siempre. Garantizado. Sin embargo, si _realizas SCBs y pierdes los datos de tu nodo, entonces tienes una posibilidad razonable de que algunos de tus compañeros sean honestos y puedas recuperar algunos de tus fondos del canal. Si tienes suerte, puedes recuperar todos tus fondos. En conclusión, es mejor que realices SCBs continuos a un disco que no sea el disco duro del nodo primario.

Los mecanismos de copia de seguridad del canal son todavía un trabajo en progreso y una debilidad en la mayoría de las implementaciones de Lightning.

En el momento de escribir este libro, sólo LND ofrece un mecanismo incorporado para las SCB. Eclair tiene un mecanismo similar desplegado para las implementaciones del lado del servidor, aunque Eclair Mobile ofrece una copia de seguridad opcional en un Google Drive. `c-lightning` ha fusionado recientemente las interfaces necesarias para que un plug-in implemente las copias de seguridad de los canales. Desafortunadamente, no existe un mecanismo de copia de seguridad consistente y acordado entre las diferentes implementaciones de nodos.

Las copias de seguridad basadas en archivos de las bases de datos de los nodos de Lightning son, en el mejor de los casos, una solución parcial porque se corre el riesgo de hacer copias de seguridad de un estado de base de datos inconsistente. Además, es posible que no se recojan de forma fiable los últimos compromisos de estado. Es mucho mejor tener un mecanismo de copia de seguridad que se active cada vez que haya un cambio de estado en un canal, garantizando así la coherencia de los datos.

Para configurar los SCBs en LND, establezca el parámetro +backupfilepath+ en la línea de comandos o en el archivo de configuración. LND guardará entonces un archivo SCB en esa ruta de directorio. Por supuesto, esto es sólo el primer paso de la solución. Ahora, hay que establecer un mecanismo que supervise este archivo en busca de cambios. Cada vez que el archivo cambia, el mecanismo de copia de seguridad debe copiar este archivo a otro disco, preferiblemente fuera del sitio. Estos mecanismos de copia de seguridad están fuera del alcance de este libro. Sin embargo, cualquier solución de respaldo sofisticada debe ser capaz de manejar este escenario. Recuerda que los archivos de respaldo también deben estar encriptados. 

==== Riesgo de billetera caliente.

Como hemos comentado anteriormente, la Lightning Network consiste en una red de _carteras calientes_. Los fondos que se almacenan en una billetera Lightning están en línea todo el tiempo. Esto los hace vulnerables. Por lo tanto, no debería almacenar grandes cantidades en una billetera Lightning. Las cantidades grandes deben guardarse en un monedero _frío_ que no esté en línea y que sólo pueda realizar transacciones en la cadena.

Incluso si empiezas con poco dinero, con el paso del tiempo puedes encontrar que tienes una cantidad significativa de dinero en una billetera Lightning. Este es un escenario típico para los propietarios de tiendas. Si utiliza un nodo Lightning para una operación de comercio electrónico, es probable que su monedero reciba fondos con frecuencia, pero que envíe fondos raramente. Por lo tanto, acabará teniendo dos problemas simultáneos. En primer lugar, sus canales estarán desequilibrados, con grandes saldos locales que superan a los pequeños saldos remotos. En segundo lugar, tendrá demasiado dinero en el monedero. Afortunadamente, también puede resolver ambos problemas simultáneamente.

Veamos algunas de las soluciones que puede utilizar para reducir los fondos expuestos en un monedero caliente.

==== Barrido de fondos.

Si el balance de su monedero Lightning es demasiado grande para su tolerancia al riesgo, tendrá que "barrer" los fondos del monedero. Puede hacerlo de tres maneras: dentro de la cadena, fuera de la cadena y con el Loop Out. Veamos cada una de estas opciones en las siguientes secciones. 

===== Barrido en la cadena.

El barrido de fondos en la cadena se realiza moviendo los fondos de la billetera Lightning a una billetera Bitcoin. Esto se hace cerrando canales. Cuando cierras un canal, todos los fondos de tu balance local son "barridos" a una dirección Bitcoin. La dirección de Bitcoin para los fondos en la cadena suele ser generada por su monedero Lightning, por lo que sigue siendo un monedero caliente. Es posible que tenga que hacer una transacción adicional en la cadena para mover los fondos a una dirección más segura, como una generada en su hardware wallet.

El cierre de los canales conllevará una tarifa en la cadena y reducirá la capacidad y la conectividad de su nodo Lightning. Sin embargo, si diriges un nodo de comercio electrónico popular, no te faltará capacidad de entrada y puedes cerrar estratégicamente los canales con grandes saldos locales, esencialmente "agrupando" tus fondos para el movimiento en la cadena. Es posible que tenga que utilizar algunas técnicas de reequilibrio de canales (ver <<channel_rebalancing>>) antes de cerrar canales para maximizar los beneficios de esta estrategia.

===== Barrido fuera de la cadena.

Otra técnica que puede utilizar consiste en ejecutar un segundo nodo de rayos que no se anuncia en la red. Puedes establecer canales de gran capacidad desde tu nodo público (por ejemplo, el que gestiona tu tienda) hasta tu nodo no anunciado (oculto). De forma regular, "barre" los fondos haciendo un pago relámpago a tu nodo oculto.

La ventaja de esta técnica radica en que el nodo Lightning que recibe los pagos de tu tienda será conocido públicamente. Esto lo convierte en un objetivo para los hackers, ya que se supone que cualquier nodo Lightning asociado a una tienda tiene un gran balance. Un segundo nodo que no esté asociado a su tienda no será fácilmente identificado como un objetivo valioso.

Como medida adicional de seguridad, puede hacer que su segundo nodo sea un servicio Tor oculto para que no se conozca su dirección IP. Eso reduce aún más la oportunidad de ataques y aumenta su privacidad.

Necesitará configurar un script que se ejecute a intervalos regulares. El propósito de este script es crear una invoice en su nodo oculto y pagar esa invoice desde el nodo de su tienda, trasladando así los fondos a su nodo oculto.

Ten en cuenta que esta técnica no mueve los fondos al cold storage. Ambos nodos Lightning son billeteras calientes. El objetivo de este barrido es mover fondos de un monedero caliente muy conocido a un monedero caliente oculto.

===== Barrido de intercambio submarino.

Otra forma de reducir el balance de tu monedero caliente Lightning es utilizar una técnica llamada _submarine swap_. Los swaps submarinos, conceptualizados por el coautor Olaoluwa Osuntokun y Alex Bosworth, permiten el intercambio de bitcoin en la cadena por pagos de Lightning y viceversa. Esencialmente, los swaps submarinos son intercambios atómicos entre fondos de Lightning fuera de la cadena y fondos de Bitcoin en la cadena.

Un operador de nodo puede iniciar un swap submarino y enviar todos los saldos disponibles del canal a la otra parte, que les enviará bitcoin en la cadena a cambio.

En el futuro, este podría ser un servicio de pago ofrecido por los nodos de la Lightning Network, que anuncian los tipos de cambio o cobran una tarifa plana por la conversión.

La ventaja de un intercambio submarino para barrer fondos es que no es necesario cerrar ningún canal. Esto significa que conservamos nuestros canales, sólo reequilibrando nuestros canales a través de esta operación. Al enviar un pago relámpago, trasladamos parte del balance de local a remoto en uno o varios de nuestros canales. Eso no sólo reduce el balance expuesto en la billetera caliente de nuestro nodo, sino que también aumenta el balance disponible para futuros pagos entrantes. 

Podrías hacerlo confiando en un intermediario que actuara como puerta de entrada, pero esto supone el riesgo de que te roben tus monedas. Sin embargo, en el caso de un swap submarino, la operación no requiere confianza. Los swaps submarinos son operaciones _atómicas_ no custodiadas. Esto significa que la contraparte de tu swap submarino no puede robar tus fondos porque el pago dentro de la cadena depende de la realización del pago fuera de la cadena y viceversa.

===== Swaps submarinos con Loop.

Un ejemplo de servicio de swap submarino es _Loop_ de Lightning Labs, la misma empresa que construye LND. Loop viene en dos variaciones: Loop In y Loop Out. _Loop In_ acepta un pago de Bitcoin en la cadena y lo convierte en un pago de Lightning fuera de la cadena. _Loop Out_ convierte un pago de Lightning en un pago de Bitcoin.

[NOTE]
====
Para utilizar el servicio Loop, debe ejecutar un nodo LND Lightning.
====

Para reducir el balance de su monedero caliente Lightning, utilizaría el servicio Loop Out. Para utilizar el servicio Loop, debe instalar un software adicional en su nodo. El software Loop se ejecuta junto a su nodo LND y proporciona algunas herramientas de línea de comandos para ejecutar swaps submarinos. Puede encontrar el software Loop y las instrucciones de instalación en https://github.com/lightninglabs/loop[GitHub].

Una vez que tenga el software instalado y en funcionamiento, una operación de Loop Out es tan sencilla como ejecutar un único comando:

----
loop out --amt 501000 --conf_target 400
Max swap fees for 501000 sat Loop Out: 25716 sat
Regular swap speed requested, it might take up to 30m0s for the swap to be executed.
CONTINUE SWAP? (y/n), expand fee detail (x): x

Estimated on-chain sweep fee:        149 sat
Max on-chain sweep fee:              14900 sat
Max off-chain swap routing fee:      10030 sat
Max no show penalty (prepay):        1337 sat
Max off-chain prepay routing fee:    36 sat
Max swap fee:                        750 sat
CONTINUE SWAP? (y/n): y
Swap initiated

Run `loop monitor` to monitor progress.
----

Tenga en cuenta que su tarifa máxima, que representa el peor de los casos, dependerá del objetivo de confirmación que seleccione

=== Tiempo de actividad y disponibilidad del nodo Lightning.

A diferencia de Bitcoin, los nodos Lightning necesitan estar en línea casi continuamente. Su nodo necesita estar en línea para recibir pagos, abrir canales, cerrar canales (de forma cooperativa) y supervisar las violaciones del protocolo. La disponibilidad de los nodos es un requisito tan importante en la Lightning Network que es una métrica utilizada por varias herramientas de gestión automática de canales (por ejemplo, +autopilot+) para decidir con qué nodos abrir canales. También puede ver la "disponibilidad" como métrica de los nodos en exploradores de nodos populares (véase <<ln_explorer>>) como https://1ml.com[1ML].

La disponibilidad de los nodos es especialmente importante para mitigar y resolver posibles violaciones del protocolo (es decir, compromisos revocados). Aunque puede permitirse interrupciones cortas de una hora hasta uno o dos días, no puede tener su nodo fuera de línea durante periodos más largos sin arriesgarse a perder fondos.

Mantener un nodo en línea de forma continuada no es fácil, ya que diversos fallos y limitaciones de recursos pueden causar y causarán ocasionalmente tiempos de inactividad. Especialmente si ejecuta un nodo ocupado y popular, se encontrará con limitaciones de memoria, espacio de intercambio, número de archivos abiertos, espacio en disco, etc. Toda una serie de problemas diferentes causarán la caída de tu nodo o de tu servidor.

==== Tolerar los fallos y automatizar.

Si tiene tiempo y conocimientos, debería probar algunos escenarios de fallos básicos en la red de pruebas de Lightning. En la red de pruebas aprenderá valiosas lecciones sin arriesgar ningún fondo. Cualquier paso que realice para automatizar su sistema mejorará su disponibilidad:

Reinicio automático del servidor informático:: ¿Qué ocurre cuando su servidor o el sistema operativo se estropean? ¿Qué sucede cuando hay un corte de energía? Simule este fallo pulsando el botón de "reset" de su PC o desenchufando el cable de alimentación. Después de un fallo, un reinicio o un corte de energía, el ordenador debería reiniciarse automáticamente. Algunos ordenadores tienen una configuración en su BIOS para especificar cómo debe reaccionar el ordenador ante los fallos de alimentación. Pruébalo para asegurarte de que el ordenador realmente se reinicia automáticamente en caso de fallo de alimentación sin intervención humana.

Reinicio automático del nodo:: ¿Qué ocurre cuando tu nodo o uno de tus nodos se estropea? Simule este fallo matando los procesos del nodo correspondiente. Si un nodo se bloquea, debería reiniciarse automáticamente. Pruébalo para asegurarte de que el nodo o los nodos realmente se reinician automáticamente en caso de fallo sin intervención humana. Si no es así, lo más probable es que tu nodo no esté configurado correctamente como servicio del sistema operativo.

Reconexión automática de la red:: ¿Qué sucede si su red se cae? ¿Qué sucede cuando su ISP se cae temporalmente? ¿Qué ocurre cuando tu ISP asigna una nueva dirección IP a tu router o a tu ordenador? Cuando la red vuelve, ¿los nodos que estás ejecutando se reconectan automáticamente a la red? Simule este fallo desenchufando y volviendo a enchufar el cable Ethernet del dispositivo que aloja sus nodos. Los nodos deberían reconectarse automáticamente y seguir funcionando sin intervención humana.

Configure sus archivos de registro:: Todos los fallos anteriores deberían dejar entradas textuales en los archivos de registro correspondientes. Aumente la verbosidad del registro si es necesario. Encuentre estas entradas de error en los archivos de registro y utilícelas para la supervisión. 

==== Supervisión de la disponibilidad del nodo.

La supervisión de su nodo es una parte importante para mantenerlo en funcionamiento. Debe supervisar no sólo la disponibilidad del propio ordenador, sino también la disponibilidad y el correcto funcionamiento del software del nodo Lightning.

Hay varias formas de hacerlo, pero la mayoría requieren cierta personalización. Se pueden utilizar herramientas genéricas de monitorización de la infraestructura o de las aplicaciones, pero hay que personalizarlas específicamente para que consulten la API del nodo Lightning y se aseguren de que el nodo está en funcionamiento, sincronizado con la blockchain y conectado a los pares del canal.

https://lightning.watch[Lightning.watch] proporciona un servicio especializado que ofrece monitorización de nodos Lightning. Utiliza un bot de Telegram para notificar cualquier interrupción del servicio. Es un servicio gratuito, aunque se puede pagar (a través de Lightning, por supuesto) para obtener alertas más rápidas.

Con el tiempo, esperamos que haya más servicios de terceros que ofrezcan una monitorización especializada de los nodos Lightning que se pague mediante micropagos. Tal vez estos servicios y sus API se estandaricen y algún día sean soportados directamente por el software del nodo Lightning.

[[watchtowers]]
==== Atalayas.

Las [[torres de vigilancia]] son un mecanismo para externalizar la supervisión y la resolución de sanciones de las violaciones del protocolo Lightning.

Como hemos mencionado en capítulos anteriores, el protocolo Lightning mantiene la seguridad mediante un mecanismo de penalización. Si uno de sus socios de canal emite una commitment transaction antigua, su nodo tendrá que ejercer la cláusula de revocación y emitir una transacción de penalización para evitar perder dinero. Pero si su nodo está caído durante la violación del protocolo, podría perder dinero.

Para resolver este problema, podemos utilizar una o más torres de vigilancia para externalizar el trabajo de monitorizar las violaciones del protocolo y emitir transacciones de penalización. Hay dos partes en la configuración de una watchtower: un servidor de watchtower (o simplemente watchtower) que monitoriza la blockchain y un cliente de watchtower que pide al servidor de watchtower este servicio de monitorización.

La tecnología de las torres de vigilancia está todavía en las primeras etapas de desarrollo y no está ampliamente apoyada. Sin embargo, en el siguiente pasaje enumeramos algunas implementaciones experimentales que puede probar.

El software LND incluye un servidor de torres de vigilancia y un cliente de torres de vigilancia. Puede activar el servidor de la torre de vigilancia añadiendo las siguientes opciones de configuración:

[source, subs="quotes"]
----
[watchtower]
watchtower.active=1
watchtower.towerdir=_/path_to_watchtower_data_directory_
----

Puede utilizar el cliente watchtower de LND activándolo en la configuración y utilizando la línea de comandos para conectarlo a un servidor watchtower. La configuración es:

----
[wtclient]
wtclient.active=1
----

El cliente de línea de comandos de LND +lncli+ muestra las siguientes opciones para gestionar el cliente de la torre de vigilancia:

----
$ lncli wtclient

NAME:
   lncli wtclient - Interact with the watchtower client.

USAGE:
   lncli wtclient command [command options] [arguments...]

COMMANDS:
     add     Register a watchtower to use for future sessions/backups.
     remove  Remove a watchtower to prevent its use for future sessions/backups.
     towers  Display information about all registered watchtowers.
     tower   Display information about a specific registered watchtower.
     stats   Display the session stats of the watchtower client.
     policy  Display the active watchtower client policy configuration.

OPTIONS:
   --help, -h  show help
----

`c-lightning` tiene los ganchos de la API necesarios para un plug-in de cliente de torre de vigilancia, aunque todavía no se ha implementado dicho plug-in.

Por último, un popular servidor de torres de vigilancia independiente es _The Eye of Satoshi_ (TEOS). Se puede encontrar en https://github.com/talaia-labs/python-teos[GitHub].

=== Gestión de canales.

Como operador de un nodo Lightning, una de las tareas recurrentes que tendrás que realizar es la gestión de tus canales. Esto significa abrir canales de salida desde tu nodo a otros nodos, así como conseguir que otros nodos abran canales de entrada a tu nodo. En el futuro, la construcción de canales cooperativos puede ser posible, por lo que puede abrir canales simétricos que tienen fondos comprometidos en ambos extremos en la creación. Por ahora, sin embargo, los nuevos canales sólo tienen fondos en un extremo, en el lado del emisor. Por lo tanto, para que tu nodo esté _equilibrado_ con capacidad de entrada y salida, tienes que abrir canales a otros y atraer a otros para que abran canales a tu nodo. 

==== Apertura de canales de salida.

En cuanto tenga su nodo Lightning en funcionamiento, puede financiar su billetera Bitcoin y empezar a abrir canales con esos fondos.

Debe elegir los socios de canal con cuidado porque la capacidad de su nodo para enviar pagos depende de quiénes sean sus socios de canal y de lo bien conectados que estén con el resto de la Lightning Network. También conviene tener más de un canal para evitar ser susceptible de un único punto de fallo. Dado que Lightning admite ahora los pagos en varias partes, puede dividir sus fondos iniciales en varios canales y encauzar pagos más grandes combinando su capacidad. Al mismo tiempo, evite que sus canales sean demasiado pequeños. Dado que tiene que pagar las tasas de transacción de Bitcoin para abrir y cerrar un canal, el balance del canal no debe ser tan pequeño que las tasas de la cadena consuman una parte significativa. Todo es cuestión de equilibrio.

Para resumir:

* Conéctese a unos pocos nodos bien conectados
* Abre más de un canal
* No abrir demasiados canales
* No hagas los canales demasiado pequeños

Una forma de encontrar nodos bien conectados es abrir un canal a un comerciante popular que venda productos en la Lightning Network. Estos nodos tienden a estar bien financiados y bien conectados. Así, cuando estés listo para comprar algo en línea a través de Lightning, puedes abrir un canal directamente al nodo del comerciante. El ID del nodo del comerciante estará en la invoice que recibirás cuando intentes comprar algo. Así es más fácil.

Otra forma de encontrar nodos bien conectados es utilizar un explorador de Lightning (véase <<ln_explorer>>) como https://1ml.com[1ML] y navegar por la lista de nodos ordenados por capacidad de canal y número de canales. No vayas a por los nodos más grandes, porque eso fomenta la centralización. Ve a por un nodo de la mitad de la lista para que puedas ayudarles a crecer. Otro factor a tener en cuenta puede ser el tiempo que lleva un nodo en funcionamiento. Los nodos establecidos desde hace más de un año son probablemente más reputados y menos arriesgados que los nodos que empezaron a funcionar hace una semana.

[[autopilot]]
===== Piloto automático.

La tarea de abrir canales puede ser parcialmente automatizada con el uso de un _autopiloto_, que es un software que abre canales automáticamente basado en algunas reglas heurísticas. El software de autopilot es todavía relativamente nuevo, y no siempre selecciona los mejores socios de canal para usted. Especialmente al principio, puede ser mejor abrir los canales manualmente.
Los pilotos automáticos existen actualmente en tres formas:

- +lnd+ incorpora un autopilot que está totalmente integrado con +lnd+ y se ejecuta constantemente en segundo plano mientras está encendido.
- +lib_autopilot.py+ puede ofrecer cálculos de autopilot para cualquier implementación de nodo basada en el chisme y los datos del canal.
- Existe un complemento de +c-lightning+ basado en +lib_autopilot.py+ que proporciona una interfaz fácil de usar para los usuarios de +c-lightning+.

Tenga en cuenta que el autopilot de +lnd+ empezará a funcionar en segundo plano en cuanto se active a través del archivo de configuración. Como resultado, empezará a abrir canales inmediatamente si tienes salidas en cadena en tu billetera de +lnd+.
Si quieres tener un control total sobre las transacciones de bitcoin que haces y los canales que abres, asegúrate de desactivar el autopilot _antes_ de cargar tu billetera +lnd+ con fondos de bitcoin.
Si el autopilot estaba previamente activado, es posible que tengas que reiniciar tu +lnd+ antes de recargar tu billetera con una transacción en la cadena o antes de cerrar canales, lo que efectivamente te da fondos en la cadena de nuevo.
Es crucial que establezcas los valores de configuración clave si quieres ejecutar el autopilot.
Echa un vistazo a este ejemplo de configuración:


----
[lnd-autopilot]
autopilot.active=1
autopilot.maxchannels=40
autopilot.allocation=0.70
autopilot.minchansize=500000
autopilot.maxchansize=5000000
autopilot.heuristic=top_centrality:1.0
----

Este archivo de configuración activaría el autopilot.
Abriría los canales siempre que se cumplan las dos condiciones siguientes

1. Su nodo tiene actualmente menos de 40 canales abiertos.
2. 2. Menos del 70% de sus fondos totales están fuera de la cadena en canales de pago. 

Los números 40 y 0,7 se eligen aquí de forma totalmente arbitraria porque no podemos hacer ninguna recomendación válida para todo el mundo sobre cuántos canales debería tener abiertos y qué porcentaje de sus fondos debería estar fuera de la cadena.
El autopilot de +lnd+ no tendrá en cuenta las comisiones dentro de la cadena. En otras palabras, no retrasará la apertura de canales a un periodo de tiempo en el que las comisiones sean bajas.
Para reducir las comisiones, puede abrir manualmente los canales durante un periodo de tiempo en el que las comisiones sean bajas, por ejemplo, durante el fin de semana.
El autopilot hará recomendaciones de canales siempre que se cumplan las condiciones y tratará de abrir inmediatamente un canal utilizando las fees actuales adecuadas.
Según el archivo de configuración anterior, los canales tendrán un tamaño de entre 5 mBTC (`minchansize` = 500.000 satoshi) y 50 mBTC (`maxchansize` = 5.000.000 satoshi).
Como es habitual, las cantidades en el archivo de configuración se enumeran en satoshi.
Actualmente, los canales por debajo de 1 mBTC no son muy útiles, y no recomendamos que se abran canales demasiado pequeños y por debajo de esta cantidad.
Con la adopción más amplia de los pagos multiparte, los canales más pequeños serán menos molestos. Pero por el momento, esta es nuestra recomendación.

El complemento +c-lightning+, que fue escrito originalmente por René Pickhardt (coautor de este libro), funciona de forma muy diferente en comparación con el autopilot +lnd+.
En primer lugar, difiere en los algoritmos utilizados para hacer las recomendaciones. No vamos a tratar este tema aquí. En segundo lugar, difiere en su interfaz de usuario.
Deberá descargar el plug-in _autopiloto_ del plug-in +c-lightning+ https://github.com/lightningd/plugins/tree/master/autopilot[repositorio] y activarlo.

[NOTE]
====
Para activar un plug-in en +c-lightning+, colóquelo en el directorio _~/.lightning/plugins_, asegúrese de que es ejecutable (por ejemplo, `chmod +x ~/.lightning/plugins/autopilot.py`), y luego reinicie +lightningd+.

Como alternativa, si no desea que un complemento se active automáticamente al iniciar +lightningd+, puede colocarlo en un directorio diferente y activarlo manualmente con el argumento +plugin+ de +lightningd+:

----
   lightningd --plugin=~/lightning-plugins/autopilot.py
----

====

El autopilot de +c-lightning+ se controla mediante tres valores de configuración que pueden establecerse en el archivo de configuración o como argumentos de la línea de comandos al iniciar +lightningd+:

----
[c-lightning-autopilot]
autopilot-percent=75
autopilot-num-channels=10
autopilot-min-channel-size-msat=100000000msat
----

Estos valores son la configuración real por defecto, y no es necesario establecerlos en absoluto.

El autopilot no se ejecutará automáticamente en segundo plano como en +lnd+.
En su lugar, tiene que iniciar una ejecución específicamente con `lightning-cli autopilot-run-once` si quiere que el autopilot abra los canales recomendados.
Pero si quiere que sólo le proporcione recomendaciones, de las cuales puede elegir los nodos a mano, puede añadir el argumento opcional `dryrun`.

Una diferencia clave entre los pilotos automáticos +lnd+ y +c-lightning+ es que el autopilot +c-lightning+ también hará una recomendación para el tamaño del canal.
Por ejemplo, si el autopilot recomienda abrir un canal con un nodo pequeño que sólo tiene canales pequeños, no recomendará abrir un canal grande.
Sin embargo, si abre un canal con un nodo bien conectado que también tiene muchos canales grandes, probablemente recomendará un tamaño de canal mayor.

Como puede ver, el autopilot de +c-lightning+ no es tan automático como el de +lnd+, pero le da un poco más de control.
Estas diferencias reflejan las preferencias personales y, de hecho, podrían ser el factor decisivo para que elijas una implementación sobre la otra.

Ten en cuenta que los pilotos automáticos actuales utilizan principalmente la información pública del gossip protocol sobre la topología actual de la Lightning Network.
Es obvio que tus necesidades personales en cuanto a canales sólo pueden reflejarse hasta cierto punto.
Los pilotos automáticos más avanzados utilizarían la información histórica y de uso que su nodo ha reunido al funcionar en el pasado, incluida la información sobre los éxitos de enrutamiento, a quién ha pagado en el pasado y quién le ha pagado.
En el futuro, estos pilotos automáticos mejorados también podrían utilizar estos datos recopilados para hacer recomendaciones sobre el cierre de canales y la reasignación de fondos.

En general, en el momento de escribir este libro, hay que tener cuidado de no depender o confiar demasiado en los pilotos automáticos
 

==== Obtener liquidez de entrada.

En el diseño actual de la Lightning Network, es más típico que los usuarios obtengan liquidez de salida _antes_ de obtener liquidez de entrada.
Lo harán abriendo un canal con otro nodo, y lo más frecuente es que puedan gastar bitcoin antes de recibirlo.
Hay tres formas típicas de obtener liquidez entrante:

* Abrir un canal con liquidez saliente y luego gastar parte de esos fondos. Ahora el balance está en el otro extremo del canal, lo que significa que puedes recibir pagos.

* Pide a alguien que abra un canal hacia tu nodo. Ofrézcase a corresponder, para que ambos nodos estén mejor conectados y equilibrados.

* Utiliza un swap submarino (por ejemplo, Loop In) para intercambiar BTC en la cadena por un canal de entrada a tu nodo.

* Pagar a un servicio de terceros para que abra un canal con usted. Existen varios servicios de este tipo. Algunos cobran una cuota por proporcionar liquidez, otros son gratuitos.

[role="pagebreak-before"]
Aquí hay una lista de proveedores de liquidez disponibles actualmente que abrirán un canal a su nodo por una tarifa:

* https://www.bitrefill.com/thor-lightning-network-channels[Servicio Thor de Bitrefill]

* https://lightningto.me[Lightning To Me]

* https://lnbig.com[LNBig]

* https://lightningconductor.net/channels[Lightning Conductor]

La creación de liquidez entrante es un reto tanto desde el punto de vista práctico como de la experiencia del usuario. La liquidez entrante no se produce de forma automática, por lo que hay que encontrar la forma de crearla para el nodo. Esta asimetría de los canales de pago tampoco es intuitiva. En la mayoría de los otros sistemas de pago, primero se paga (inbound) antes de pagar a otros (outbound).

El reto de crear liquidez de entrada es más notable si eres un comerciante o vendes tus servicios para los pagos de Lightning. En ese caso, tienes que estar atento para asegurarte de que tienes suficiente liquidez de entrada para poder seguir recibiendo pagos. ¿Qué pasa si hay una oleada de compradores en tu tienda, pero no pueden pagarte realmente porque no hay más capacidad de entrada?

En el futuro, estos retos pueden mitigarse parcialmente con la implantación de canales de doble financiación, que se financian desde ambos lados y ofrecen una capacidad de entrada y salida equilibrada. La carga también podría mitigarse con un software de autopilot más sofisticado, que podría solicitar y pagar la capacidad de entrada según sea necesario.

En última instancia, los usuarios de Lightning deben ser estratégicos y proactivos en cuanto a la gestión de canales para garantizar que haya suficiente capacidad de entrada para satisfacer sus necesidades.

==== Cierre de canales.

Sin embargo, hay casos en los que es necesario un _cierre forzoso_.

Algunos ejemplos:

* Su socio de canal está fuera de línea y no puede ser contactado para iniciar un cierre mutuo.
* Su socio de canal está en línea, pero no responde a las solicitudes para iniciar un cierre mutuo.
* Su socio de canal está en línea y sus nodos están negociando un cierre mutuo, pero se atascan y no pueden llegar a una resolución.

[[channel_rebalancing]]
==== Reequilibrio de canales.

Durante la realización de transacciones y el enrutamiento de pagos en Lightning, la combinación de capacidades de entrada y salida puede desequilibrarse.

Por ejemplo, si uno de sus socios de canal enruta frecuentemente los pagos a través de su nodo, agotará la capacidad de entrada en ese canal, mientras que también agotará la capacidad de salida en los canales de salida. Una vez que esto ocurra, ya no podrá enrutar los pagos a través de esa ruta.

Hay muchas formas de reequilibrar los canales, cada una con diferentes ventajas e inconvenientes. Una forma es utilizar un intercambio submarino (por ejemplo, Loop Out), como se ha descrito anteriormente en este capítulo. Otra forma de reequilibrar es simplemente esperar los pagos enrutados que fluyen en la dirección opuesta. Si su nodo está bien conectado, cuando una ruta específica se agota en una dirección, la misma ruta queda disponible en la dirección opuesta. Otros nodos pueden "descubrir" esa ruta en la dirección opuesta y empezar a utilizarla como parte de su ruta de pago, reequilibrando así los fondos de nuevo.

Una tercera forma de reequilibrar los canales es crear a propósito una _ruta circular_ que envíe un pago desde tu nodo de vuelta a tu nodo, a través de la Lightning Network. Enviando un pago por un canal con gran capacidad local y organizando la ruta para que vuelva a tu nodo por un canal con gran capacidad remota, ambos canales estarán más equilibrados. Un ejemplo de estrategia de reequilibrio de rutas circulares puede verse en <<circular_rebalancing>>.

[[circular_rebalancing]]
.Circular route rebalancing
image::images/mtln_0504.png[]

El reequilibrio circular está soportado por la mayoría de las implementaciones de nodos Lightning y puede realizarse en la línea de comandos o a través de una de las interfaces de gestión web como Ride The Lightning (ver <<rtl>>).

El reequilibrio de canales es un tema complejo que es objeto de investigación activa y que se trata con más detalle en <<channel_rebalancing>>. 

=== Comisiones de enrutamiento.

El funcionamiento de un nodo Lightning le permite ganar comisiones al enrutar los pagos a través de sus canales. Las comisiones de enrutamiento no suelen ser una fuente de ingresos significativa y se ven eclipsadas por el coste de funcionamiento del nodo. Por ejemplo, en un nodo relativamente activo que enruta una docena de pagos al día, las comisiones no ascienden a más de 2.000 satoshis.

Los nodos compiten por las tasas de enrutamiento fijando su tarifa deseada en cada canal. Las fees de enrutamiento se establecen mediante dos parámetros en cada canal: una _tarifa base_ fija que se cobra por cualquier pago y una _tarifa variable_ adicional que es proporcional al importe del pago.

Al enviar un pago por relámpago, un nodo seleccionará una ruta para minimizar las tasas, minimizar los saltos, o ambas cosas. Como resultado, de estas interacciones surge un mercado de fees de enrutamiento. En la actualidad, hay muchos nodos que cobran fees muy bajas o no cobran ninguna por el enrutamiento, lo que crea una presión a la baja en el mercado de fees de enrutamiento.

Si no hace ninguna elección, su nodo Lightning establecerá una tarifa base y una tasa de tarifa por defecto para cada nuevo canal. Los valores por defecto dependen de la implementación del nodo que utilice.
La tarifa base se establece en la unidad de _millisatoshi_ (milésimas de satoshi). La tasa proporcional se establece en la unidad de _millonésimas_ y se aplica al importe del pago.
La unidad de millonésimas suele abreviarse con _ppm_ (partes por millón).
Por ejemplo, una tasa base de 1.000 (milisatoshi) y una tasa de 1.000 ppm (millonésimas) daría como resultado los siguientes cargos para un pago de 100.000 satoshi:

[latexmath]
++++
\begin{equation}
\begin{aligned}
P &= 100,000 \text{ satoshi} \\
F_{base} &= 1,000 \text{ millisatoshi} = 1 \text{ satoshi} \\
F_{rate} &= 1,000 \text{ ppm} = 1,000/1,000,000 = 1/1,000 = \text{0.001} = 0.1\% \\
F_{total} &= F_{base} + ( P * F_{rate} ) \\
 \Rightarrow  F_{total} &= 1 \text{ satoshi} + ( 100,000/1,000 ) \text{ satoshi} \\
 \Rightarrow  F_{total} &= 1 \text{ satoshi} + 100 \text{ satoshi} = 101 \text{ satoshi} \\
\end{aligned}
\end{equation}
++++

En términos generales, usted puede tomar uno de los dos enfoques a las tasas de enrutamiento. Puede encauzar muchos pagos con comisiones bajas, compensando las comisiones bajas con un volumen elevado. O bien, puede optar por cobrar comisiones más altas. Si opta por establecer tasas más altas, su nodo será seleccionado sólo cuando no existan otras rutas más baratas. Por lo tanto, usted enrutará con menos frecuencia pero ganará más por cada enrutamiento exitoso.

Para la mayoría de los nodos, suele ser mejor utilizar los valores de las tasas de enrutamiento por defecto. De esta manera, su nodo compite en igualdad de condiciones con otros nodos que utilizan los valores por defecto.

También puedes utilizar la configuración de la tasa de enrutamiento para reequilibrar los canales. Si la mayoría de tus canales tienen las fees por defecto pero quieres reequilibrar un canal en particular, sólo tienes que reducir las fees de ese canal específico a cero o a fees muy bajas. Entonces siéntese y espere a que alguien dirija un pago a través de su ruta "barata" y reequilibre sus canales por usted como efecto secundario.

=== Gestión de nodos.

La gestión de su nodo Lightning en la línea de comandos no es obviamente fácil. Le ofrece toda la flexibilidad de la API del nodo y la posibilidad de escribir sus propios scripts personalizados para satisfacer sus necesidades personales. Pero si no quiere lidiar con la complejidad de la línea de comandos y sólo necesita algunas capacidades básicas de gestión del nodo, debería considerar la instalación de una interfaz de usuario basada en la web que facilite la gestión del nodo.

Hay varios proyectos que compiten entre sí y que ofrecen una gestión de nodos Lightning basada en la web. Algunos de los más populares se describen en la siguiente sección.

[[rtl]]
==== Ride The Lightning.

Ride The Lightning (RTL) es una interfaz gráfica de usuario web que ayuda a los usuarios a gestionar las operaciones de los nodos Lightning para las tres principales implementaciones de nodos Lightning (LND, `c-lightning` y Eclair). RTL es un proyecto de código abierto desarrollado por Shahana Farooqui y muchos otros colaboradores. Puedes encontrar el software de RTL en https://github.com/Ride-The-Lightning/RTL[GitHub].

<<rtl-web-interface>> muestra una captura de pantalla de ejemplo de la interfaz web de RTL, tal y como se ofrece en el repositorio del proyecto.

[[rtl-web-interface]]
.Example RTL web interface
image::images/mtln_0505.png[]

==== lndmon.

Lightning Labs, los creadores de LND, proporcionan una interfaz gráfica de usuario basada en la web llamada +lndmon+ para supervisar las distintas métricas de un nodo LND Lightning. +lndmon+ sólo funciona con nodos LND. Es una interfaz de sólo lectura para la monitorización y, como tal, no permite gestionar activamente el nodo. No puede abrir canales ni realizar pagos. Encuentra +lndmon+ en https://github.com/lightninglabs/lndmon[GitHub].

==== ThunderHub.

https://thunderhub.io[ThunderHub] es una interfaz gráfica de usuario basada en la web muy agradable, similar a la de RTL pero exclusiva de LND. Se puede utilizar para realizar pagos, reequilibrar canales y gestionar el nodo a través de una variedad de funciones. 

=== Conclusión.

A medida que mantengas tu nodo y ganes experiencia, aprenderás mucho sobre la Lightning Network. Ser un operador de nodo es una tarea desafiante pero gratificante. Dominar estas habilidades te permitirá contribuir al crecimiento y desarrollo de esta tecnología y de la propia Lightning Network. Además, obtendrá la capacidad de enviar y recibir pagos de Lightning con el mayor grado de control y facilidad. Desempeñarás un papel central en la infraestructura de la red y no serás un mero participante en los márgenes.

== Arquitectura de la Red Relámpago.

En la primera parte de este libro hemos introducido los principales conceptos de la Lightning Network y hemos trabajado con un ejemplo completo de enrutamiento de un pago y la configuración de las herramientas que podemos utilizar para explorar más a fondo. En la segunda parte del libro exploraremos la Lightning Network con mucho más detalle técnico, diseccionando cada uno de los bloques de construcción.

En esta sección describiremos los componentes de la Lightning Network con más detalle y proporcionaremos una perspectiva "general" para guiarle a través de los siguientes capítulos.

=== El conjunto de protocolos de la Red Relámpago.

La Red Relámpago está compuesta por una compleja colección de protocolos que se ejecutan sobre Internet. Podemos clasificar a grandes rasgos estos protocolos en cinco capas distintas que conforman una _pila de protocolos_, donde cada capa se basa en los protocolos de la capa inferior y los utiliza. Además, cada capa de protocolo abstrae las capas subyacentes y "oculta" parte de la complejidad.

El diagrama de arquitectura mostrado en <<lightning_network_protocol_suite>> proporciona una visión general de estas capas y de los protocolos que las componen. 

[[lightning_network_protocol_suite]]
.The Lightning Network protocol suite
image::images/mtln_0601.png[]

Las cinco capas de la Red Relámpago, de abajo hacia arriba, son:

Capa de conexión a la red: Contiene los protocolos que interactúan directamente con los protocolos centrales de Internet (TCP/IP), los protocolos superpuestos (Tor v2/v3) y los servicios de Internet (DNS). Esta capa también contiene los protocolos criptográficos de transporte que protegen los mensajes de Lightning.

Capa de mensajería:: Esta capa contiene los protocolos que los nodos utilizan para negociar las características, formatear los mensajes y codificar los campos de los mensajes.

Capa Peer-to-peer (P2P): Esta capa es la principal capa de protocolo para la comunicación entre los nodos Lightning y contiene todos los diferentes mensajes que se intercambian entre los nodos.

Capa de enrutamiento:: Esta capa contiene los protocolos utilizados para enrutar los pagos entre los nodos, de extremo a extremo y atómicamente. Esta capa contiene la funcionalidad principal de la Lightning Network: los pagos enrutados.

Capa de pago:: La capa más alta de la red, que presenta una interfaz de pago fiable para las aplicaciones.

=== Lightning en detalle.

A lo largo de los próximos 10 capítulos, diseccionaremos el conjunto de protocolos y examinaremos cada componente de la Lightning Network en detalle.

Hemos pasado bastante tiempo intentando decidir el mejor orden para presentar estos detalles. No es una elección fácil porque hay mucha interdependencia entre los distintos componentes: cuando empiezas a explicar uno, te das cuenta de que arrastra a bastantes de los otros componentes. En lugar de un enfoque de arriba a abajo o de abajo a arriba, acabamos eligiendo un camino más serpenteante que comienza con los bloques de construcción más fundamentales que son exclusivos de la Lightning Network: los canales de pago, y se mueve hacia fuera desde allí. Pero como ese camino no es obvio, utilizaremos el conjunto de protocolos Lightning que se muestra en <<lightning_network_protocol_suite>> como mapa. En cada capítulo se centrará en uno o más componentes relacionados, y los verá resaltados en el conjunto de protocolos. Algo así como un marcador de mapa que dice "¡Estás aquí!".

Esto es lo que vamos a cubrir: 

#canales_de_pago:: En este capítulo veremos cómo funcionan los canales de pago, con bastante más profundidad de la que vimos en las primeras partes del libro. Veremos la estructura y el Guión Bitcoin de las transacciones de financiación y compromiso, y el proceso utilizado por los nodos para negociar cada paso del protocolo.

#enrutamiento:: A continuación, reuniremos varios canales de pago en una red y enrutaremos un pago de un extremo a otro. En ese proceso nos adentraremos en el contrato inteligente hash time-locked contract (HTLC) y en el Bitcoin Script que utilizamos para construirlo.

#operación_de_canal:: Uniendo los conceptos de un payment channel simple y un pago enrutado usando HTLCs, ahora veremos cómo los HTLCs son parte de la commitment transaction de cada canal. También veremos el protocolo para añadir, liquidar, fallar y eliminar HTLCs de los compromisos.

#onion_routing:: A continuación, veremos cómo se propaga la información de los HTLC a través de la red dentro del protocolo de enrutamiento de cebolla. Veremos el mecanismo de cifrado y descifrado por capas que da a la Lightning Network algunas de sus características de privacidad.

#gossip:: En este capítulo veremos cómo los nodos Lightning se encuentran entre sí y aprenderemos sobre los canales publicados para construir un gráfico de canales que pueden utilizar para encontrar caminos a través de la red.

>#path_finding:: A continuación, veremos cómo la información del gossip protocol es utilizada por cada nodo para construir un "mapa" de toda la red, que puede utilizar para encontrar caminos de un punto a otro para enrutar los pagos. También veremos las innovaciones existentes en la búsqueda de rutas, como los pagos multiparte.

#protocolo_de_alambre:: La base de la Lightning Network es el protocolo peer-to-peer que los nodos utilizan para intercambiar mensajes sobre la red y sobre sus canales. En este capítulo veremos cómo se construyen esos mensajes y las capacidades de extensión que se incorporan a los mensajes con bits de características y codificación Type-Length-Value (TLV).

#transporte_de_mensajes_encriptados:: Al descender a la parte inferior de la red, veremos el sistema de transporte cifrado subyacente que garantiza el secreto y la integridad de todas las comunicaciones entre nodos.

#facturas:: Una parte clave de la Lightning Network son las solicitudes de pago, también conocidas como facturas Lightning. En este capítulo diseccionamos la estructura y codificación de una invoice.

¡Vamos a sumergirnos en ella!

[[payment_channels]]
== Canales de pago.

En este capítulo nos sumergiremos en los canales de pago y veremos cómo se construyen. Empezaremos con el nodo de Alice abriendo un canal al nodo de Bob, basándonos en los ejemplos presentados al principio de este libro.

[role="pagebreak-after"]
Los mensajes intercambiados por los nodos de Alice y Bob se definen en https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md["BOLT #2: Peer Protocol for Channel Management"]. Las transacciones creadas por los nodos de Alice y Bob se definen en https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md["BOLT #3: Formatos de Transacción y Script de Bitcoin"]. En este capítulo nos centramos en las partes "Apertura y cierre del canal" y "Máquina de estado del canal" de la arquitectura del protocolo Lightning, resaltadas por un esquema en el centro (capa peer-to-peer) de <<LN_protocol_channel_highlight>>. 

[[LN_protocol_channel_highlight]]
.Payment channels in the Lightning protocol suite
image::images/mtln_0701.png["Payment channels in the Lightning protocol suite"]

=== Una forma diferente de utilizar el sistema Bitcoin.

La Lightning Network se describe a menudo como un "protocolo Bitcoin de segunda capa", lo que hace que suene distinto a Bitcoin. Otra forma de describir Lightning es como una "forma más inteligente de usar Bitcoin" o simplemente como una "aplicación sobre Bitcoin". Exploremos eso. 

Históricamente, las transacciones de Bitcoin se transmiten a todo el mundo y se registran en la blockchain de Bitcoin para ser consideradas válidas. Sin embargo, como veremos, si alguien tiene una transacción de Bitcoin pre-firmada que gasta una salida multisig que le da la capacidad exclusiva de gastar ese Bitcoin, efectivamente es dueño de ese Bitcoin incluso si no transmite la transacción. 

Puede pensar en la transacción de Bitcoin prefirmada como un cheque con fecha posterior, que puede cobrarse en cualquier momento. Sin embargo, a diferencia del sistema bancario tradicional, esta transacción no es una "promesa" de pago (también conocida como pagaré), sino un instrumento al portador verificable que equivale a dinero en efectivo. Siempre que el bitcoin al que se refiere la transacción no se haya gastado ya en el momento del canje (o en el momento en que se intente "cobrar" el cheque), el sistema Bitcoin garantiza que esta transacción pre-firmada puede ser emitida y registrada en cualquier momento. Esto sólo es cierto, por supuesto, si ésta es la única transacción presignada. Dentro de la Lightning Network existen dos o más transacciones presignadas de este tipo al mismo tiempo; por lo tanto, necesitamos un mecanismo más sofisticado para seguir teniendo la funcionalidad de un instrumento al portador verificable, como también aprenderá en este capítulo.

La Lightning Network es simplemente una forma diferente y creativa de utilizar Bitcoin. En la Red Relámpago una combinación de transacciones registradas (en la cadena) y pre-firmadas pero retenidas (fuera de la cadena) forman una "capa" de pagos que es una forma más rápida, más barata y más privada de usar Bitcoin. Puede ver esta relación entre las transacciones de Bitcoin dentro y fuera de la cadena en <<on_off_chain>>. 

[[on_off_chain]]
.Lightning payment channel made of on-chain and off-chain transactions
image::images/mtln_0702.png["Lightning payment channel made of on-chain and off-chain transactions"]

Lightning es Bitcoin. Es sólo una forma diferente de utilizar el sistema Bitcoin.

=== Propiedad y control de Bitcoin.

Antes de entender los canales de pago, tenemos que dar un pequeño paso atrás y entender cómo funcionan la propiedad y el control en Bitcoin.

Cuando alguien dice que es "dueño" de Bitcoin, normalmente quiere decir que conoce la clave privada de una dirección de Bitcoin que tiene algunas salidas de transacciones no gastadas (ver <<bitcoin_fundamentals_review>>). La clave privada les permite firmar una transacción para gastar ese bitcoin transfiriéndolo a una dirección diferente. En Bitcoin la "propiedad" de bitcoin puede definirse como la _capacidad de gastar_ ese bitcoin.

Tenga en cuenta que el término "propiedad" tal y como se utiliza en Bitcoin es distinto del término "propiedad" utilizado en un sentido legal. Un ladrón que tiene las claves privadas y puede gastar Bitcoin es un _propietario de facto_ de ese Bitcoin aunque no sea un propietario legal.

[TIP]
====
La propiedad de Bitcoin es sólo el control de las claves y la capacidad de gastar el Bitcoin con esas claves. Como dice el popular dicho de Bitcoin: "Tus llaves, tus monedas-no tus llaves, no tus monedas".
====

==== Diversidad de propiedad (independiente) y Multisig.

La propiedad y el control de las claves privadas no siempre están en manos de una sola persona. Ahí es donde las cosas se ponen interesantes y complicadas. Sabemos que más de una persona puede llegar a conocer la misma clave privada, ya sea por robo o porque el titular original de la clave hace una copia y se la da a otra persona. ¿Son todas estas personas propietarias? En un sentido práctico, lo son, porque cualquiera de las personas que conocen la clave privada puede gastar el bitcoin sin la aprobación de ninguna otra.

Bitcoin también tiene direcciones multifirma donde se necesitan múltiples claves privadas para firmar antes de gastar (ver <<multisig>>). Desde una perspectiva práctica, la propiedad en una dirección multifirma depende del quórum (_K_) y del total (_N_) definidos en el esquema __K__-de-__N__. Un esquema de multifirma de 1 de 10 permitiría a 1 (_K_) de 10 (_N_) firmantes gastar una cantidad de bitcoins bloqueada en esa dirección. Esto es similar al escenario en el que 10 personas tienen una copia de la misma clave privada y cualquiera de ellas puede gastarla independientemente.

==== Propiedad conjunta sin control independiente.

También existe el escenario en el que _nadie_ tiene quórum. En un esquema 2-de-2 como el utilizado en la Lightning Network, ninguno de los firmantes puede gastar el bitcoin sin obtener la firma de la otra parte. ¿Quién es el propietario del bitcoin en ese caso? En realidad, nadie tiene la propiedad porque nadie tiene el control. Cada uno de ellos posee el equivalente a una acción de voto en la decisión, pero ambos votos son necesarios. Un problema clave (juego de palabras) con un esquema 2-de-2, tanto en Bitcoin como en la ley, es lo que ocurre si una de las partes no está disponible, o si hay un bloqueo de votos y alguna de las partes se niega a cooperar. 

==== Prevención de Bitcoin "bloqueado" y no gastable.

Si uno de los dos firmantes de un multisig no puede o no quiere firmar, los fondos se vuelven inutilizables. Este escenario no sólo puede ocurrir accidentalmente (pérdida de claves), sino que puede ser utilizado como una forma de chantaje por cualquiera de las partes: "No firmaré si no me pagas una parte de los fondos".

Los canales de pago en Lightning se basan en una dirección multisig 2 de 2, con los dos socios del canal como firmantes en el multisig. En este momento, los canales se financian sólo por uno de los dos socios del canal: cuando se elige "abrir" un canal, se depositan fondos en la dirección multisig 2-de-2 con una transacción. Una vez que esa transacción es minada y los fondos están en la multisig, no puedes recuperarlos sin la cooperación de tu socio de canal, porque necesitas su firma (también) para gastar el bitcoin.

En la siguiente sección, al ver cómo abrir (crear) un canal Lightning, veremos cómo podemos evitar la pérdida de fondos o cualquier escenario de chantaje entre los dos socios mediante la implementación de un protocolo de equidad para la construcción del canal con la ayuda de transacciones pre-firmadas que gastan la salida del multisig de una manera que da a los compañeros en el canal la capacidad exclusiva de gastar una de las salidas que codifica la cantidad de bitcoin que poseen en el canal.


=== Construyendo un payment channel.

En <<what_is_payment_channel>>, describimos los canales de pago como una _relación financiera_ entre dos nodos Lightning, que se establece mediante la financiación de una dirección multifirma 2-de-2 de los dos socios del canal.

Supongamos que Alice quiere construir un payment channel que le permita conectarse directamente a la tienda de Bob. En primer lugar, los dos nodos (el de Alice y el de Bob) tienen que establecer una conexión de Internet entre sí, para poder negociar un payment channel.

==== Claves privadas y públicas de los nodos.

Cada nodo de la Lightning Network se identifica con una _clave pública de nodo_. La clave pública identifica de forma exclusiva al nodo específico y suele presentarse como una codificación hexadecimal. Por ejemplo, René Pickhardt dirige actualmente un nodo Lightning (+ln.rene-pickhardt.de+) que se identifica con la siguiente clave pública de nodo:

----
02a1cebfacb2674143b5ad0df3c22c609e935f7bc0ebe801f37b8e9023d45ea7b8
----

Cada nodo genera una clave privada raíz cuando se inicializa por primera vez. La clave privada se mantiene privada en todo momento (nunca se comparte) y se almacena de forma segura en la billetera del nodo. A partir de esa clave privada, el nodo obtiene una clave pública que es el identificador del nodo y se comparte con la red. Dado que el espacio de claves es enorme, siempre que cada nodo genere la clave privada de forma aleatoria, tendrá una clave pública única que, por tanto, podrá identificarlo de forma exclusiva en la red.

==== Dirección de red del nodo.

Además, cada nodo también anuncia una dirección de red en la que puede ser localizado, en uno de los varios formatos posibles:

TCP/IP:: Una dirección IPv4 o IPv6 y un número de puerto TCP

TCP/Tor:: Una dirección Tor "onion" y un número de puerto TCP

El identificador de la dirección de red se escribe como +Dirección:Puerto+, que es consistente con los estándares internacionales para los identificadores de red, como se usan, por ejemplo, en la web.

Por ejemplo, el nodo de René con la clave pública del nodo +02a1ceb...45ea7b8+ actualmente anuncia su dirección de red como la dirección TCP/IP:

----
172.16.235.20:9735
----

[TIP]
====
El puerto TCP por defecto para la Red Relámpago es el 9735, pero un nodo puede elegir escuchar en cualquier puerto TCP.
====

==== Identificadores de nodo.

La clave pública del nodo y la dirección de red se escriben juntas en el siguiente formato, separadas por el signo +@+, como __++NodeID@Address:Port++__.

Así, el identificador completo del nodo de René sería

----
02a1cebfacb2674143b5ad0df3c22c609e935f7bc0ebe801f37b8e9023d45ea7b8
@172.16.235.20:9735
----

[TIP]
====
El alias del nodo de René es +ln.rene-pickhardt.de+; sin embargo, este nombre existe sólo para mejorar la legibilidad. Cada operador de nodo puede anunciar el alias que quiera, y no hay ningún mecanismo que impida a los operadores de nodo seleccionar un alias que ya esté siendo utilizado. Por lo tanto, para referirse a un nodo, hay que utilizar el esquema __++NodeID@Address:Port++__.
====

El identificador anterior suele estar codificado en un código QR, lo que facilita a los usuarios el escaneo si quieren conectar su propio nodo con el nodo específico identificado por esa dirección.

Al igual que los nodos de Bitcoin, los nodos Lightning anuncian su presencia en la Lightning Network "cotilleando" su clave pública de nodo y su dirección de red. De este modo, otros nodos pueden encontrarlos y mantener un inventario (base de datos) de todos los nodos conocidos a los que pueden conectarse e intercambiar los mensajes que se definen en el protocolo de mensajes P2P de Lightning. 

==== Conectando nodos como pares directos.

Para que el nodo de Alice se conecte al nodo de Bob, necesitará la clave pública del nodo de Bob, o la dirección completa que contiene la clave pública, la dirección IP o Tor, y el puerto. Dado que Bob dirige una tienda, la dirección del nodo de Bob puede obtenerse de una invoice o de una página de pago de la tienda en la web. Alice puede escanear un código QR que contenga la dirección y ordenar a su nodo que se conecte al nodo de Bob.

Una vez que Alice se ha conectado al nodo de Bob, sus nodos son ahora pares conectados directamente.

[TIP]
====
Para abrir un payment channel, dos nodos deben estar primero conectados como pares directos abriendo una conexión a través de Internet (o Tor).
====

=== Construyendo el canal.

Ahora que los nodos Lightning de Alice y Bob están conectados, pueden comenzar el proceso de construcción de un payment channel. En esta sección revisaremos las comunicaciones entre sus nodos, conocidas como el _Protocolo de pares Lightning para la gestión del canal_, y el protocolo criptográfico que utilizan para construir las transacciones de Bitcoin.

[TIP]
====
Describimos dos protocolos diferentes en este escenario. Primero, hay un _protocolo de mensajes_, que establece cómo se comunican los nodos Lightning a través de Internet y qué mensajes intercambian entre sí. En segundo lugar, está el _protocolo criptográfico_, que establece cómo los dos nodos construyen y firman las transacciones de Bitcoin.
====

[[peer_protocol_channel_management]]
==== Protocolo de pares para la gestión de canales.

El protocolo de pares de Lightning para la gestión de canales se define en https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md[BOLT #2: Peer Protocol for Channel Management]. En este capítulo revisaremos con más detalle las secciones "Channel Establishment" y "Channel Closing" de BOLT #2.

==== Flujo de mensajes de establecimiento de canal.

El establecimiento del canal se consigue mediante el intercambio de seis mensajes entre los nodos de Alice y Bob (tres de cada peer): +open_channel+, +accept_channel+, +funding_created+, +funding_signed+, +funding_locked+, y +funding_locked+. Los seis mensajes se muestran como un diagrama de secuencia temporal en <<funding_message_flow>>. 

[[funding_message_flow]]
.The channel establishment message flow
image::images/mtln_0703.png["The channel establishment message flow"]

En <<funding_message_flow>>, los nodos de Alice y Bob están representados por las líneas verticales "A" y "B" a cada lado del diagrama. Un diagrama de secuencia temporal como éste muestra el tiempo fluyendo hacia abajo, y los mensajes fluyendo de un lado a otro entre los dos pares de comunicación. Las líneas están inclinadas hacia abajo para representar el tiempo transcurrido necesario para transmitir cada mensaje, y la dirección del mensaje se muestra con una flecha al final de cada línea.

El establecimiento del canal consta de tres partes. En primer lugar, los dos compañeros comunican sus capacidades y expectativas, con Alice iniciando una solicitud a través de +open_channel+ y Bob aceptando la solicitud de canal a través de +accept_channel+.

En segundo lugar, Alice construye las transacciones de financiación y reembolso (como veremos más adelante en esta sección) y envía +funding_created+ a Bob. Otro nombre para la transacción de "reembolso" es una transacción de "compromiso", ya que compromete la distribución actual de los saldos en el canal. Bob responde enviando de vuelta las firmas necesarias con +funding_signed+. Esta interacción es la base del _protocolo criptográfico_ para asegurar el canal y evitar robos. Alice emitirá ahora la funding transaction (en la cadena) para establecer y anclar el payment channel. La transacción tendrá que ser confirmada en el blockchain de Bitcoin.

[TIP]
====
El nombre del mensaje +funding_signed+ puede ser un poco confuso. Este mensaje no contiene una firma para la funding transaction, sino que contiene la firma de Bob para la transacción de reembolso que permite a Alice reclamar su bitcoin de vuelta al multisig.
====

Una vez que la transacción tiene suficientes confirmaciones (definidas por el campo `minimum_depth` del mensaje `accept_channel`), Alice y Bob intercambian mensajes +funding_locked+, y el canal entra en modo de funcionamiento normal.

===== El mensaje open_channel.

El nodo de Alice solicita un payment channel con el nodo de Bob enviando un mensaje +open_channel+. El mensaje contiene información sobre las _expectativas_ de Alice para la configuración del canal, que Bob puede aceptar o rechazar.

La estructura del mensaje +open_channel+ (tomada de BOLT #2) se muestra en <<open_channel_message>>.

[[open_channel_message]]
.The `open_channel` message
====
----
[chain_hash:chain_hash]
[32*byte:temporary_channel_id]
[u64:funding_satoshis]
[u64:push_msat]
[u64:dust_limit_satoshis]
[u64:max_htlc_value_in_flight_msat]
[u64:channel_reserve_satoshis]
[u64:htlc_minimum_msat]
[u32:feerate_per_kw]
[u16:to_self_delay]
[u16:max_accepted_htlcs]
[point:funding_pubkey]
[point:revocation_basepoint]
[point:payment_basepoint]
[point:delayed_payment_basepoint]
[point:htlc_basepoint]
[point:first_per_commitment_point]
[byte:channel_flags]
[open_channel_tlvs:tlvs]
----
====

Los campos contenidos en este mensaje especifican los parámetros del canal que Alice desea, así como varios ajustes de configuración de los nodos de Alice que reflejan las expectativas de seguridad para el funcionamiento del canal. 

[role="pagebreak-before"]
Algunos de los parámetros de construcción del canal se enumeran aquí:

+chain_hash+:: Esto identifica qué blockchain (por ejemplo, la red principal de Bitcoin) se utilizará para este canal. Normalmente es el hash del bloque génesis de esa blockchain.

+funding_satoshis+:: La cantidad que Alice utilizará para financiar el canal, que es la capacidad total del canal.

+canal_reserva_satoshis+:: El balance mínimo, en satoshis, que se reserva en cada lado de un canal. Volveremos a esto cuando hablemos de las penalizaciones.

+push_msat+:: Una cantidad opcional que Alice "empujará" inmediatamente a Bob como un pago sobre la financiación del canal. Establecer este valor a cualquier cosa que no sea 0 significa efectivamente regalar dinero a su socio de canal y debe ser utilizado con precaución.

+to_self_delay+:: Un parámetro de seguridad muy importante para el protocolo. El valor del mensaje `open_channel` se utiliza en la commitment transaction del respondedor, y el `accept_channel` en la del iniciador. Esta asimetría existe para permitir que cada parte exprese cuánto tiempo necesita esperar la otra parte para reclamar unilateralmente los fondos en una commitment transaction. Si Bob, en cualquier momento, cierra unilateralmente el canal contra la voluntad de Alice, se compromete a no acceder a sus propios fondos durante el tiempo definido aquí. Cuanto más alto sea este valor, más seguridad tendrá Alice, pero más tiempo podrá tener Bob sus fondos bloqueados.

+clave_pública+:: La clave pública que Alice aportará al multisig 2-de-2 que ancla este canal.

+X_basepoint+:: Claves maestras, usadas para derivar claves hijas para varias partes del compromiso, la revocación, el pago enrutado (HTLCs) y las transacciones de cierre. Se utilizarán y explicarán en capítulos posteriores.

[TIP]
====
Si desea comprender los demás campos y mensajes del protocolo Lightning peer que no tratamos en este libro, le sugerimos que los busque en las especificaciones de BOLT. Estos mensajes y campos son importantes, pero no pueden ser cubiertos con suficiente detalle en el ámbito de este libro. Queremos que entiendas los principios fundamentales lo suficientemente bien como para que puedas completar los detalles leyendo la especificación real del protocolo (BOLTs).
====

===== El mensaje accept_channel.

En respuesta al mensaje +open_channel+ de Alice, Bob devuelve el mensaje +accept_channel+ mostrado en <<accept_channel_message>>.

[[accept_channel_message]]
.The `accept_channel` message
====
----
[32*byte:temporary_channel_id]
[u64:dust_limit_satoshis]
[u64:max_htlc_value_in_flight_msat]
[u64:channel_reserve_satoshis]
[u64:htlc_minimum_msat]
[u32:minimum_depth]
[u16:to_self_delay]
[u16:max_accepted_htlcs]
[point:funding_pubkey]
[point:revocation_basepoint]
[point:payment_basepoint]
[point:delayed_payment_basepoint]
[point:htlc_basepoint]
[point:first_per_commitment_point]
[accept_channel_tlvs:tlvs]
----
====

Como puedes ver, es similar al mensaje +open_channel+ y contiene las expectativas del nodo de Bob y los valores de configuración.

Los dos campos más importantes de +accept_channel+ que Alice utilizará para construir el payment channel son

+funding_pubkey+:: La clave pública que el nodo de Bob aporta para la dirección multisig 2 de 2 que ancla el canal.

+profundidad_mínima+:: El número de confirmaciones que el nodo de Bob espera para la funding transaction antes de considerar el canal "abierto" y listo para ser utilizado.

==== La funding transaction.

Una vez que el nodo de Alice recibe el mensaje +accept_channel+ de Bob, tiene la información necesaria para construir la _transacción de financiación_ que ancla el canal a la blockchain de Bitcoin. Como hemos comentado en capítulos anteriores, un payment channel Lightning está anclado por una dirección multifirma 2-de-2. En primer lugar, necesitamos generar esa dirección multifirma para permitirnos construir la funding transaction (y la transacción de reembolso como se describe posteriormente).

==== Generación de una dirección multifirma.

La funding transaction envía alguna cantidad de bitcoin (+funding_satoshis+ del mensaje +open_channel+) a una salida multifirma 2-de-2 que se construye a partir de las claves públicas +funding_pubkey+ de Alice y Bob.

El nodo de Alice construye un script de multifirma como se muestra aquí:

++++
<pre data-type="programlisting">2 &lt;<em>Alice_funding_pubkey</em>&gt; &lt;<em>Bob_funding_pubkey</em>&gt; 2 CHECKMULTISIG
</pre>
++++

Tenga en cuenta que, en la práctica, las claves de financiación se _ordenan_ de forma determinista (utilizando el orden lexicográfico de la forma comprimida serializada de las claves públicas) antes de colocarse en la secuencia de comandos testigo. Al acordar este orden de antemano, nos aseguramos de que ambas partes construirán una salida de funding transaction idéntica, que está firmada por la firma de commitment transaction intercambiada.


Esta secuencia de comandos se codifica como una dirección Bitcoin Pay-to-Witness-Script-Hash (P2WSH), cuyo aspecto es el siguiente

----
bc1q89ju02heg32yrqdrnqghe6132wek25p6sv6e564znvrvez7tq5zqt4dn02
----
==== Construyendo la funding transaction.

El nodo de Alice puede ahora construir una funding transaction, enviando la cantidad acordada con Bob (`funding_satoshis`) a la dirección multisig de 2 de 2. Supongamos que funding_satoshis era de 140.000 y Alice está gastando una salida de 200.000 satoshi y creando un cambio de 60.000 satoshi. La transacción se verá algo así como <<A_B_funding_Tx>>.  

[[A_B_funding_Tx]]
.Alice constructs the funding transaction
image::images/mtln_0704.png["Alice constructs the funding transaction"]

Alice _no transmite_ esta transacción porque al hacerlo pondría en riesgo sus 140.000 satoshi. Una vez gastado a la multisig de 2 de 2, no hay forma de que Alice recupere su dinero sin la firma de Bob.

[role="pagebreak-before less_space"]
Canales de pago de doble financiación
****
En la implementación actual de Lightning, los canales son financiados sólo por el nodo que inicia el canal (Alice en nuestro ejemplo). Se han propuesto canales con doble financiación, pero aún no se han implementado. En un canal con doble financiación, tanto Alice como Bob contribuirían a la funding transaction. Los canales de doble financiación requieren un flujo de mensajes y un protocolo criptográfico ligeramente más complicados, por lo que aún no se han implementado, pero están previstos para una futura actualización de los BOLTs de Lightning. La implementación de `c-lightning` incluye una versión experimental de una variante de los canales de doble financiación.
****

==== Retención de Transacciones Firmadas sin Transmisión.

Una importante característica de Bitcoin que hace posible Lightning es la capacidad de construir y firmar transacciones, pero sin emitirlas. La transacción es _válida_ en todos los sentidos, pero hasta que no se emite y confirma en la blockchain de Bitcoin no se reconoce y sus resultados no son gastables porque no se han creado en la blockchain. Utilizaremos esta capacidad muchas veces en la Lightning Network, y el nodo de Alice utiliza la capacidad cuando construye la funding transaction: reteniéndola y no emitiéndola todavía.

==== Reembolso antes de la financiación.

Para evitar la pérdida de fondos, Alice no puede poner su bitcoin en un 2-de-2 hasta que tenga una manera de obtener un reembolso si las cosas van mal. Esencialmente, ella debe planificar la "salida" del canal antes de entrar en este acuerdo.

Consideremos la construcción legal de un acuerdo prenupcial, también conocido como "prenupcial". Cuando dos personas contraen matrimonio, su dinero está ligado por ley (dependiendo de la jurisdicción). Antes de contraer matrimonio, pueden firmar un acuerdo que especifique cómo separar sus bienes si se disuelve el matrimonio por divorcio.

Podemos crear un acuerdo similar en Bitcoin. Por ejemplo, podemos crear una transacción de reembolso, que funciona como un acuerdo prenupcial, permitiendo a las partes decidir cómo se dividirán los fondos en su canal antes de que sus fondos estén realmente bloqueados en la dirección de financiación multifirma.

==== Construyendo la transacción de reembolso prefijada.

Llamamos a esta transacción de reembolso una _transacción de compromiso_ porque compromete a ambos socios del canal a distribuir el balance del canal de manera justa. Ya que Alice financió el canal por su cuenta, ella obtiene todo el balance, y tanto Alice como Bob se comprometen a reembolsar a Alice con esta transacción.

En la práctica, es un poco más complicado como veremos en capítulos posteriores, pero por ahora vamos a mantener las cosas simples y asumir que se ve como <<A_B_fund_refund_Tx>>. 

[[A_B_fund_refund_Tx]]
.Alice also constructs the refund transaction
image::images/mtln_0705.png["Alice also constructs the refund transaction"]

Más adelante en este capítulo veremos cómo se pueden hacer más transacciones de compromiso para distribuir el balance del canal en diferentes cantidades.

==== Encadenamiento de transacciones sin transmisión.

Así que ahora, Alicia ha construido las dos transacciones mostradas en <<A_B_fund_refund_Tx>>. Pero te preguntarás cómo es posible.  Alice no ha transmitido la funding transaction a la blockchain de Bitcoin. En lo que respecta a todos en la red, esa transacción no existe. La transacción de reembolso se construye para _gastar_ una de las salidas de la funding transaction, aunque esa salida tampoco existe todavía. ¿Cómo se puede gastar una salida que no ha sido confirmada en el blockchain de Bitcoin?

La transacción de reembolso todavía no es una transacción válida. Para que se convierta en una transacción válida deben ocurrir dos cosas:

* La funding transaction debe ser transmitida a la red Bitcoin. (Para garantizar la seguridad de la Lightning Network, también requeriremos que sea confirmada por la blockchain de Bitcoin, aunque esto no es estrictamente necesario para encadenar transacciones).
* La entrada de la transacción de reembolso necesita las firmas de Alice y Bob. 

[role="pagebreak-before"]
Pero aunque estas dos cosas no hayan sucedido, y aunque el nodo de Alice no haya emitido la funding transaction, todavía puede construir la transacción de reembolso. Puede hacerlo porque puede calcular el hash de la funding transaction y referenciarlo como entrada en la transacción de reembolso.

¿Notas cómo Alice ha calculado +6da3c2...387710+ como hash de la funding transaction? Si la funding transaction se emite, ese hash se registrará como el ID de la funding transaction. Por lo tanto, la salida `0` de la funding transaction (la salida de la dirección 2-de-2) se referenciará entonces como ID de salida +6da3c2...387710:0+. La transacción de reembolso puede construirse para gastar esa salida de la funding transaction aunque todavía no exista, porque Alice sabe cuál será su identificador una vez confirmado.

Esto significa que Alice puede crear una transacción encadenada haciendo referencia a una salida que aún no existe, sabiendo que la referencia será válida si la funding transaction se confirma, haciendo que la transacción de reembolso también sea válida. Como veremos en la siguiente sección, este "truco" de encadenar transacciones antes de que se emitan requiere una característica muy importante de Bitcoin que se introdujo en agosto de 2017: _Testigo Segregado_.

==== Solventando la maleabilidad (Testigo Segregado).

Alice tiene que depender de que el ID de la funding transaction se conozca antes de la confirmación. Pero antes de la introducción de Segregated Witness (SegWit) en agosto de 2017, esto no era suficiente para proteger a Alice. Debido a la forma en que se construían las transacciones con las firmas (testigos) incluidas en el ID de la transacción, era posible que un tercero (por ejemplo, Bob) difundiera una versión alternativa de una transacción con un ID de transacción _malleado_ (modificado). Esto se conoce como _maleabilidad de la transacción_, y antes de SegWit, este problema dificultaba la implementación de canales de pago de duración indefinida de forma segura.

Si Bob pudiera modificar la funding transaction de Alice antes de que fuera confirmada, y producir una réplica que tuviera un ID de transacción diferente, Bob podría hacer que la transacción de reembolso de Alice fuera inválida y secuestrar su bitcoin. Alice estaría a merced de Bob para conseguir una firma para liberar sus fondos y podría ser fácilmente chantajeada. Bob no podía robar los fondos, pero podía impedir que Alice los recuperara.

La introducción de SegWit hizo que los ID de las transacciones no confirmadas fueran inmutables desde el punto de vista de terceros, lo que significa que Alice podía estar segura de que el ID de la funding transaction no cambiaría. Como resultado, Alice puede estar segura de que si consigue la firma de Bob en la transacción de reembolso, tiene una forma de recuperar su dinero. Ahora tiene una forma de implementar el equivalente en Bitcoin de un "acuerdo prenupcial" antes de bloquear sus fondos en la multisig.

[TIP]
====
Te habrás preguntado cómo podría Bob alterar (falsear) una transacción creada y firmada por Alice. Ciertamente, Bob no tiene las claves privadas de Alice. Sin embargo, las firmas ECDSA de un mensaje no son únicas. Conocer una firma (que se incluye en una transacción válida) permite producir muchas firmas de aspecto diferente que siguen siendo válidas. Antes de que SegWit eliminara las firmas del algoritmo de compendio de transacciones, Bob podía sustituir la firma por una firma válida equivalente que produjera un ID de transacción diferente, rompiendo la cadena entre la funding transaction y la de reembolso.
====

===== El mensaje funding_created.

Ahora que Alice ha construido las transacciones necesarias, el flujo de mensajes de construcción del canal continúa. Alice transmite el mensaje +funding_created+ a Bob. Puedes ver el contenido de este mensaje aquí:

[[funding_created_message]]
.The funding_created message
----
[32*byte:temporary_channel_id]
[sha256:funding_txid]
[u16:funding_output_index]
[signature:signature]
----

Con este mensaje, Alice proporciona a Bob la información importante sobre la funding transaction que ancla el payment channel:

+funding_txid+:: Este es el ID de la transacción (TxID) de la funding transaction, y se utiliza para crear el ID del canal una vez que se establece el canal.

+funding_output_index+:: Es el índice de salida, para que Bob sepa qué salida de la transacción (por ejemplo, la salida `0`) es la salida multisig financiada por Alice. Esto también se utiliza para formar el ID del canal.

Finalmente, Alice también envía la +firma+ correspondiente a la `funding_pubkey` de Alice y que se utiliza para gastar de la multisig de 2-de-2. Esto lo necesita Bob porque también tendrá que crear su propia versión de una commitment transaction. Esa commitment transaction necesita una firma de Alice, que ella le proporciona. Observe que las transacciones de compromiso de Alice y Bob tienen un aspecto ligeramente diferente, por lo que las firmas serán diferentes. Saber cómo es la commitment transaction de la otra parte es crucial y forma parte del protocolo para proporcionar la firma válida. 

[TIP]
====
En el protocolo Lightning vemos a menudo que los nodos envían firmas en lugar de transacciones enteras firmadas. Esto se debe a que cualquiera de las partes puede reconstruir la misma transacción y, por tanto, sólo se necesita la firma para que sea válida. Enviar sólo la firma y no la transacción completa ahorra mucho ancho de banda de la red.
====


===== El mensaje funding_signed.

Después de recibir el mensaje +funding_created+ de Alice, Bob ya conoce el ID de la funding transaction y el índice de salida. El ID del canal se hace mediante un "or exclusivo" (XOR) a nivel de bits del ID de la funding transaction y el índice de salida:

----
channel_id = funding_txid XOR funding_output_index
----

Más concretamente, un "channel_id", que es la representación de 32 bytes de un UTXO de financiación, se genera al XORar los 2 bytes inferiores del TxID de financiación con el índice de la salida de financiación.

Bob también tendrá que enviar a Alice su firma para la transacción de reembolso, basada en la `funding_pubkey` de Bob que formó la multisig de 2 de 2. Aunque Bob ya tiene su transacción de reembolso local, esto permitirá a Alice completar la transacción de reembolso con todas las firmas necesarias y estar segura de que su dinero es reembolsable en caso de que algo vaya mal.

Bob construye un mensaje +funding_signed+ y lo envía a Alice. Aquí vemos el contenido de este mensaje:

[[funding_signed_message]]
.The funding_signed message
----

[channel_id:channel_id]
[signature:signature]

----

==== Transmisión de la funding transaction.

Al recibir el mensaje +funding_signed+ de Bob, Alicia tiene ahora las dos firmas necesarias para firmar la transacción de reembolso. Su "plan de salida" es ahora seguro, y por lo tanto puede emitir la funding transaction sin temor a tener sus fondos bloqueados. Si algo va mal, Alice puede simplemente emitir la transacción de reembolso y recuperar su dinero, sin más ayuda de Bob.

Alice ahora envía la funding transaction a la red Bitcoin para que pueda ser minada en el blockchain. Tanto Alice como Bob estarán pendientes de esta transacción y esperarán a que se produzcan confirmaciones de +mínima_profundidad+ (por ejemplo, seis confirmaciones) en la blockchain de Bitcoin.

[TIP]
====
Por supuesto, Alice utilizará el protocolo de Bitcoin para verificar que la firma que Bob le envió es realmente válida. Este paso es muy crucial. Si por alguna razón Bob estuviera enviando datos erróneos a Alice, su "plan de salida" sería saboteado.
====

===== El mensaje funding_locked.

Tan pronto como la funding transaction haya alcanzado el número requerido de confirmaciones, tanto Alice como Bob se envían el mensaje +funding_locked+ y el canal está listo para ser utilizado.

=== Envío de pagos a través del canal.

El canal ha sido configurado, pero en su estado inicial, toda la capacidad (140.000 satoshis) está del lado de Alice. Esto significa que Alice puede enviar pagos a Bob a través del canal, pero Bob no tiene fondos para enviar a Alice todavía.

En las próximas secciones mostraremos cómo se realizan los pagos a través del payment channel y cómo se actualiza el _estado del canal_.

Supongamos que Alicia quiere enviar 70.000 satoshis a Bob para pagar su cuenta en la cafetería de Bob.

==== Dividir el balance.

En principio, enviar un pago de Alicia a Bob es simplemente una cuestión de redistribuir el balance del canal. Antes de enviar el pago, Alice tiene 140.000 satoshis y Bob ninguno. Después de enviar el pago de 70.000 satoshis, Alice tiene 70.000 satoshis y Bob tiene 70.000 satoshis.

Por lo tanto, todo lo que Alice y Bob tienen que hacer es crear y firmar una transacción que gaste el multisig a dos salidas pagando a Alice y Bob sus saldos correspondientes. A esta transacción actualizada la llamamos _transacción de compromiso_.

Alice y Bob operan el payment channel _avanzando el estado del canal_ a través de una serie de compromisos. Cada compromiso actualiza los saldos para reflejar los pagos que han circulado por el canal. Tanto Alice como Bob pueden iniciar un nuevo compromiso para actualizar el canal.

En <<competing_commitments_1>> vemos varias transacciones de compromiso. 

La primera commitment transaction mostrada en <<competing_commitments_1>> es la transacción de reembolso que Alice construyó antes de financiar el canal. En el diagrama, este es el compromiso #0. Después de que Alicia pague a Bob 70.000 satoshis, la nueva commitment transaction (Compromiso #1) tiene dos salidas que pagan a Alicia y a Bob sus respectivos saldos. Hemos incluido dos transacciones de compromiso posteriores (Compromiso #2 y Compromiso #3) que representan a Alicia pagando a Bob 10.000 satoshis adicionales y luego 20.000 satoshis, respectivamente.

Cada commitment transaction firmada y válida puede ser utilizada por cualquiera de los dos socios del canal en cualquier momento para cerrar el canal transmitiéndolo a la red Bitcoin. Dado que ambos tienen la commitment transaction más reciente y pueden utilizarla en cualquier momento, también pueden simplemente retenerla y no emitirla. Es su garantía de una salida justa del canal.

[[competing_commitments_1]]
.Multiple commitment transactions
image::images/mtln_0706.png[Multiple commitment transactions]

==== Compromisos en competencia.

¿No es esto un "double-spending" que el sistema Bitcoin pretende evitar?

Así es. De hecho, dependemos de la capacidad de Bitcoin para _prevenir_ un double-spending para que Lightning funcione. No importa cuántas transacciones de compromiso construyan y firmen Alice y Bob, sólo una de ellas puede ser confirmada.

Mientras Alice y Bob mantengan estas transacciones y no las difundan, el resultado de la financiación no se gastará. Pero si una commitment transaction se emite y se confirma, gastará el resultado de la financiación. Si Alice o Bob intentan emitir más de una commitment transaction, sólo una de ellas será confirmada y las otras serán rechazadas como intento (y fracaso) de double-spending.

Si se emite más de una commitment transaction, hay muchos factores que determinarán cuál se confirma primero: la cantidad de tasas incluidas, la velocidad de propagación de estas transacciones en competencia, la topología de la red, etc. Esencialmente se convierte en una carrera sin un resultado predecible. Eso no suena muy seguro. Suena como si alguien pudiera hacer trampa.

==== Engañando con Transacciones de Compromiso Antiguas.

Veamos más detenidamente las transacciones de compromiso en <<competing_commitments_1>>. Las cuatro transacciones de compromiso están firmadas y son válidas. Pero sólo la última refleja con exactitud los saldos más recientes del canal. En este escenario particular, Alice tiene la oportunidad de hacer trampa transmitiendo un compromiso más antiguo y consiguiendo que se confirme en el blockchain de Bitcoin. Digamos que Alice transmite el Compromiso #0 y consigue que se confirme: efectivamente cerrará el canal y se llevará los 140.000 satoshis ella misma. De hecho, en este ejemplo particular, cualquier compromiso, excepto el Compromiso #3, mejora la posición de Alice y le permite "cancelar" al menos parte de los pagos reflejados en el canal.

En la siguiente sección veremos cómo la Lightning Network resuelve este problema, impidiendo que las transacciones de compromiso más antiguas sean utilizadas por los socios del canal mediante un mecanismo de revocación y sanciones. Hay otras formas de evitar la transmisión de transacciones de compromiso más antiguas, como los canales de eltoo, pero requieren una actualización de Bitcoin llamada rebinding de entrada (ver <<bitcoin_prot_17>>).

==== Revocación de transacciones de compromiso antiguas.

Las transacciones de Bitcoin no expiran y no pueden ser "canceladas". Tampoco pueden ser detenidas o censuradas una vez que han sido emitidas. Entonces, ¿cómo podemos "revocar" una transacción que tiene otra persona y que ya ha sido firmada?

La solución utilizada en Lightning es otro ejemplo de protocolo de equidad. En lugar de tratar de controlar la capacidad de transmitir una transacción, hay un mecanismo de _penalización_ incorporado que garantiza que a un posible tramposo no le conviene transmitir una commitment transaction antigua. Siempre pueden transmitirla, pero lo más probable es que pierdan dinero si lo hacen.

[TIP]
====
La palabra "revocar" es un término erróneo porque implica que los compromisos más antiguos son de alguna manera inválidos y no pueden ser transmitidos y confirmados. Pero este no es el caso, ya que las transacciones válidas de Bitcoin no pueden ser revocadas. En cambio, el protocolo Lightning utiliza un mecanismo de penalización para castigar al socio del canal que emite un compromiso antiguo.
====

Hay tres elementos que componen el mecanismo de revocación y penalización del protocolo Lightning:

Transacciones de compromiso asimétricas:: Las transacciones de compromiso de Alice son ligeramente diferentes a las de Bob.

Retraso en el gasto:: El pago a la parte que tiene la commitment transaction se retrasa (timelocked), mientras que el pago a la otra parte puede reclamarse inmediatamente.

Claves de revocación:: Se utilizan para desbloquear una opción de penalización para los compromisos antiguos.

Veamos estos tres elementos sucesivamente.


==== Transacciones de compromiso asimétricas.

Alice y Bob mantienen transacciones de compromiso ligeramente diferentes. Veamos específicamente el compromiso #2 de <<competing_commitments_1>>, con más detalle en <<commitment_2>>. 

[[commitment_2]]
.Commitment transaction #2
image::images/mtln_0707.png[Commitment transaction #2]

Alice y Bob realizan dos variaciones diferentes de esta transacción, como se ilustra en <<asymmetric_1>>.

[[asymmetric_1]]
.Asymmetric commitment transactions
image::images/mtln_0708.png[Asymmetric commitment transactions]

Por convención, dentro del protocolo Lightning, nos referimos a los dos socios del canal como `self` (también conocido como `local`) y `remote`, dependiendo de qué lado estemos mirando. Las salidas que pagan a cada socio del canal se denominan `to_local` y `to_remote`, respectivamente.

En <<asymmetric_1>> vemos que Alice tiene una transacción que paga 60.000 satoshis "a sí misma" (puede ser gastada por las llaves de Alice), y 80.000 satoshis "a distancia" (puede ser gastada por las llaves de Bob).

Bob tiene la imagen de espejo de esa transacción, donde la primera salida es 80.000 satoshis "para sí mismo" (puede ser gastado por las claves de Bob), y 60.000 satoshis "para la distancia" (puede ser gastado por las claves de Alice). 

==== Gasto retardado (Timelocked) a_mismo.

El uso de transacciones asimétricas permite que el protocolo atribuya fácilmente la _culpa_ a la parte que hace la trampa. La invariante de que la parte _emisora_ siempre debe esperar garantiza que la parte "honesta" tenga tiempo para refutar la reclamación y revocar sus fondos. Esta asimetría se manifiesta en forma de salidas diferentes para cada parte: la salida "to_local" siempre está bloqueada por el tiempo y no puede gastarse inmediatamente, mientras que la salida "to_remote" no está bloqueada por el tiempo y puede gastarse inmediatamente.

En la commitment transaction realizada por Alice, por ejemplo, la salida "to_local" que le paga a ella está bloqueada durante 432 bloques, mientras que la salida "to_remote" que paga a Bob puede gastarse inmediatamente (ver <<asymmetric_delayed_1>>). La commitment transaction de Bob para el Compromiso #2 es la imagen de espejo: su propia salida (`to_local`) está bloqueada por tiempo y la salida `to_remote` de Alice puede ser gastada inmediatamente.

[[asymmetric_delayed_1]]
.Asymmetric and delayed commitment transactions
image::images/mtln_0709.png[Asymmetric and delayed commitment transactions]

[role="pagebreak-before"]
Esto significa que si Alice cierra el canal emitiendo y confirmando la commitment transaction que tiene, no puede gastar su balance durante 432 bloques, pero Bob puede reclamar su balance inmediatamente. Si Bob cierra el canal utilizando la commitment transaction que tiene, no puede gastar su balance durante 432 bloques, mientras que Alice puede gastar el suyo inmediatamente.

El retraso está ahí por una razón: para permitir a la parte _remota_ ejercer una opción de penalización si un compromiso antiguo (revocado) debe ser emitido por el otro socio del canal. Veamos a continuación las claves de revocación y la opción de penalización.

El retraso es negociado por Alice y Bob, durante el flujo de mensajes de construcción del canal inicial, como un campo llamado +to_self_delay+. Para garantizar la seguridad del canal, el retardo es escalado a la capacidad del canal-lo que significa que un canal con más fondos tiene retrasos más largos en las salidas de +a sí mismo+ en los compromisos. El nodo de Alice incluye un retardo deseado para +to_self+ en el mensaje de +open_channel+. Si Bob lo considera aceptable, su nodo incluye el mismo valor para +to_self_delay+ en el mensaje +accept_channel+. Si no están de acuerdo, entonces el canal es rechazado (ver <<theShutdownmessage>>).

==== Claves de revocación.

Como hemos comentado anteriormente, la palabra "revocación" es un poco engañosa porque implica que la transacción "revocada" no puede ser utilizada.

De hecho, la transacción revocada puede ser usada, pero si es usada, y ha sido revocada, entonces uno de los socios del canal puede tomar todos los fondos del canal creando una transacción de penalización.

La forma en que esto funciona es que la salida `to_local` no sólo está bloqueada por el tiempo, sino que también tiene dos condiciones de gasto en el script: puede ser gastado por _self_ después del retraso del bloqueo de tiempo _o_ puede ser gastado por _remote_ inmediatamente con una clave de revocación para este compromiso.

Así, en nuestro ejemplo, cada lado mantiene una commitment transaction que incluye una opción de revocación en la salida `to_local`, como se muestra en <<asymmetric_delayed_revocable_1>>. 

[[asymmetric_delayed_revocable_1]]
.Asymmetric, delayed, and revocable commitments
image::images/mtln_0710.png["Asymmetric, delayed and revocable commitments"]

[[commitment_transaction]]
=== La commitment transaction.

Ahora que entendemos la estructura de las transacciones de compromiso y por qué necesitamos compromisos asimétricos, retrasados y revocables, veamos el Script de Bitcoin que implementa esto.

La primera salida (`to_local`) de una commitment transaction se define en https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#to_local-output[BOLT #3: Transacción de compromiso, salida `to_local`], como sigue:

----
OP_IF
    # Penalty transaction
    <revocationpubkey>
OP_ELSE
    <to_self_delay>
    OP_CHECKSEQUENCEVERIFY
    OP_DROP
    <local_delayedpubkey>
OP_ENDIF
OP_CHECKSIG
----

Este es un script condicional (ver <<conditional_scripts>>), lo que significa que la salida puede ser gastada si se cumple _cualquiera_ de las dos condiciones. La primera cláusula permite que la salida sea gastada por cualquiera que pueda firmar por +<revocationpubkey>+. La segunda cláusula está bloqueada por bloques +<to_self_delay>+ y sólo puede ser gastada después de ese número de bloques por cualquiera que pueda firmar por +<local_delayedpubkey>+. En nuestro ejemplo, habíamos establecido el bloqueo temporal de +<to_self_delay>+ en 432 bloques, pero éste es un retraso configurable que negocian los dos socios del canal. La duración de +to_self_delay+ timelock se suele elegir en proporción a la capacidad del canal, lo que significa que los canales de mayor capacidad (más fondos), tienen timelocks +to_self_delay+ más largos para proteger a las partes. 

La primera cláusula permite que la salida sea gastada por cualquiera que pueda firmar por +<revocationpubkey>+. Un requisito crítico para la seguridad de este script es que la parte remota _no_ pueda firmar unilateralmente con la `revocationpubkey`. Para ver por qué esto es importante, considere el escenario en el que la parte remota incumple un compromiso previamente revocado. Si pueden firmar con esta clave, entonces pueden simplemente tomar la cláusula de revocación _ellos mismos_ y robar todos los fondos en el canal. En su lugar, obtenemos la "clave de revocación" para cada estado basándonos en la información de la parte local y de la remota. Se utiliza un uso inteligente de la criptografía simétrica y asimétrica para permitir a ambas partes calcular la clave pública de la `revocationpubkey`, pero sólo permitir a la parte honesta del yo calcular la clave privada dada su información secreta, como se detalla en <<revocation_sidebar>>.

[[revocation_sidebar]]
.Revocation and Commitment Secret Derivations
****  
Cada parte envía un `revocation_basepoint` durante los mensajes iniciales de negociación del canal, así como un `first_per_commitment_point`. El `revocation_basepoint` es estático durante la vida del canal, mientras que cada nuevo estado del canal se basará en un nuevo `first_per_commitment_point`.

Dada esta información, la `revocationpubkey` para cada estado del canal se deriva a través de la siguiente serie de operaciones de curva elíptica y hashing: 

----
revocationpubkey = revocation_basepoint * sha256(revocation_basepoint || per_commitment_point) + per_commitment_point * sha256(per_commitment_point || revocation_basepoint)
----

Debido a la propiedad conmutativa de los grupos abelianos sobre los que se definen las curvas elípticas, una vez que el `per_commitment_secret` (la clave privada para el `per_commitment_point`) es revelado por la parte remota, uno mismo puede derivar la clave privada para la `revocationpubkey` con la siguiente operación: 

----
revocation_priv = (revocationbase_priv * sha256(revocation_basepoint || per_commitment_point)) + (per_commitment_secret * sha256(per_commitment_point || revocation_basepoint)) mod N
----

Para ver por qué esto funciona en la práctica, observa que podemos _reordenar_ (conmutar) y ampliar el cálculo de la clave pública de la fórmula original para `revocationpubkey`: 

```
revocationpubkey = G*(revocationbase_priv * sha256(revocation_basepoint || per_commitment_point) + G*(per_commitment_secret * sha256(per_commitment_point || revocation_basepoint))
                 = revocation_basepoint * sha256(revocation_basepoint || per_commitment_point) + per_commitment_point * sha256(per_commitment_point || revocation_basepoint))
```

En otras palabras, la `revocationbase_priv` sólo puede ser derivada (y utilizada para firmar la `revocationpubkey`) por la parte que conozca _tanto_ la `revocationbase_priv` _como_ el `per_commitment_secret`. Este pequeño truco es lo que hace que el sistema de revocación basado en la clave pública utilizado en la Lightning Network sea seguro. 
****

[TIP] 
==== 
El bloqueo de tiempo utilizado en la commitment transaction con +CHECKSEQUENCEVERIFY+ es un _bloqueo de tiempo relativo_. Cuenta los bloques transcurridos desde la confirmación de esta salida. Esto significa que no será gastable hasta el bloque +to_self_delay+ _después_ de que se emita y confirme esta commitment transaction. 
==== 

La segunda salida (to_remote) de la commitment transaction se define en https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#to_remote-output[BOLT #3: Commitment Transaction, `to_remote` Output], y en la forma más simple es un Pay-to-Witness-Public-Key-Hash (P2WPKH) para +<remote_pubkey>+, lo que significa que simplemente paga al propietario que puede firmar por +<remote_pubkey>+.

Ahora que hemos definido las transacciones de compromiso en detalle, veamos cómo Alice y Bob avanzan el estado del canal, crean y firman nuevas transacciones de compromiso, y revocan transacciones de compromiso antiguas.

=== Avanzando el estado del canal.

Para avanzar el estado del canal, Alice y Bob intercambian dos mensajes: Los mensajes +commitment_signed+ y +revoke_and_ack+. El mensaje +commitment_signed+ puede ser enviado por cualquiera de los dos socios del canal cuando tienen una actualización del estado del canal. El otro socio del canal puede entonces responder con +revoke_and_ack+ para _revocar_ el compromiso anterior y _acceder_ al nuevo compromiso.

En <<commitment_message_flow>> vemos a Alice y Bob intercambiando dos pares de "compromiso firmado" y "revocación y retorno". El primer flujo muestra una actualización de estado iniciada por Alice (de izquierda a derecha +commitment_signed+), a la que Bob responde (de derecha a izquierda +revoke_and_ack+). El segundo flujo muestra una actualización de estado iniciada por Bob y respondida por Alice.

[[commitment_message_flow]]
.Commitment and revocation message flow
image::images/mtln_0711.png[Commitment and revocation message flow]

==== El mensaje commitment_signed.

La estructura del mensaje +commitment_signed+ se define en https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#committing-updates-so-far-commitment_signed[BOLT #2: Peer Protocol, `commitment_signed`], y se muestra aquí:

[[commitment_signed_message]]
.The commitment_signed message
----
[channel_id:channel_id]
[signature:signature]
[u16:num_htlcs]
[num_htlcs*signature:htlc_signature]
----

+channel_id+:: El identificador del canal
+firma+:: La firma para el nuevo compromiso remoto
+num_htlcs+:: El número de HTLCs actualizados en este compromiso
+firma_htlc+:: Las firmas de las actualizaciones

[NOTE]
====
El uso de HTLCs para comprometer actualizaciones se explicará en detalle en <<htlcs>> y en <<channel_operation>>. 
====

El mensaje +commitment_signed+ de Alice da a Bob la firma necesaria (la parte de Alice del 2-de-2) para una nueva commitment transaction.

==== El mensaje revoke_and_ack.

Ahora que Bob tiene una nueva commitment transaction, puede revocar el compromiso anterior dando a Alice una clave de revocación, y construir el nuevo compromiso con la firma de Alice.

El mensaje +revoke_and_ack+ se define en https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#completing-the-transition-to-the-updated-state-revoke_and_ack[BOLT #2: Peer Protocol, `revoke_and_ack`], y se muestra aquí:

[[revoke_and_ack_message]]
.The revoke_and_ack message
----

[channel_id:channel_id]
[32*byte:per_commitment_secret]
[point:next_per_commitment_point]

----

+id_canal+:: Es el identificador del canal.
+per_commitment_secret+:: Se utiliza para generar una clave de revocación para el compromiso anterior (antiguo), revocándolo efectivamente.
+siguiente_por_compromiso+:: Se utiliza para construir una `revocation_pubkey` para el nuevo compromiso, de manera que pueda ser revocado posteriormente.

[[revocation]]
==== Revocación y Recompromiso.

Veamos esta interacción entre Alice y Bob más de cerca.

Alice está dando a Bob los medios para crear un nuevo compromiso. A cambio, Bob está revocando el antiguo compromiso para asegurar a Alice que no lo utilizará. Alice sólo puede confiar en el nuevo compromiso si tiene la clave de revocación para castigar a Bob por publicar el antiguo compromiso. Desde la perspectiva de Bob, él puede revocar con seguridad el antiguo compromiso dándole a Alice las claves para penalizarlo, porque tiene una firma para un nuevo compromiso.

Cuando Bob responde con +revoke_and_ack+, le da a Alice un +per_commitment_secret+. Este secreto se puede utilizar para construir la clave de firma de revocación para el antiguo compromiso, lo que permite a Alice apoderarse de todos los fondos del canal ejerciendo una penalización.

Tan pronto como Bob ha dado este secreto a Alice, él _no_ debe nunca difundir ese compromiso antiguo. Si lo hace, dará a Alice la oportunidad de penalizarlo tomando los fondos. Esencialmente, Bob está dando a Alice la capacidad de responsabilizarle por la difusión de un compromiso antiguo, y en efecto ha revocado su capacidad de usar ese compromiso antiguo.

Una vez que Alice ha recibido el +revoke_and_ack+ de Bob, puede estar segura de que Bob no puede emitir el antiguo compromiso sin ser penalizado. Ahora tiene las claves necesarias para crear una transacción de penalización si Bob difunde un compromiso antiguo.

[[revocation_secret_derivation]]
==== Engaño y penalización en la práctica.

En la práctica, tanto Alice como Bob tienen que vigilar que no se hagan trampas. Ellos están monitoreando el blockchain de Bitcoin para cualquier commitment transaction relacionada con cualquiera de los canales que están operando. Si ven una commitment transaction confirmada en la cadena, comprobarán si es el compromiso más reciente. Si es un compromiso "antiguo", deben construir y emitir inmediatamente una transacción de penalización. La transacción de penalización gasta _ambas_ salidas +a_local+ y +a_remota+, cerrando el canal y enviando ambos saldos al socio del canal engañado.

Para permitir más fácilmente a ambos lados llevar la cuenta de los números de compromiso de los compromisos de revocación pasados, cada compromiso realmente _codifica_ el número del compromiso dentro de los campos de tiempo de bloqueo y secuencia en una transición. Dentro del protocolo, esta codificación especial se denomina "pistas de estado". Asumiendo que una parte conoce el número de compromiso actual, es capaz de utilizar las pistas de estado para reconocer fácilmente si un compromiso emitido fue uno revocado, y si es así, qué número de compromiso fue violado, ya que ese número se utiliza para buscar fácilmente qué secreto de revocación debe ser utilizado en el árbol de secretos de revocación (shachain). 

En lugar de codificar la pista de estado a la vista, se utiliza una pista de estado _ofuscada_ en su lugar. Esta ofuscación se consigue primero XORando el número de compromiso actual con un conjunto de bytes aleatorios generados de forma determinista utilizando las claves públicas de financiación de ambos lados del canal. Un total de 6 bytes a través del tiempo de bloqueo y la secuencia (24 bits del tiempo de bloqueo y 24 bits de la secuencia) se utilizan para codificar la pista de estado dentro de la commitment transaction, por lo que se necesitan 6 bytes aleatorios para utilizar para la XOR. Para obtener estos 6 bytes, ambos lados obtienen el hash SHA-256 de la clave de financiación del iniciador concatenada con la clave de financiación del respondedor. Antes de codificar la altura de compromiso actual, el entero es XORizado con este ofuscador de pistas de estado, y luego codificado en los 24 bits inferiores del tiempo de bloqueo, y los 64 bits superiores de la secuencia.

Revisemos nuestro canal entre Alice y Bob y mostremos un ejemplo específico de una transacción de penalización. En <<competing_commitments_2>> vemos los cuatro compromisos en el canal de Alice y Bob. Alice ha hecho tres pagos a Bob:

* 70.000 satoshis pagados y comprometidos con Bob con el Compromiso #1
* 10.000 satoshis pagados y comprometidos con Bob con el Compromiso #2
* 20.000 satoshis pagados y comprometidos con Bob con el Compromiso #3

[[competing_commitments_2]]
.Revoked and current commitments
image::images/mtln_0712.png[Revoked and current commitments]

Con cada compromiso, Alice ha revocado el compromiso anterior (más antiguo). El estado actual del canal y el balance correcto está representado por el compromiso #3. Todos los compromisos anteriores han sido revocados, y Bob tiene las claves necesarias para emitir transacciones de penalización contra ellos, en caso de que Alice intente emitir uno de ellos.

Alice podría tener un incentivo para hacer trampa porque todas las transacciones de compromiso anteriores le darían una proporción mayor del balance del canal que la que le corresponde. Digamos, por ejemplo, que Alice intenta emitir el compromiso nº 1. Esa commitment transaction pagaría a Alice 70.000 satoshis y a Bob 70.000 satoshis. Si Alicia pudiera emitir y gastar su salida +to_local+, estaría robando efectivamente 30.000 satoshis a Bob al retroceder sus dos últimos pagos a Bob.

Alice decide correr un gran riesgo y emitir el Compromiso #1 revocado, para robarle 30.000 satoshis a Bob. En <<cheating_commitment>> vemos el antiguo compromiso de Alice que difunde a la blockchain de Bitcoin. 

[[cheating_commitment]]
.Alice cheating
image::images/mtln_0713.png[Alice cheating]

Como puedes ver, el antiguo compromiso de Alice tiene dos salidas, una pagándose a sí misma 70.000 satoshis (salida +to_local+) y otra pagando a Bob 70.000 satoshis. Alice aún no puede gastar su salida de 70.000 +a_local+ porque tiene un bloqueo de tiempo de 432 bloques (3 días). Ahora espera que Bob no se dé cuenta hasta dentro de tres días.

Desafortunadamente para Alice, el nodo de Bob está monitoreando diligentemente el blockchain de Bitcoin y ve una commitment transaction antigua difundida y (eventualmente) confirmada en la cadena.

El nodo de Bob emitirá inmediatamente una transacción de penalización. Como este antiguo compromiso fue revocado por Alice, Bob tiene el +per_commitment_secret+ que Alice le envió. Utiliza ese secreto para construir una firma para la +revocation_pubkey+. Mientras que Alice tiene que esperar 432 bloques, Bob puede gastar _ambas+ salidas inmediatamente. Puede gastar la salida de +to_remote+ con sus claves privadas porque estaba destinada a pagarle de todos modos. También puede gastar la salida destinada a Alice con una firma de la clave de revocación. Su nodo difunde la transacción de penalización mostrada en <<penalty_transaction>>. 

[[penalty_transaction]]
.Cheating and penalty
image::images/mtln_0714.png[Cheating and penalty]

La transacción de penalización de Bob paga 140.000 satoshis a su propio monedero, llevándose toda la capacidad del canal. Alice no sólo ha fallado en hacer trampa, ¡ha perdido todo en el intento!

==== La reserva del canal: Asegurando la Piel en el Juego.

Se habrá dado cuenta de que hay una situación especial que hay que tratar. Si Alicia pudiera seguir gastando su balance hasta que fuera cero, estaría en condiciones de cerrar el canal emitiendo una commitment transaction antigua sin arriesgarse a una penalización: o bien la commitment transaction revocada tiene éxito tras el retraso, o bien el tramposo es descubierto pero no hay consecuencias porque la penalización es cero. Desde la perspectiva de la teoría de los juegos, es dinero gratis intentar hacer trampa en esta situación. Por eso está en juego la reserva del canal, de modo que un posible tramposo siempre se enfrenta al riesgo de una penalización.

=== Cerrando el Canal (Cierre Cooperativo).

Hasta ahora hemos visto las transacciones de compromiso como una forma posible de cerrar un canal, unilateralmente. Este tipo de cierre de canal no es ideal porque obliga a un bloqueo de tiempo al socio del canal que lo utiliza.

Una mejor manera de cerrar un canal es el cierre cooperativo. En un cierre cooperativo, los dos socios del canal negocian una commitment transaction final llamada _transacción de cierre_ que paga a cada parte su balance inmediatamente al monedero de destino de su elección. Entonces, el socio que inició el flujo de cierre del canal emitirá la transacción de cierre.

El flujo de mensajes de cierre se define en https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#channel-close[BOLT #2: Peer Protocol, Channel Close], y se muestra en <<closing_message_flow>>.  

[[closing_message_flow]]
.The channel close message flow
image::images/mtln_0715.png[The channel close message flow]

[[theShutdownmessage]]
==== El mensaje de cierre.

El cierre del canal comienza con uno de los dos socios del canal enviando el mensaje +shutdown+. El contenido de este mensaje se muestra aquí:

[[shutdown_message]]
.The shutdown message
----

[channel_id:channel_id]
[u16:len]
[len*byte:scriptpubkey]

----

+channel_id+:: El identificador del canal que queremos cerrar
+len+:: La longitud del script del monedero de destino que este socio del canal quiere recibir su balance
+scriptpubkey+:: Un script de Bitcoin del monedero de destino, en uno de los formatos de dirección de Bitcoin "estándar" (P2PKH, P2SH, P2WPKH, P2WSH, etc.; ver el <<glossary>>)

Digamos que Alice envía el mensaje +shutdown+ a Bob para cerrar su canal. Alice especificará un script de Bitcoin que corresponde a la dirección de Bitcoin de su billetera. Ella le dice a Bob: vamos a hacer una transacción de cierre que pague mi balance a esta billetera. 

Bob responderá con su propio mensaje de +cierre+ indicando que está de acuerdo en cerrar cooperativamente el canal. Su mensaje de +cierre+ incluye el script de la dirección de su monedero.

Ahora tanto Alice como Bob tienen la dirección de billetera preferida del otro, y pueden construir transacciones de cierre idénticas para liquidar el balance del canal.

==== El mensaje "closing_signed".

Asumiendo que el canal no tiene compromisos o actualizaciones pendientes y que los socios del canal han intercambiado los mensajes de +cierre+ mostrados en la sección anterior, ahora pueden terminar este cierre cooperativo.

El _funder_ del canal (Alice en nuestro ejemplo) comienza enviando un mensaje +closing_signed+ a Bob. Este mensaje propone una tarifa de transacción para la transacción en la cadena, y la firma de Alice (la multisig de 2 de 2) para la transacción de cierre. El mensaje +closing_signed+ se muestra aquí:

[[closing_signed_message]]
.The closing_signed message
----
[channel_id:channel_id]
[u64:fee_satoshis]
[signature:signature]
----


+channel_id+:: El identificador del canal
+fee_satoshis+:: La tarifa de transacción propuesta en la cadena, en satoshis
+firma+:: La firma del remitente para la transacción de cierre

Cuando Bob recibe esto, puede responder con un mensaje +closing_signed+ propio. Si está de acuerdo con la tarifa, simplemente devuelve la misma tarifa propuesta y su propia firma. Si no está de acuerdo, debe proponer una tarifa diferente.

Esta negociación puede continuar con mensajes de +firma de cierre+ hasta que los dos socios del canal lleguen a un acuerdo sobre la tarifa.

Una vez que Alice recibe un mensaje +closing_signed+ con la misma tarifa que propuso en su último mensaje, la negociación ha finalizado. Alice firma y transmite la transacción de cierre y el canal se cierra.

==== La transacción de cierre cooperativo.

La transacción de cierre cooperativo es similar a la última commitment transaction que Alice y Bob habían acordado. Sin embargo, a diferencia de la última commitment transaction, no tiene llaves de tiempo o de revocación de penalización en los resultados. Dado que ambas partes cooperan para producir esta transacción y no van a hacer más compromisos, no hay necesidad de los elementos asimétricos, retrasados y revocables en esta transacción.

Normalmente, las direcciones utilizadas en esta transacción de cierre cooperativo se generan de forma reciente para cada canal que se cierra. Sin embargo, también es posible que ambas partes _bloqueen_ una dirección de "entrega" que se utilizará para enviar sus fondos liquidados de forma cooperativa. Dentro del espacio de nombres TLV de los mensajes `open_channel` y `accept_channel`, ambas partes son libres de especificar un "script de cierre por adelantado". Comúnmente, esta dirección se deriva de las claves que residen en el cold storage. Esta práctica sirve para aumentar la seguridad de los canales: si un socio del canal es pirateado de alguna manera, el pirata no puede cerrar el canal de forma cooperativa utilizando una dirección que controla. En cambio, el socio de canal honesto no comprometido se negará a cooperar en el cierre de un canal si no se utiliza la dirección de cierre especificada por adelantado. Esta característica crea efectivamente un "bucle cerrado", restringiendo el flujo de fondos fuera de un canal dado.

Alice emite una transacción mostrada en <<closing_transaction>> para cerrar el canal. 

[[closing_transaction]]
.The cooperative close transaction
image::images/mtln_0716.png[The cooperative close transaction]

Tan pronto como esta transacción de cierre es confirmada en el blockchain de Bitcoin, el canal se cierra. Ahora, Alice y Bob pueden gastar sus resultados como quieran. 

=== Conclusión.

En esta sección hemos examinado los canales de pago con mucho más detalle. Hemos examinado tres flujos de mensajes utilizados por Alice y Bob para negociar la financiación, los compromisos y el cierre del canal. También mostramos la estructura de las transacciones de financiación, compromiso y cierre, y vimos los mecanismos de revocación y penalización.

Como veremos en los próximos capítulos, las HTLCs se utilizan incluso para los pagos locales entre los socios del canal. No son necesarios, pero el protocolo es mucho más sencillo si los pagos locales (un canal) y enrutados (muchos canales) se realizan de la misma manera.

En un único payment channel, el número de pagos por segundo sólo está limitado por la capacidad de la red entre Alice y Bob. Mientras los socios del canal sean capaces de enviar unos pocos bytes de datos de ida y vuelta para acordar un nuevo balance del canal, habrán realizado efectivamente un pago. Esta es la razón por la que podemos lograr un rendimiento mucho mayor de los pagos en la Lightning Network (fuera de la cadena) que el rendimiento de las transacciones que puede manejar la blockchain de Bitcoin (en la cadena).

En los próximos capítulos discutiremos el enrutamiento, los HTLC y su uso en las operaciones de la cadena.


[[routing]]
== Enrutamiento en una red de canales de pago.

En este capítulo desvelaremos finalmente cómo los canales de pago pueden conectarse para formar una red de canales de pago a través de un proceso llamado _routing_. En concreto, estudiaremos la primera parte de la capa de enrutamiento, el protocolo "Contratos atómicos y multisaltos sin confianza". Esto se destaca mediante un esquema en el conjunto de protocolos, que se muestra en <<LN_protocol_routing_highlight>>.

[[LN_protocol_routing_highlight]]
.Atomic payment routing in the Lightning protocol suite
image::images/mtln_0801.png["Atomic payment routing in the Lightning protocol suite"]

=== Enrutamiento de un pago.

En esta sección examinaremos el enrutamiento desde la perspectiva de Dina, una jugadora que recibe donaciones de sus fans mientras transmite sus sesiones de juego.

La innovación de los canales de pago enrutados permite a Dina recibir propinas sin tener que mantener un canal separado con cada uno de sus fans que quieran darle una propina.
Mientras exista un camino de canales bien financiados desde ese espectador hasta Dina, ella podrá recibir el pago de ese fan.

En <<dina_routing_diagram>> vemos un posible esquema de red creado por varios canales de pago entre nodos de Lightning. Todos los que aparecen en este diagrama pueden enviar un pago a Dina construyendo una ruta. Imagina que Fan 4 quiere enviar un pago a Dina. ¿Ves el camino que podría permitirlo? Fan 4 podría enviar un pago a Dina a través de Fan 3, Bob y Chan. Del mismo modo, Alice podría enrutar un pago a Dina a través de Bob y Chan.

[[dina_routing_diagram]]
.Fans connected (in)directly to Dina on the Lightning Network
image::images/mtln_0802.png["Fans connected (in)directly to Dina on the Lightning Network"]

Los nodos a lo largo de la ruta desde el ventilador hasta Dina son intermediarios llamados _nodos de enrutamiento_ en el contexto del enrutamiento de un pago. No hay ninguna diferencia funcional entre los nodos de enrutamiento y los nodos operados por los fans de Dina. Cualquier nodo Lightning es capaz de enrutar pagos a través de sus canales de pago.

Es importante destacar que los nodos de enrutamiento no pueden robar los fondos mientras enrutan un pago de un fan a Dina.
Además, los nodos de enrutamiento no pueden perder dinero mientras participan en el proceso de enrutamiento.
Los nodos de enrutamiento pueden cobrar una tasa de enrutamiento por actuar como intermediarios, aunque no tienen por qué hacerlo y pueden optar por enrutar los pagos de forma gratuita.

Otro detalle importante es que, debido al uso del onion routing, los nodos intermediarios sólo conocen explícitamente el nodo que les precede y el que les sigue en la ruta.
No saben necesariamente quién es el remitente y el destinatario del pago.
Esto permite a los aficionados utilizar nodos intermediarios para pagar a Dina, sin filtrar información privada y sin riesgo de robo.

Este proceso de conectar una serie de canales de pago con seguridad de extremo a extremo, y la estructura de incentivos para que los nodos _remitan_ los pagos, es una de las innovaciones clave de la Lightning Network.

En este capítulo nos adentraremos en el mecanismo de enrutamiento de la Lightning Network, detallando la forma precisa en que los pagos fluyen a través de la red. En primer lugar, aclararemos el concepto de enrutamiento y lo compararemos con el de pathfinding, ya que a menudo se confunden y se utilizan indistintamente. A continuación, construiremos el protocolo de equidad: un protocolo atómico, sin confianza y con varios saltos que se utiliza para enrutar los pagos. Para demostrar cómo funciona este protocolo de equidad, utilizaremos un equivalente físico de transferencia de monedas de oro entre cuatro personas. Por último, examinaremos la implementación del protocolo atómico, sin confianza y con múltiples saltos que se utiliza actualmente en la Lightning Network, que se denomina contrato con bloqueo temporal (HTLC). 

=== Enrutamiento versus Pathfinding.

Es importante señalar que separamos el concepto de _routing_ del concepto de _pathfinding_. Estos dos conceptos se confunden a menudo, y el término _routing_ se utiliza a menudo para describir ambos conceptos. Eliminemos la ambigüedad antes de seguir adelante.

La búsqueda de rutas, que se trata en <<path_finding>>, es el proceso de encontrar y elegir una ruta contigua hecha de canales de pago que conecte al remitente A con el destinatario B. El remitente de un pago hace la búsqueda de rutas examinando el "gráfico de canales" que ha reunido a partir de los anuncios de canales cotilleados por otros nodos.

El enrutamiento se refiere a la serie de interacciones a través de la red que intentan reenviar un pago desde un punto A a otro punto B, a través de la ruta previamente seleccionada por el pathfinding. El enrutamiento es el proceso activo de envío de un pago en una ruta, que implica la cooperación de todos los nodos intermediarios a lo largo de esa ruta.

Una regla importante es que es posible que exista un _camino_ entre Alicia y Bob (quizás incluso más de uno), pero que no haya una _ruta_ activa por la que enviar el pago. Un ejemplo es el escenario en el que todos los nodos que conectan a Alice y Bob están actualmente desconectados. En este ejemplo, se puede examinar el gráfico de canales y conectar una serie de canales de pago de Alicia a Bob, por lo que existe una _ruta_. Sin embargo, debido a que los nodos intermediarios están fuera de línea, el pago no puede ser enviado y por lo tanto no existe una _ruta_.

=== Creación de una red de canales de pago.

Antes de sumergirnos en el concepto de un pago atómico multisalto sin confianza, vamos a trabajar con un ejemplo.
Volvamos a Alice que, en los capítulos anteriores, compró un café a Bob con quien tiene un canal abierto.
Ahora Alice está viendo una retransmisión en directo de Dina, la jugadora, y quiere enviar a Dina una propina de 50.000 satoshis a través de la Lightning Network. Pero Alice no tiene un canal directo con Dina. ¿Qué puede hacer Alice?

Alice podría abrir un canal directo con Dina; sin embargo, eso requeriría liquidez y tasas en la cadena que podrían ser superiores al valor de la propina en sí. En su lugar, Alice puede utilizar sus canales abiertos existentes para enviar un consejo a Dina _sin_ la necesidad de abrir un canal directamente con Dina. Esto es posible, siempre y cuando exista alguna ruta de canales desde Alice hasta Dina con capacidad suficiente para enrutar la propina.

Como se puede ver en <<routing_network>>, Alice tiene un canal abierto con Bob, el dueño de la cafetería. Bob, a su vez, tiene un canal abierto con el desarrollador de software Chan, que le ayuda con el sistema de punto de venta que utiliza en su cafetería. Chan también es el propietario de una gran empresa de software que desarrolla el juego al que juega Dina, y ya tienen un canal abierto que Dina utiliza para pagar la licencia del juego y los objetos del mismo.

[[routing_network]]
.A network of payment channels between Alice and Dina
image::images/mtln_0803.png["A network of payment channels between Alice and Dina"]

Es posible trazar una _ruta_ desde Alice a Dina que utilice a Bob y Chan como nodos de enrutamiento intermedios.
Alice puede entonces elaborar una _ruta_ a partir de este camino trazado y utilizarla para enviar una propina de unos pocos miles de satoshis a Dina, siendo el pago _reenviado_ por Bob y Chan.
Esencialmente, Alice pagará a Bob, que pagará a Chan, que pagará a Dina. No se requiere un canal directo de Alice a Dina.

El principal reto es hacer esto de una manera que evite que Bob y Chan roben el dinero que Alice quiere entregar a Dina.

=== Un ejemplo físico de "enrutamiento".

Para entender cómo la Lightning Network protege el pago mientras se enruta, podemos compararlo con un ejemplo de enrutamiento de pagos físicos con monedas de oro en el mundo real.

Supongamos que Alicia quiere dar 10 monedas de oro a Dina, pero no tiene acceso directo a Dina. Sin embargo, Alice conoce a Bob, que conoce a Chan, que conoce a Dina, así que decide pedir ayuda a Bob y a Chan. Esto se muestra en <<alice_dina_routing_1>>.

[[alice_dina_routing_1]]
.Alice wants to pay Dina 10 gold coins
image::images/mtln_0804.png[]

Alice puede pagar a Bob para que pague a Chan para que pague a Dina, pero ¿cómo se asegura de que Bob o Chan no huyan con las monedas después de recibirlas?
En el mundo físico, los contratos podrían utilizarse para realizar una serie de pagos de forma segura. 

Alice podría negociar un contrato con Bob, que dice:

____
_Yo, Alice, te daré a ti, Bob, 10 monedas de oro si se las pasas a Chan._
____

Aunque este contrato es bonito en abstracto, en el mundo real, Alice corre el riesgo de que Bob incumpla el contrato y espere que no le pillen.
Incluso si Bob es atrapado y procesado, Alice se enfrenta al riesgo de que esté en bancarrota y no pueda devolverle sus 10 monedas de oro.
Suponiendo que estos problemas se resuelvan mágicamente, aún no está claro cómo aprovechar este contrato para lograr el resultado deseado: que las monedas se entreguen a Dina.

Mejoremos nuestro contrato para incorporar estas consideraciones:

____
_Yo, Alicia, te reembolsaré a ti, Bob, 10 monedas de oro si puedes demostrarme (por ejemplo, mediante un recibo) que has entregado 10 monedas de oro a Chan._
____

Podrías preguntarte por qué debería Bob firmar un contrato así.
Tiene que pagar a Chan, pero en última instancia no obtiene nada del intercambio, y corre el riesgo de que Alice no le reembolse. Bob podría ofrecer a Chan un contrato similar para pagar a Dina, pero igualmente Chan tampoco tiene motivos para aceptarlo.

Incluso dejando de lado el riesgo, Bob y Chan deben _ya_ tener 10 monedas de oro para enviar; de lo contrario, no podrían participar en el contrato.

Por lo tanto, Bob y Chan se enfrentan tanto al riesgo como al coste de oportunidad por aceptar este contrato, y tendrían que ser compensados para aceptarlo.

Alice puede entonces hacer esto atractivo tanto para Bob como para Chan ofreciéndoles honorarios de una moneda de oro cada uno, si transmiten su pago a Dina.

El contrato sería entonces:

____
_Yo, Alice, te reembolsaré a ti, Bob, con 12 monedas de oro si puedes demostrarme (por ejemplo, mediante un recibo) que has entregado 11 monedas de oro a Chan._
____

Alice promete ahora a Bob 12 monedas de oro. Hay 10 para entregar a Dina y 2 para los honorarios. Ella promete 12 a Bob si éste puede demostrar que ha entregado 11 a Chan.
La diferencia de una moneda de oro es la comisión que ganará Bob por ayudar en este pago concreto. En <<alice_dina_routing_2>> vemos cómo este acuerdo haría llegar 10 monedas de oro a Dina a través de Bob y Chan.

[[alice_dina_routing_2]]
.Alice pays Bob, Bob pays Chan, Chan pays Dina
image::images/mtln_0805.png[]

Because there is still the issue of trust and the risk that either Alice or Bob won't honor the contract, all parties decide to use an escrow service.
At the start of the exchange, Alice could "lock up" these 12 gold coins in escrow that will only be paid to Bob once he proves that he's paid 11 gold coins to Chan.

This escrow service is an idealized one, which does not introduce other risks (e.g., counterparty risk). Later we will see how we can replace the escrow with a Bitcoin smart contract. Let's assume for now that everyone trusts this escrow service.

In the Lightning Network, the receipt (proof of payment) could take the form of a secret that only Dina knows.
In practice, this secret would be a random number that is large enough to prevent others from guessing it (typically a _very, very_ large number, encoded using 256 bits!).

Dina generates this secret value +R+ from a random number generator.

The secret could then be committed to the contract by including the SHA-256 hash of the secret in the contract itself, as follows:

++++
<ul class="simplelist">
<li><em>H</em> = SHA-256(<em>R</em>)</li>
</ul>
++++

We call this hash of the payment's secret the _payment hash_.
The secret that "unlocks" the payment is called the _payment secret_.

Por ahora, mantenemos las cosas simples y asumimos que el secreto de Dina es simplemente la línea de texto: `Dinas secret`. Este mensaje secreto se denomina _secreto de pago_ o _preimagen de pago_.

To "commit" to this secret, Dina computes the SHA-256 hash, which when encoded in hexadecimal, can be displayed as follows:

----
0575965b3b44be51e8057d551c4016d83cb1fba9ea8d6e986447ba33fe69f6b3
----

To facilitate Alice's payment, Dina will create the payment secret and the payment hash, and send the payment hash to Alice. In <<alice_dina_routing_3>> we see that Dina sends the payment hash to Alice via some external channel (dashed line), such as an email or text message.

[[alice_dina_routing_3]]
.Dina sends the hashed secret to Alice
image::images/mtln_0806.png["Dina sends the hashed secret to Alice"]

Alice doesn't know the secret, but she can rewrite her contract to use the hash of the secret as a proof of payment:

____
_Yo, Alice, te reembolsaré a ti, Bob, con 12 monedas de oro si puedes mostrarme un mensaje válido cuyo hash sea:`057596`.... 
Puedes adquirir este mensaje estableciendo un contrato similar con Chan, que tiene que establecer un contrato similar con Dina. 
Para asegurarte de que se te reembolsará, proporcionaré las 12 monedas de oro a un depósito de confianza antes de que establezcas tu próximo contrato._
____

Este nuevo contrato ahora protege a Alice de que Bob no reenvíe a Chan, protege a Bob de no ser reembolsado por Alice, y asegura que habrá prueba de que Dina fue finalmente pagada a través del hash del secreto de Dina. 

Después de que Bob y Alice estén de acuerdo con el contrato, y Bob reciba el mensaje de la plica de que Alice ha depositado las 12 monedas de oro, Bob puede ahora negociar un contrato similar con Chan.

Obsérvese que, dado que Bob está aceptando una comisión de servicio de 1 moneda, sólo enviará 11 monedas de oro a Chan una vez que éste muestre la prueba de que ha pagado a Dina.
Del mismo modo, Chan también exigirá una cuota y esperará recibir 11 monedas de oro una vez que haya demostrado que ha pagado a Dina las 10 monedas de oro prometidas.

El contrato de Bob con Chan dirá:

____
_Yo, Bob, te reembolsaré a ti, Chan, 11 monedas de oro si puedes mostrarme un mensaje válido cuyo hash sea: `057596`....
Puedes adquirir este mensaje estableciendo un contrato similar con Dina.
Para asegurarte de que se te reembolsará, proporcionaré las 11 monedas de oro a un depósito de confianza antes de que establezcas tu próximo contrato._
____

Una vez que Chan recibe el mensaje de la plica de que Bob ha depositado las 11 monedas de oro, Chan establece un contrato similar con Dina:

____
_Yo, Chan, te reembolsaré, Dina, con 10 monedas de oro si puedes mostrarme un mensaje válido que tenga el hash de:`057596`....
Para asegurarte que se te reembolsará después de revelar el secreto, proporcionaré las 10 monedas de oro a un depósito de confianza._
____

Ahora todo está en su sitio.
Alice tiene un contrato con Bob y ha depositado 12 monedas de oro en un depósito de confianza.
Bob tiene un contrato con Chan y ha colocado 11 monedas de oro en depósito.
Chan tiene un contrato con Dina y ha depositado 10 monedas de oro.
Ahora le toca a Dina revelar el secreto, que es la imagen previa al hash que ha establecido como prueba de pago.

Dina envía ahora +el secreto de Dina+ a Chan.

Chan comprueba que +Secreto de Dina+ tiene un hash de +057596+.... Chan tiene ahora una prueba de pago y ordena al servicio de custodia que entregue las 10 monedas de oro a Dina.

Chan proporciona ahora el secreto a Bob. Bob lo comprueba y ordena al servicio de custodia que entregue las 11 monedas de oro a Chan.

Bob proporciona ahora el secreto a Alice.
Alice lo comprueba y ordena al servicio de custodia que libere las 12 monedas de oro a Bob.

Ahora todos los contratos están resueltos.
Alice ha pagado un total de 12 monedas de oro, 1 de las cuales fue recibida por Bob, 1 de las cuales fue recibida por Chan, y 10 de las cuales fueron recibidas por Dina.
Con una cadena de contratos como ésta, Bob y Chan no pudieron huir con el dinero porque lo depositaron primero en la plica.

Sin embargo, todavía queda un problema.
Si Dina se negara a liberar su preimagen secreta, entonces Chan, Bob y Alice tendrían sus monedas depositadas en escrow pero no serían reembolsadas.
Y del mismo modo, si cualquier otra persona a lo largo de la cadena no transmitiera el secreto, ocurriría lo mismo.
Así que, aunque nadie puede robarle dinero a Alice, todos seguirían teniendo su dinero atascado en la plica de forma permanente.

Por suerte, esto puede resolverse añadiendo un plazo al contrato.

Podríamos modificar el contrato para que, si no se cumple en un plazo determinado, el contrato caduque y el servicio de custodia devuelva el dinero a la persona que hizo el depósito original.
A este plazo lo llamamos "bloqueo de tiempo".

El depósito queda bloqueado en el servicio de custodia durante un tiempo determinado y, finalmente, se libera aunque no se haya presentado ninguna prueba de pago.

Para tener en cuenta esto, el contrato entre Alice y Bob se modifica de nuevo con una nueva cláusula:

____
_Bob tiene 24 horas para mostrar el secreto después de la firma del contrato.
Si Bob no proporciona el secreto en ese plazo, el depósito de Alice será devuelto por el servicio de custodia y el contrato quedará invalidado._
____

Bob, por supuesto, tiene que asegurarse de que recibe el comprobante de pago en 24 horas.
Aunque pague con éxito a Chan, si recibe el comprobante de pago más tarde de las 24 horas, no se le reembolsará. Para eliminar ese riesgo, Bob debe dar a Chan un plazo aún más corto.

A su vez, Bob modificará su contrato con Chan de la siguiente manera:

____
_Chan tiene 22 horas para mostrar el secreto después de la firma del contrato.
Si no proporciona el secreto en ese plazo, el depósito de Bob será devuelto por el servicio de custodia y el contrato quedará invalidado._
____

Como habrás adivinado, Chan también modificará su contrato con Dina:

____
_Dina tiene 20 horas para mostrar el secreto después de la firma del contrato.
Si no lo hace en ese tiempo, el depósito de Chan será devuelto por el servicio de custodia y el contrato quedará invalidado._
____

Con esta cadena de contratos podemos asegurar que, al cabo de 24 horas, el pago pasará con éxito de Alice a Bob, a Chan y a Dina, o fracasará y se reembolsará a todos.
O el contrato falla o tiene éxito, no hay término medio.

En el contexto de la Red Relámpago, llamamos a esta propiedad de "todo o nada" _atomicidad_.

Mientras la plica sea de confianza y cumpla fielmente con su deber, a ninguna de las partes le robarán sus monedas en el proceso.

La condición previa para que esta _ruta_ funcione del todo es que todas las partes del camino tengan suficiente dinero para satisfacer la serie de depósitos requeridos. 

Aunque parece un detalle menor, más adelante veremos que este requisito es en realidad uno de los problemas más difíciles para los nodos LN.
Se vuelve progresivamente más difícil a medida que aumenta el tamaño del pago.
Además, las partes no pueden utilizar su dinero mientras esté bloqueado en el depósito.

Así, los usuarios que envían pagos se enfrentan a un coste de oportunidad por bloquear el dinero, que en última instancia se reembolsa a través de las fees de enrutamiento, como vimos en el ejemplo anterior.

Ahora que hemos visto un ejemplo de enrutamiento de pagos físicos, veremos cómo esto puede ser implementado en la blockchain de Bitcoin, sin necesidad de una custodia de terceros. Para ello estableceremos los contratos entre los participantes utilizando Bitcoin Script. Reemplazamos la custodia de terceros con _contratos inteligentes_ que implementan un protocolo de equidad. Desglosemos este concepto y pongámoslo en práctica.

=== Protocolo de equidad.

Como vimos en el primer capítulo de este libro, la innovación de Bitcoin es la capacidad de utilizar primitivas criptográficas para implementar un protocolo de equidad que sustituye la confianza en terceros (intermediarios) por un protocolo de confianza.

En nuestro ejemplo de las monedas de oro, necesitábamos un servicio de custodia para evitar que cualquiera de las partes renegara de sus obligaciones. La innovación de los protocolos criptográficos de equidad nos permite sustituir el servicio de custodia por un protocolo.

Las propiedades del protocolo de equidad que queremos crear son

Funcionamiento sin confianza:: Los participantes en un pago enrutado no necesitan confiar entre sí, ni en ningún intermediario o tercero. En su lugar, confían en el protocolo para que les proteja de las trampas.

Atomicidad:: O bien el pago se ejecuta por completo, o bien fracasa y todos son reembolsados. No existe la posibilidad de que un intermediario recoja un pago enrutado y no lo reenvíe al siguiente salto. Así, los intermediarios no pueden hacer trampas ni robar.

Salto múltiple:: La seguridad del sistema se extiende de extremo a extremo para los pagos enrutados a través de múltiples canales de pago, al igual que para un pago entre los dos extremos de un único payment channel.

Una propiedad adicional y opcional es la capacidad de dividir los pagos en múltiples partes, manteniendo la atomicidad para todo el pago. Esto se denomina _pagos en varias partes_ (_MPP_) y se explora con más detalle en <<mpp>>.

==== Implementación de pagos atómicos de confianza multi-salto.

Bitcoin Script es lo suficientemente flexible como para que haya docenas de maneras de implementar un protocolo de equidad que tenga las propiedades de atomicidad, operación sin confianza y seguridad multisalto. La elección de una implementación específica depende de ciertas compensaciones entre la privacidad, la eficiencia y la complejidad.

El protocolo de equidad para el enrutamiento que se utiliza actualmente en la Lightning Network se denomina contrato de tiempo bloqueado (HTLC). Los HTLC utilizan una preimagen de hash como el secreto que desbloquea un pago, como vimos en el ejemplo de la moneda de oro en este capítulo. El receptor de un pago genera un número secreto aleatorio y calcula su hash. El hash se convierte en la condición del pago, y una vez revelado el secreto, todos los participantes pueden canjear sus pagos entrantes. Las HTLC ofrecen atomicidad, funcionamiento sin confianza y seguridad multisalto.

Otro mecanismo propuesto para implementar el enrutamiento es un _Contrato de Tiempo Bloqueado_ (_PTLC_). Los PTLC también consiguen la atomicidad, el funcionamiento sin confianza y la seguridad multisalto, pero lo hacen con mayor eficiencia y mejor privacidad.  La implementación eficiente de los PTLC depende de un nuevo algoritmo de firma digital llamado _Schnorr signatures_, que se espera que se active en Bitcoin en 2021.

=== Revisando el ejemplo de la propina.

Revisemos nuestro ejemplo de la primera parte de este capítulo. Alice quiere dar una propina a Dina con un Lightning payment. Digamos que Alice quiere enviar a Dina 50.000 satoshis como propina.

Para que Alice pague a Dina, necesitará que el nodo de Dina genere una invoice Lightning. Discutiremos esto con más detalle en <<invoices>>. Por ahora, vamos a suponer que Dina tiene un sitio web que puede producir una invoice Lightning para las propinas.

[TIP]
====
Los pagos de Lightning se pueden enviar sin invoice utilizando una función llamada _keysend_, de la que hablaremos con más detalle en <<keysend>>. Por ahora, explicaremos el flujo de pago más sencillo utilizando una invoice.
====

Alice visita el sitio de Dina, introduce la cantidad de 50.000 satoshis en un formulario y, como respuesta, el nodo Lightning de Dina genera una solicitud de pago de 50.000 satoshis en forma de invoice Lightning. Esta interacción tiene lugar a través de la web y fuera de la Lightning Network, como se muestra en <<alice_dina_invoice_1>>.

[[alice_dina_invoice_1]]
.Alice requests an invoice from Dina's website
image::images/mtln_0807.png["Alice requests an invoice from Dina's website"] 

Como hemos visto en los ejemplos anteriores, suponemos que Alice no tiene un payment channel directo con Dina. En su lugar, Alice tiene un canal con Bob, Bob tiene un canal con Chan, y Chan tiene un canal con Dina. Para pagar a Dina, Alice debe encontrar un camino que la conecte con Dina. Discutiremos este paso con más detalle en "path_finding". Por ahora, vamos a suponer que Alice es capaz de reunir información sobre los canales disponibles y ve que hay un camino de ella a Dina, a través de Bob y Chan.

[NOTE]
====
¿Recuerdas que Bob y Chan podrían esperar una pequeña compensación por enrutar el pago a través de sus nodos? Alice quiere pagar a Dina 50.000 satoshis, pero como verás en las siguientes secciones enviará a Bob 50.200 satoshis. Con los 200 satoshis extra pagará a Bob y a Chan 100 satoshis a cada uno, como tarifa de enrutamiento.
====

Ahora, el nodo de Alice puede construir un Lightning payment. En las próximas secciones, veremos cómo el nodo de Alice construye un HTLC para pagar a Dina y cómo ese HTLC se reenvía a lo largo de la ruta de Alice a Dina.


==== Liquidación de HTLCs en la cadena y fuera de ella.

El propósito de la Lightning Network es permitir las transacciones _fuera de la cadena_ que son de confianza al igual que las transacciones en la cadena porque nadie puede hacer trampa. La razón por la que nadie puede hacer trampa es porque en cualquier momento, cualquiera de los participantes puede llevar sus transacciones fuera de la cadena a la cadena. Cada transacción fuera de la cadena está lista para ser enviada a la blockchain de Bitcoin en cualquier momento. Así, la blockchain de Bitcoin actúa como mecanismo de resolución de disputas y de liquidación final si es necesario.

El mero hecho de que cualquier transacción pueda ser llevada a la cadena en cualquier momento es precisamente la razón por la que todas esas transacciones pueden mantenerse fuera de la cadena. Si se sabe que se puede recurrir, se puede seguir cooperando con los demás participantes y evitar la necesidad de la liquidación en la cadena y las comisiones adicionales.

En todos los ejemplos que siguen, asumiremos que cualquiera de estas transacciones puede realizarse en la cadena en cualquier momento. Los participantes elegirán mantenerlas fuera de la cadena, pero no hay ninguna diferencia en la funcionalidad del sistema, aparte de las tasas más altas y el retraso impuesto por la minería en la cadena de las transacciones. El ejemplo funciona igual si todas las transacciones son on-chain o off-chain.

[[htlcs]]
=== Contratos Hash Time-Locked.

En esta sección explicamos cómo funcionan los HTLCs.

La primera parte de un HTLC es el _hash_. This refers to the use of a cryptographic hash algorithm to commit to a randomly generated secret. Knowledge of the secret allows redemption of the payment. The cryptographic hash function guarantees that while it's infeasible for anyone to guess the secret preimage, it's easy for anyone to verify the hash, and there's only one possible preimage that resolves the payment condition.

In <<alice_dina_invoice_2>> we see Alice getting a Lightning invoice from Dina. Inside that invoice Dina's secret is called the _payment preimage_. The payment hash acts as an identifier that can be used to route the payment to Dina. The payment preimage acts as a receipt and proof of payment once the payment is complete.

[[alice_dina_invoice_2]]
.Alice gets a payment hash from Dina
image::images/mtln_0808.png["Alice gets a payment hash from Dina"]

In the Lightning Network, Dina's payment preimage won't be a phrase like +Dinas secret+ but a random number generated by Dina's node. Let's call that random number _R_.

Dina's node will calculate a cryptographic hash of _R_, such that:

++++
<ul class="simplelist">
<li><em>H</em> = SHA-256(<em>R</em>)</li>
</ul>
++++

In this equation, _H_ is the hash, or _payment hash_ and _R_ is the secret or _payment preimage_.

The use of a cryptographic hash function is one element that guarantees _trustless operation_. The payment intermediaries do not need to trust each other because they know that no one can guess the secret or fake it.

==== HTLCs in Bitcoin Script.

In our gold coin example, Alice had a contract enforced by escrow like this:

____
_Alice will reimburse Bob with 12 gold coins if you can show a valid message that hashes to:_ +0575...f6b3+. _Bob has 24 hours to show the secret after the contract was signed. If Bob does not provide the secret by this time, Alice's deposit will be refunded by the escrow service and the contract becomes invalid._
____

[role="pagebreak-before"]
Let's see how we would implement this as an HTLC in Bitcoin Script. In <<received_htlc>> we see an HTLC Bitcoin Script as currently used in the Lightning Network. You can find this definition in https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#offered-htlc-outputs[BOLT #3, Transactions].

[[received_htlc]]
.HTLC implemented in Bitcoin Script (BOLT #3)
[source,text,linenums]
====
----
# To remote node with revocation key
OP_DUP OP_HASH160 <RIPEMD160(SHA256(revocationpubkey))> OP_EQUAL
OP_IF
    OP_CHECKSIG
OP_ELSE
    <remote_htlcpubkey> OP_SWAP OP_SIZE 32 OP_EQUAL
    OP_IF
        # To local node via HTLC-success transaction.
        OP_HASH160 <RIPEMD160(payment_hash)> OP_EQUALVERIFY
        2 OP_SWAP <local_htlcpubkey> 2 OP_CHECKMULTISIG
    OP_ELSE
        # To remote node after timeout.
        OP_DROP <cltv_expiry> OP_CHECKLOCKTIMEVERIFY OP_DROP
        OP_CHECKSIG
    OP_ENDIF
OP_ENDIF
----
====

Vaya, parece complicado. Pero no te preocupes, vamos a ir paso a paso y a simplificarlo.

El Script de Bitcoin utilizado actualmente en la Lightning Network es bastante complejo porque está optimizado para la eficiencia del espacio en la cadena, lo que lo hace muy compacto pero difícil de leer. 

En las siguientes secciones, nos centraremos en los elementos principales de la secuencia de comandos y presentaremos secuencias de comandos simplificadas que son ligeramente diferentes de lo que se utiliza realmente en Lightning.

La parte principal del HTLC está en la línea 10 de <<received_htlc>>. ¡Vamos a construirlo desde cero!

==== Preimagen de pago y verificación del hash.

El núcleo de un HTLC es el hash, donde el pago puede realizarse si el receptor conoce la preimagen de pago. Alice bloquea el pago a un hash de pago específico, y Bob tiene que presentar una preimagen de pago para reclamar los fondos. El sistema Bitcoin puede verificar que la preimagen de pago de Bob es correcta haciendo un hash y comparando el resultado con el hash de pago que Alice utilizó para bloquear los fondos.

Esta parte de un HTLC puede ser implementada en Bitcoin Script como sigue:

----
OP_SHA256 <H> OP_EQUAL
----

Alice puede crear una salida de transacción que paga, 50.200 satoshi con un script de bloqueo arriba, reemplazando `<H>` con el valor hash +0575...f6b3+ proporcionado por Dina. Entonces, Alice puede firmar esta transacción y ofrecerla a Bob:

.Alice ofrece un HTLC de 50.200 satoshi a Bob
----
OP_SHA256 0575...f6b3 OP_EQUAL
----

Bob no puede gastar este HTLC hasta que conozca el secreto de Dina, por lo que gastar el HTLC está condicionado a que Bob cumpla con el pago hasta Dina.

Una vez que Bob tiene el secreto de Dina, Bob puede gastar esta salida con un script de desbloqueo que contenga el valor de la preimagen secreta _R_.

El script de desbloqueo combinado con el script de bloqueo produciría

----
<R> OP_SHA256 <H> OP_EQUAL
----

El motor de Bitcoin Script evaluaría este script de la siguiente manera:

1. +R+ se empuja a la pila.
2. El operador `OP_SHA256` toma el valor +R+ de la pila y lo convierte en hash, empujando el resultado +H~R~+ a la pila.
3. 3. Se empuja +H+ a la pila.
4. El operador `OP_EQUAL` compara +H+ y +H~R~+. Si son iguales, el resultado es +TRUE+, el script se completa y se verifica el pago.

==== Extendiendo HTLCs de Alice a Dina.

Alice ahora extenderá el HTLC a través de la red para que llegue a Dina.

En <<alice_dina_htlc_1>>, vemos el HTLC propagado a través de la red desde Alice a Dina. Alice ha dado a Bob un HTLC por 50.200 satoshi. Bob puede ahora crear un HTLC por 50.100 satoshi y dárselo a Chan.

Bob sabe que Chan no puede canjear el HTLC de Bob sin transmitir el secreto, momento en el que Bob también puede utilizar el secreto para canjear el HTLC de Alice. Este es un punto realmente importante porque asegura la _atomicidad_ de extremo a extremo del HTLC. Para gastar el HTLC, uno necesita revelar el secreto, lo que hace posible que otros gasten también su HTLC. O todos los HTLCs son gastables, o ninguno de los HTLCs es gastable: ¡atomicidad!

Debido a que el HTLC de Alice es 100 satoshi más que el HTLC que Bob le dio a Chan, Bob ganará 100 satoshi como tarifa de enrutamiento si este pago se completa.

Bob no está tomando un riesgo y no está confiando en Alice o Chan. En cambio, Bob está confiando en que una transacción firmada junto con el secreto será canjeable en el blockchain de Bitcoin.

[[alice_dina_htlc_1]]
.Propagating the HTLC across the network
image::images/mtln_0809.png["Propagating the HTLC across the network"]

Del mismo modo, Chan puede extender un HTLC de 50.000 a Dina. No arriesga nada ni confía en Bob o Dina. Para canjear el HTLC, Dina tendría que difundir el secreto, que Chan podría utilizar para canjear el HTLC de Bob. Chan también ganaría 100 satoshis como tarifa de enrutamiento.

==== Retropropagando el secreto.

Una vez que Dina recibe un HTLC de 50.000 de Chan, ahora puede cobrar. Dina podría simplemente comprometer este HTLC en la cadena y gastarlo revelando el secreto en la transacción de gasto. O, en su lugar, Dina puede actualizar el balance del canal con Chan dándole el secreto. No hay ninguna razón para incurrir en una tarifa de transacción e ir a la cadena. Así que, en su lugar, Dina envía el secreto a Chan, y acuerdan actualizar sus saldos de canal para reflejar un pago de 50.000 satoshi Lightning a Dina. En <<alice_dina_htlc_redeem_1>> vemos a Dina dando el secreto a Chan, cumpliendo así el HTLC.

[[alice_dina_htlc_redeem_1]]
.Dina settles Chan's HTLC off-chain
image::images/mtln_0810.png["Dina settles Chan's HTLC off-chain"]

Observa que el balance del canal de Dina pasa de 50.000 satoshi a 100.000 satoshi. El balance del canal de Chan se reduce de 200.000 satoshi a 150.000 satoshi. La capacidad del canal no ha cambiado, pero 50.000 se han movido del lado del canal de Chan al lado del canal de Dina.

Chan tiene ahora el secreto y ha pagado a Dina 50.000 satoshi. Puede hacer esto sin ningún riesgo, porque el secreto permite a Chan canjear los 50.100 HTLC de Bob. Chan tiene la opción de comprometer ese HTLC en la cadena y gastarlo revelando el secreto en la blockchain de Bitcoin. Pero, al igual que Dina, prefiere evitar los gastos de transacción. Así que en lugar de eso, envía el secreto a Bob para que puedan actualizar sus saldos de canal para reflejar un Lightning payment de 50.100 satoshi de Bob a Chan. En <<alice_dina_htlc_redeem_2>> vemos a Chan enviando el secreto a Bob y recibiendo un pago a cambio. 

[[alice_dina_htlc_redeem_2]]
.Chan settles Bob's HTLC off-chain
image::images/mtln_0811.png["Chan settles Bob's HTLC off-chain"]

Chan ha pagado a Dina 50.000 satoshi, y ha recibido 50.100 satoshi de Bob. Así que Chan tiene 100 satoshi más en los saldos de su canal, que ganó como tarifa de enrutamiento.

Bob ahora también tiene el secreto. Puede usarlo para gastar el HTLC de Alice en la cadena. O bien, puede evitar las tasas de transacción mediante la liquidación de la HTLC en el canal con Alice. En <<alice_dina_htlc_redeem_3>> vemos que Bob envía el secreto a Alice y actualizan el balance del canal para reflejar un pago de 50.200 satoshi Lightning de Alice a Bob.

[[alice_dina_htlc_redeem_3]]
.Bob settles Alice's HTLC off-chain
image::images/mtln_0812.png["Bob settles Alice's HTLC off-chain"]

Bob ha recibido 50.200 satoshi de Alice y ha pagado 50.100 satoshi a Chan, por lo que tiene 100 satoshi extra en sus saldos del canal por las tasas de enrutamiento.

Alice recibe el secreto y ha liquidado los 50.200 satoshi HTLC. El secreto puede ser usado como un _recibo_ para probar que Dina recibió el pago por ese hash de pago específico.

Los saldos finales del canal reflejan el pago de Alice a Dina y las tasas de enrutamiento pagadas en cada salto, como se muestra en <<alice_dina_htlc_redeem_4>>.

[[alice_dina_htlc_redeem_4]]
.Channel balances after the payment
image::images/mtln_0813.png["Channel balances after the payment"]

[[preventing_theft]]
==== Vinculación de la firma: Previniendo el robo de HTLCs.

Hay una trampa. ¿Te has dado cuenta?

Si Alice, Bob y Chan crean los HTLCs como se muestra en <<alice_dina_htlc_redeem_4>>, se enfrentan a un pequeño pero no insignificante riesgo de pérdida. Cualquiera de esos HTLCs puede ser canjeado (gastado) por cualquiera que conozca el secreto. Al principio, sólo Dina conoce el secreto. Se supone que Dina sólo puede gastar el HTLC de Chan. Pero Dina podría gastar los tres HTLC al mismo tiempo, ¡o incluso en una sola transacción de gasto! Después de todo, Dina conoce el secreto antes que nadie. Del mismo modo, una vez que Chan conoce el secreto, se supone que sólo debe gastar el HTLC ofrecido por Bob. ¿Pero qué pasa si Chan también gasta el HTLC ofrecido por Alice?

¡Esto no es _sin confianza_! Falla la característica de seguridad más importante. Tenemos que arreglar esto.

El script HTLC debe tener una condición adicional que vincule cada HTLC a un destinatario específico. Lo hacemos requiriendo una firma digital que coincida con la clave pública de cada destinatario, impidiendo así que cualquier otra persona pueda gastar ese HTLC. Como sólo el destinatario designado tiene la capacidad de producir una firma digital que coincida con esa clave pública, sólo el destinatario designado puede gastar ese HTLC.

Volvamos a ver los guiones teniendo en cuenta esta modificación. El HTLC de Alice para Bob se modifica para incluir la clave pública de Bob y el operador +OP_CHECKSIG+.

Aquí está el script HTLC modificado:

----
OP_SHA256 <H> OP_EQUALVERIFY <Bob's Pub> OP_CHECKSIG
----

[TIP]
====
Observe que también hemos cambiado +OP_EQUAL+ por +OP_EQUALVERIFY+. Cuando un operador tiene el sufijo +VERIFY+, no devuelve +TRUE+ o +FALSE+ en la pila. En su lugar, _altera_ la ejecución y falla el script si el resultado es falso y continúa sin ninguna salida en la pila si es verdadero.
====

Para canjear este HTLC, Bob tiene que presentar un script de desbloqueo que incluya una firma de la clave privada de Bob, así como la preimagen del pago secreto, como este

----
<Bob's Signature> <R>
----

Los scripts de desbloqueo y bloqueo se combinan y son evaluados por el motor de scripts, de la siguiente manera:

----
<Bob's Sig> <R> OP_SHA256 <H> OP_EQUALVERIFY <Bob's Pub> OP_CHECKSIG
----

1. +<Bob's Sig>+ se empuja a la pila.
2. +R+ es empujado a la pila.
3. +OP_SHA256+ saca y hace el hash de +R+ de la parte superior de la pila y empuja +H~R~+ a la pila.
4. +H+ es empujado a la pila.
5. 5. +OP_EQUALVERIFY+ extrae +H+ y +H~R~+ y los compara. Si no son iguales, la ejecución se detiene. En caso contrario, se continúa sin salida a la pila.
6. La tecla +<Bob's Pub>+ es empujada a la pila.
7. +OP_CHECKSIG+ saca la Sig de +<Bob>+ y la Pub de +<Bob>+ y verifica la firma. El resultado (`Verdadero/Falso`) es empujado a la pila.

Como puedes ver, esto es ligeramente más complicado, pero ahora hemos arreglado el HTLC y nos hemos asegurado de que sólo el destinatario previsto puede gastarlo.

==== Optimización del Hash.

Veamos la primera parte del script HTLC hasta ahora:

----
OP_SHA256 <H> OP_EQUALVERIFY
----

Si miramos esto en la representación simbólica anterior, parece que los operadores +OP_+ son los que más espacio ocupan. Pero no es así. Bitcoin Script está codificado en binario, y cada operador representa un byte. Mientras tanto, el valor +<H>+ que utilizamos como marcador de posición para el hash de pago es un valor de 32 bytes (256 bits). Puede encontrar un listado de todos los operadores de Bitcoin Script y su codificación binaria y hexadecimal en https://en.bitcoin.it/wiki/Script[Wiki de Bitcoin: Script], o en https://github.com/bitcoinbook/bitcoinbook/blob/develop/appdx-scriptops.asciidoc[Apéndice D, "Operadores, Constantes y Símbolos del Lenguaje de Transacción Script," en _Mastering Bitcoin_].

Representado en hexadecimal, nuestro script HTLC tendría este aspecto: 

----
a8 0575965b3b44be51e8057d551c4016d83cb1fba9ea8d6e986447ba33fe69f6b3 88
----

En codificación hexadecimal, +OP_SHA256+ es +a8+ y +OP_EQUALVERIFY+ es +88+. La longitud total de este script es de 34 bytes, de los cuales 32 bytes son el hash.

Como hemos mencionado anteriormente, cualquier participante de la Lightning Network debería poder tomar una transacción fuera de la cadena que tenga y ponerla en la cadena si necesita hacer valer su derecho a los fondos. Para llevar una transacción a la cadena, tendrían que pagar tasas de transacción a los mineros, y estas tasas son proporcionales al tamaño, en bytes, de la transacción.

Por lo tanto, queremos encontrar formas de minimizar el "peso" de las transacciones en la cadena optimizando el script tanto como sea posible. Una forma de hacerlo es añadir otra función hash sobre el algoritmo SHA-256, una que produzca hashes más pequeños. El lenguaje de Bitcoin Script proporciona el operador +OP_HASH160+ que realiza un "doble hash" de una preimagen: primero se realiza el hash de la preimagen con SHA-256, y luego el hash resultante se realiza de nuevo con el algoritmo de hash RIPEMD160. El hash resultante de RIPEMD160 es de 160 bits o 20 bytes, mucho más compacto. En Bitcoin Script esta es una optimización muy común que se utiliza en muchos de los formatos de dirección comunes.

Por lo tanto, vamos a utilizar esa optimización en su lugar. Nuestro hash SHA-256 es +057596...69f6b3+. Si lo sometemos a otra ronda de hash con RIPEMD160 obtendremos el resultado:

----
R = "Dinas secret"
H256 = SHA256(R)
H256 = 0575965b3b44be51e8057d551c4016d83cb1fba9ea8d6e986447ba33fe69f6b3
H160 = RIPEMD160(H256)
H160 = 9e017f67971ed7cea17f98528d5f5c0ccb2c71
----

Alice puede calcular el hash RIPEMD160 del hash de pago que proporciona Dina y utilizar el hash más corto en su HTLC, ¡al igual que Bob y Chan!

[role="pagebreak-before"]
El script HTLC "optimizado" tendría este aspecto:

----
OP_HASH160 <H160> OP_EQUALVERIFY
----

Codificado en hexadecimal, esto es:

----
a9 9e017f67971ed7cea17f98528d5f5c0ccb2c71 88
----

Donde +OP_HASH160+ es +a9+ y +OP_EQUALVERIFY+ es +88+. Este script sólo tiene 22 bytes. Hemos ahorrado 12 bytes de cada transacción que canjea un HTLC en la cadena.

Con esa optimización, ahora ves cómo llegamos al script HTLC que se muestra en la línea 10 de <<received_htlc>>:

----
...
    # To local node via HTLC-success transaction.
    OP_HASH160 <RIPEMD160(payment_hash)> OP_EQUALVERIFY...
----

==== Cooperativa HTLC y fallo de tiempo de espera.

Hasta ahora hemos visto la parte del "hash" de HTLC y cómo funcionaría si todos cooperaran y estuvieran conectados en el momento del pago.

¿Qué ocurre si alguien se desconecta o no coopera? ¿Qué ocurre si el pago no puede realizarse?

Tenemos que garantizar una forma de "fallar con elegancia", porque los fallos ocasionales de enrutamiento son inevitables. Hay dos formas de fallar: de forma cooperativa y con un reembolso con límite de tiempo.

El fallo cooperativo es relativamente sencillo: cada participante en la ruta deshace el HTLC, eliminando la salida del HTLC de sus transacciones de compromiso sin cambiar el balance. Veremos cómo funciona esto en detalle en <<channel_operation>>.

Veamos cómo podemos revertir un HTLC sin la cooperación de uno o más participantes. Tenemos que asegurarnos de que si uno de los participantes no coopera, los fondos no queden simplemente bloqueados en el HTLC _para siempre_. Esto daría a alguien la oportunidad de pedir un rescate por los fondos de otro participante: "Dejaré tus fondos atados para siempre si no me pagas el rescate".

Para evitar esto, cada script de HTLC incluye una cláusula de reembolso que está conectada a un bloqueo de tiempo. ¿Recuerdas nuestro contrato de depósito original? "Bob tiene 24 horas para mostrar el secreto después de la firma del contrato. Si Bob no proporciona el secreto en este tiempo, el depósito de Alice será reembolsado".

El reembolso con tiempo es una parte importante de la secuencia de comandos que asegura la _atomicidad_, de modo que todo el pago de extremo a extremo tiene éxito o falla con gracia. No hay que preocuparse por el estado de "medio pago". Si hay un fallo, cada participante puede deshacer el HTLC de forma cooperativa con su socio de canal o poner la transacción de reembolso en cadena bloqueada por tiempo unilateralmente para recuperar su dinero.

Para implementar este reembolso en Bitcoin Script, utilizamos un operador especial OP_CHECKLOCKTIMEVERIFY también conocido como +OP_CLTV+ para abreviar. Aquí está el script, como se vio anteriormente en la línea 13 de <<received_htlc>>:

----
...
	OP_DROP <cltv_expiry> OP_CHECKLOCKTIMEVERIFY OP_DROP
	OP_CHECKSIG
...
----

El operador +OP_CLTV+ toma un tiempo de expiración definido como la altura del bloque después de la cual esta transacción es válida. Si el tiempo de caducidad de la transacción no es el mismo que el de +<cltv_expiry>+, la evaluación del script falla y la transacción no es válida. En caso contrario, el script continúa sin ninguna salida a la pila. Recuerde, el sufijo +VERIFY+ significa que este operador no da salida a +TRUE+ o +FALSE+ sino que se detiene/fallece o continúa sin salida a la pila. 

Esencialmente, el +OP_CLTV+ actúa como un "guardián" que impide que el script siga adelante si no se ha alcanzado la altura del bloque +<cltv_expiry>+ en la blockchain de Bitcoin.

El operador +OP_DROP+ simplemente deja caer el elemento más alto de la pila del script. Esto es necesario al principio porque hay un elemento "sobrante" de las líneas de script anteriores. Es necesario _después_ de +OP_CLTV+ para eliminar el elemento +<cltv_expiry>+ de la parte superior de la pila porque ya no es necesario.

Finalmente, una vez que la pila se ha limpiado, debería quedar una clave pública y una firma que +OP_CHECKSIG+ pueda verificar. Como vimos en <<preventing_theft>>, esto es necesario para asegurar que sólo el propietario legítimo de los fondos pueda reclamarlos, vinculando esta salida a su clave pública y requiriendo una firma.

==== Timelocks decrecientes.

Como los HTLCs se extienden de Alice a Dina, la cláusula de reembolso con bloqueo de tiempo en cada HTLC tiene un valor _diferente_ +cltv_expiry+. Veremos esto con más detalle en <<onion_routing>>. Pero basta con decir que para asegurar un desenvolvimiento ordenado de un pago que falla, cada salto necesita esperar un poco menos para su reembolso. La diferencia entre los timelocks de cada salto se denomina +cltv_expiry_delta+, y es establecida por cada nodo y anunciada a la red, como veremos en <<gossip>>.

Por ejemplo, Alice establece el timelock de reembolso en el primer HTLC a una altura de bloque actual + 500 bloques ("actual" es la altura de bloque actual). Bob entonces establecería el timelock +cltv_expiry+ en el HTLC a Chan a actual + 450 bloques. Chan establecería el timelock a actual + 400 bloques de la altura de bloque actual. De esta manera, Chan puede obtener un reembolso del HTLC que ofreció a Dina _antes_ de que Bob obtenga un reembolso del HTLC que ofreció a Chan. Bob puede obtener un reembolso del HTLC que ofreció a Chan antes de que Alice pueda obtener un reembolso por el HTLC que ofreció a Bob. El timelock decreciente evita las condiciones de carrera y asegura que la cadena HTLC se desenrolle hacia atrás, desde el destino hacia el origen.

=== Conclusión.

En este capítulo hemos visto cómo Alice puede pagar a Dina aunque no tenga un payment channel directo. Alice puede encontrar un camino que la conecte con Dina y encaminar un pago a través de varios canales de pago para que llegue a Dina.

Para asegurarse de que el pago es atómico y sin confianza a través de múltiples saltos, Alice debe implementar un protocolo de equidad en cooperación con todos los nodos intermediarios en la ruta. El protocolo de equidad se implementa actualmente como un HTLC, que compromete los fondos a un hash de pago derivado de una preimagen de pago secreta.

Cada uno de los participantes en la ruta de pago puede extender un HTLC al siguiente participante, sin preocuparse por el robo o el bloqueo de fondos. El HTLC puede ser canjeado revelando la preimagen de pago secreta. Una vez que un HTLC llega a Dina, ésta revela la preimagen, que fluye hacia atrás, resolviendo todos los HTLCs ofrecidos.

Por último, vimos cómo una cláusula de reembolso con límite de tiempo completa el HTLC, asegurando que todos los participantes puedan obtener un reembolso si el pago falla pero, por cualquier razón, uno de los participantes no coopera en el desenlace de los HTLC. Al tener siempre la opción de ir a la cadena para un reembolso, el HTLC logra el objetivo de equidad de la atomicidad y la operación sin confianza.

[[channel_operation]]
== Operación del canal y reenvío de pagos.

En este capítulo reuniremos los canales de pago y los contratos de tiempo bloqueado (HTLC). En <<payment_channels>>, explicamos la forma en que Alice y Bob construyen un payment channel entre sus dos nodos. También hemos visto los mecanismos de compromiso y penalización que aseguran el payment channel. En "Enrutamiento", vimos los HTLCs y cómo éstos pueden ser utilizados para enrutar un pago a través de una ruta hecha de múltiples canales de pago. En este capítulo unimos los dos conceptos viendo cómo se gestionan los HTLC en cada payment channel, cómo se comprometen los HTLC con el estado del canal y cómo se liquidan para actualizar los saldos del canal.

Específicamente, discutiremos "Añadir, liquidar, fallar HTLCs" y la "Máquina de estado del canal" que forman la superposición entre la capa peer-to-peer y la capa de enrutamiento, como se destaca por un esquema en <<LN_protocol_channelops_highlight>>. 

[[LN_protocol_channelops_highlight]]
.Channel operation and payment forwarding in the Lightning protocol suite
image::images/mtln_0901.png["Channel operation and payment forwarding in the Lightning protocol suite"]

=== Local (un solo canal) frente a enrutado (múltiples canales).

Aunque es posible enviar pagos a través de un payment channel simplemente actualizando los saldos del canal y creando nuevas transacciones de compromiso, el protocolo Lightning utiliza HTLC incluso para los pagos "locales" a través de un payment channel. La razón de esto es mantener el mismo diseño de protocolo independientemente de si un pago es de un solo salto (a través de un único payment channel) o de varios saltos (enrutado a través de múltiples canales de pago).

Al mantener la misma abstracción tanto para el local como para el remoto, no sólo simplificamos el diseño del protocolo sino que también mejoramos la privacidad. Para el receptor de un pago no hay ninguna diferencia discernible entre un pago realizado directamente por su socio de canal y un pago reenviado por su socio de canal en nombre de otra persona.

=== Reenvío de pagos y actualización de compromisos con HTLCs.

Volveremos a nuestro ejemplo de <<routing>> para demostrar cómo los HTLC de Alice a Dina se comprometen con cada payment channel. Como recuerdas en nuestro ejemplo, Alice está pagando a Dina 50.000 satoshis enrutando un HTLC a través de Bob y Chan. La red se muestra en <<alice_dina_htlc_2>>. 

[[alice_dina_htlc_2]]
.Alice pays Dina with an HTLC routed via Bob and Chan
image::images/mtln_0809.png["Alice pays Dina with an HTLC routed via Bob and Chan"]

Nos centraremos en el payment channel entre Alice y Bob y revisaremos los mensajes y transacciones que utilizan para procesar este HTLC.

==== HTLC y flujo de mensajes de compromiso.

El flujo de mensajes entre Alice y Bob (y también entre cualquier par de socios del canal) se muestra en <<HTLC_commitment_message_flow>>. 

[[HTLC_commitment_message_flow]]
.The message flow for HTLC commitment between channel partners
image::images/mtln_0903.png["The message flow for HTLC commitment between channel partners"]

[role="pagebreak-before"]
Ya hemos visto el +compromiso_firmado+ y el +revoke_and_ack+ en <<payment_channels>>. Ahora veremos cómo encajan los HTLC en el esquema de compromiso. Los dos nuevos mensajes son +update_add_htlc+, que Alice utiliza para pedir a Bob que añada un HTLC, y +update_fulfill_htlc+, que Bob utiliza para canjear el HTLC una vez que ha recibido el secreto del pago (el secreto de Dina).

=== Reenvío de pagos con HTLCs.

Alice y Bob comienzan con un payment channel que tiene un balance de 70.000 satoshi en cada lado.

Como vimos en <<payment_channels>>, esto significa que Alice y Bob han negociado y cada uno mantiene transacciones de compromiso. Estas transacciones de compromiso son asimétricas, retrasadas y revocables, y se parecen al ejemplo de <<alice_bob_commitment_txs_1>>. 

[[alice_bob_commitment_txs_1]]
.Alice and Bob's initial commitment transactions
image::images/mtln_0904.png["Alice and Bob's initial commitment transactions"]

==== Añadir un HTLC.

Alice quiere que Bob acepte un HTLC por valor de 50.200 satoshis para enviarlo a Dina. Para ello, Alice debe enviar los detalles de este HTLC, incluyendo el hash de pago y la cantidad, a Bob. Bob también necesitará saber dónde reenviarlo, algo que discutimos en detalle en <<onion_routing>>.

Para añadir el HTLC, Alice inicia el flujo que vimos en <<HTLC_commitment_message_flow>> enviando el mensaje +update_add_htlc+ a Bob.

[[update_add_htlc]]
==== El mensaje update_add_HTLC.

Alice envía el mensaje `update_add_HTLC` Lightning a Bob. Este mensaje está definido en https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#adding-an-htlc-update_add_htlc[BOLT #2: Peer Protocol, `update_add_HTLC`], y se muestra en el Ejemplo 9-1. 

[[update_add_HTLC_message_fields]]
.The `update_add_HTLC` message
====
----
[channel_id:channel_id]
[u64:id]
[u64:amount_msat]
[sha256:payment_hash]
[u32:cltv_expiry]
[1366*byte:onion_routing_packet]
----
====

+channel_id+:: Es el canal que Alice tiene con Bob donde quiere añadir el HTLC. Recuerda que Alice y Bob pueden tener varios canales entre sí.

+id+:: Este es un contador de HTLC y comienza en +0+ para el primer HTLC ofrecido a Bob por Alice y se incrementa para cada HTLC posterior ofrecido. 

+cantidad_msat+:: Es la cantidad (valor) del HTLC en milisatoshis. En nuestro ejemplo es 50.200.000 milisatoshis (es decir, 50.200 satoshis).

+hash_de_pago+:: Es el hash del pago calculado a partir de la invoice de Dina. Es _H_ = RIPEMD160(SHA-256(_R_)), donde _R_ es el secreto de Dina que sólo conoce Dina y que se revelará si se le paga.

+cltv_expiry+:: Es el tiempo de caducidad de este HTLC, que se codificará como un reembolso con tiempo en caso de que el HTLC no llegue a Dina en este tiempo.

+paquete_de_enrutamiento+:: Se trata de una ruta encriptada en cebolla que indica a Bob dónde debe reenviar este HTLC a continuación (a Chan). El enrutamiento de cebolla está cubierto en detalle en <<onion_routing>>. 

[TIP]
====
Como recordatorio, la contabilidad dentro de la Lightning Network está en unidades de milisatoshis (milésimas de satoshi), mientras que la contabilidad de Bitcoin está en satoshis. Las cantidades en HTLC son milisatoshis, que se redondean al satoshi más cercano en las transacciones de compromiso de Bitcoin.
====

==== HTLC en las transacciones de compromiso.

La información recibida es suficiente para que Bob cree una nueva commitment transaction. La nueva commitment transaction tiene las mismas dos salidas +to_self+ y +to_remote+ para el balance de Alice y Bob, y una _nueva_ salida que representa el HTLC ofrecido por Alice.

Ya hemos visto la estructura básica de un HTLC en <<routing>>. El script completo de un HTLC ofrecido está definido en https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#offered-htlc-outputs[BOLT #3: Transacciones, Salida HTLC ofrecida] y se muestra en <<offered_htlc_output_script>>. 


[[offered_htlc_output_script]]
.Offered HTLC output script
====
[source,text,linenums]
----
# Revocation <1>
OP_DUP OP_HASH160 <RIPEMD160(SHA256(revocationpubkey))> OP_EQUAL
OP_IF
    OP_CHECKSIG
OP_ELSE
    <remote_HTLCpubkey> OP_SWAP OP_SIZE 32 OP_EQUAL
    OP_IF
        # Redemption <2>
        OP_HASH160 <RIPEMD160(payment_hash)> OP_EQUALVERIFY
        2 OP_SWAP <local_HTLCpubkey> 2 OP_CHECKMULTISIG
    OP_ELSE
        # Refund <3>
        OP_DROP <cltv_expiry> OP_CHECKLOCKTIMEVERIFY OP_DROP
        OP_CHECKSIG
    OP_ENDIF
OP_ENDIF
----
<1> La primera cláusula de la condicional `OP_IF` es canjeable por Alice con una clave de revocación. Si este compromiso es revocado posteriormente, Alice tendrá una clave de revocación para reclamar esta salida en una transacción de penalización, llevándose todo el balance del canal.
<2> La segunda cláusula es canjeable por la preimagen (secreto de pago, o en nuestro ejemplo, el secreto de Dina) si se revela. Esto permite a Bob reclamar esta salida si tiene el secreto de Dina, lo que significa que ha entregado con éxito el pago a Dina.
<3> La tercera y última cláusula es un reembolso del HTLC a Alice si el HTLC expira sin llegar a Dina. Se bloquea el tiempo con la expiración +cltv_expiry+. Esto asegura que el balance de Alice no está "atascado" en un HTLC que no puede ser dirigido a Dina.
====

Hay tres maneras de reclamar esta salida. Intenta leer el script y ver si puedes averiguarlo (recuerda que es un lenguaje basado en la pila, por lo que las cosas aparecen "al revés").

==== Nuevo compromiso con la salida HTLC.

Bob tiene ahora la información necesaria para añadir este script HTLC como una salida adicional y crear una nueva commitment transaction. El nuevo compromiso de Bob tendrá 50.200 satoshis en la salida HTLC. Esa cantidad provendrá del balance del canal de Alice, por lo que el nuevo balance de Alice será de 19.800 satoshis (70.000 - 50.200 = 19.800). Bob construye este compromiso como un "Compromiso #3" tentativo, mostrado en <<add_commitment_3b>>. 

[[add_commitment_3b]]
.Bob's new commitment with an HTLC output
image::images/mtln_0905.png["Bob's new commitment with an HTLC output"]

[role="pagebreak-before less_space"]
==== Alice se compromete.

Poco después de enviar el mensaje +update_add_htlc+, ella se compromete con el nuevo estado del canal, para que el HTLC pueda ser añadido con seguridad por Bob. Bob tiene la información del HTLC y ha construido un nuevo compromiso pero todavía no tiene este nuevo compromiso firmado por Alice.

Alice envía +compromiso_firmado+ a Bob, con la firma para el nuevo compromiso y para el HTLC que contiene. Hemos visto el mensaje +compromiso_firmado+ en <<payment_channels>>, pero ahora podemos entender el resto de los campos. Como recordatorio, se muestra en <<ops_commitment_signed_message>>. 

[[ops_commitment_signed_message]]
.The `commitment_signed` message
====
----
[channel_id:channel_id]
[signature:signature]
[u16:num_htlcs]
[num_htlcs*signature:htlc_signature]
----
====


Los campos +num_htlcs+ y +htlc_signature+ tienen ahora más sentido:

+num_htlcs+:: Es el número de HTLCs que están pendientes en la commitment transaction. En nuestro ejemplo, sólo un HTLC, el que ofreció Alice.

+htlc_signature+:: Es un array de firmas (+num_htlcs+ de longitud), que contiene las firmas de las salidas HTLC.

Alice puede enviar estas firmas sin dudar: siempre puede obtener un reembolso si el HTLC expira sin ser dirigido a Dina.

Ahora, Bob tiene una nueva commitment transaction firmado, como se muestra en <<signed_commitment_3b>>. 

[[signed_commitment_3b]]
.Bob has a new signed commitment
image::images/mtln_0906.png[Bob has a new signed commitment]

==== Bob reconoce el nuevo compromiso y revoca el antiguo.

Lo hace enviando el mensaje +revoke_and_ack+, tal y como vimos en <<payment_channels>> anteriormente. Como recordatorio, ese mensaje se muestra en <<revoke_and_ack_message_2>>. 

[[revoke_and_ack_message_2]]
.The +revoke_and_ack+ message
====
----
[channel_id:channel_id]
[32*byte:per_commitment_secret]
[point:next_per_commitment_point]
----
====

Bob envía el +per_commitment_secret+ que permite a Alice construir una clave de revocación para construir una transacción de penalización gastando el compromiso antiguo de Bob. Una vez que Bob ha enviado esto, nunca puede publicar el "Compromiso #2" sin arriesgarse a una transacción de penalización y perder todo su dinero. Por lo tanto, el antiguo compromiso es efectivamente revocado.

Bob ha movido efectivamente el estado del canal hacia adelante, como se muestra en <<revoked_commitment_2b>>. 

[[revoked_commitment_2b]]
.Bob has revoked the old commitment
image::images/mtln_0907.png[Bob has revoked the old commitment]

A pesar de que Bob tiene una nueva commitment transaction (firmada) y una salida de HTLC en su interior, no puede considerar que su HTLC se haya establecido con éxito.

Primero necesita que Alice revoque su compromiso anterior, porque de lo contrario, Alice puede retroceder su balance a 70.000 satoshis. Bob necesita asegurarse de que Alice también tiene una commitment transaction que contiene el HTLC y ha revocado el compromiso anterior.

Por eso, si Bob no es el destinatario final de los fondos del HTLC, no debe reenviar todavía el HTLC ofreciendo un HTLC en el siguiente canal con Chan.

Alice ha construido una transacción de nuevo compromiso en espejo que contiene el nuevo HTLC, pero aún debe ser firmado por Bob. Podemos verlo en <<add_commitment_3a>>. 

[[add_commitment_3a]]
.Alice's new commitment with an HTLC output
image::images/mtln_0908.png["Alice's new commitment with an HTLC output"]

Como describimos en <<payment_channels>>, el compromiso de Alice es la imagen en espejo del de Bob, ya que contiene el constructo asimétrico, retrasado y revocable para la revocación y la aplicación de sanciones de los compromisos antiguos. El balance de 19.800 satoshi de Alice (después de deducir el valor HTLC), es retrasado y revocable. El balance de 70.000 satoshi de Bob es inmediatamente revocable.

A continuación, el flujo de mensajes para +commitment_signed+ y +revoke_and_ack+ se repite ahora, pero en sentido contrario. Bob envía +commitment_signed+ para firmar el nuevo compromiso de Alice, y Alice responde revocando su antiguo compromiso.

Para completar, vamos a revisar rápidamente las transacciones de compromiso como esta ronda de compromiso/revocación ocurre.

[role="pagebreak-before less_space"]
==== Bob se compromete.

Bob ahora envía un +commitment_signed+ de vuelta a Alice, con sus firmas para la nueva commitment transaction de Alice, incluyendo la salida HTLC que ha añadido.

Ahora Alice tiene la firma para la nueva commitment transaction. El estado del canal se muestra en <<signed_commitment_3a>>. 

[[signed_commitment_3a]]
.Alice has a new signed commitment
image::images/mtln_0909.png[Alice has a new signed commitment]

Alice puede ahora reconocer el nuevo compromiso revocando el anterior. Alice envía el mensaje +revoke_and_ack+ que contiene el necesario +per_commitment_point+ que permitirá a Bob construir una clave de revocación y una transacción de penalización. Así, Alice revoca su antiguo compromiso.

El estado del canal se muestra en <<revoked_commitment_2a>>.

[[revoked_commitment_2a]]
.Alice has revoked the old commitment
image::images/mtln_0910.png[Alice has revoked the old commitment]

=== Múltiples HTLCs.

En cualquier momento, Alice y Bob pueden tener docenas o incluso cientos de HTLCs a través de un solo canal. Cada HTLC se ofrece y se añade a la commitment transaction como una salida adicional. Por lo tanto, una commitment transaction siempre tiene dos salidas para los balances de los socios del canal y cualquier número de salidas HTLC, una por HTLC.

Como vimos en el mensaje +commitment_signed+, hay una matriz para las firmas de HTLC para que se puedan transmitir múltiples compromisos de HTLC al mismo tiempo.

El número máximo actual de HTLCs permitido en un canal es de 483 HTLCs para tener en cuenta el tamaño máximo de las transacciones de Bitcoin y asegurar que las transacciones de compromiso siguen siendo transacciones válidas de Bitcoin.

Como veremos en la siguiente sección, el máximo es sólo para los HTLCs _pendientes_ porque, una vez que un HTLC se cumple (o falla por tiempo de espera/error), se elimina de la commitment transaction.

=== Cumplimiento del HTLC.

Ahora Bob y Alice tienen una nueva commitment transaction con una salida adicional de HTLC, y hemos logrado un paso importante hacia la actualización de un payment channel.

El nuevo balance de Alice y Bob no refleja todavía que Alice haya enviado con éxito 50.200 satoshis a Bob.

Sin embargo, los HTLCs están ahora configurados de manera que será posible una liquidación segura a cambio de la prueba de pago.

==== Propagación de HTLC.

Supongamos que Bob continúa la cadena y establece un HTLC con Chan por 50.100 satoshis. El proceso será exactamente el mismo que acabamos de ver entre Alice y Bob. Bob enviará +update_add_htlc+ a Chan, luego intercambiarán mensajes +commitment_signed+ y +revoke_and_ack+ en dos rondas, progresando su canal al siguiente estado.

A continuación, Chan hará lo mismo con Dina: ofrecer un HTLC de 50.000 satoshi, comprometerse y revocar, etc. Sin embargo, Dina es la destinataria final del HTLC. Dina es la única que conoce el secreto del pago (la preimagen del hash del pago). Por lo tanto, Dina puede cumplir el HTLC con Chan inmediatamente.

==== Dina cumple el HTLC con Chan.

Dina puede liquidar la HTLC enviando un mensaje +update_fulfill_htlc+ a Chan. El mensaje +update_fulfill_htlc+ está definido en https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#removing-an-htlc-update_fulfill_htlc-update_fail_htlc-and-update_fail_malformed_htlc[BOLT #2: Peer Protocol, `update_fulfill_htlc`] y se muestra aquí: 

[[update_fulfill_htlc_message]]
.The +update_fulfill_htlc+ message
----
[channel_id:channel_id]
[u64:id]
[32*byte:payment_preimage]
----

It's a really simple message:

+channel_id+:: The channel ID on which the HTLC is committed.

+id+:: The ID of the HTLC (we started with 0 and incremented for each HTLC on the channel).

+payment_preimage+:: The secret that proves payment was made and redeems the HTLC. This is the +R+ value that was hashed by Dina to produce the payment hash in the invoice to Alice.

When Chan receives this message, he will immediately check if the `payment_preimage` (let's call it _R_) produces the payment hash (let's call it _H_) in the HTLC that he offered to Dina. He hashes it like this:

++++
<ul class="simplelist">
<li><em>H</em> = RIPEMD160(SHA-256 (<em>R</em>))</li>
</ul>
++++

If the result _H_ matches the payment hash in the HTLC, Chan can do a little dance of celebration. This long-awaited secret can be used to redeem the HTLC, and will be passed back along the chain of payment channels all the way to Alice, resolving every HTLC that was part of this payment to Dina.

Volvamos al canal de Alice y Bob y veamos cómo deshacen el HTLC. Para llegar allí, supongamos que Dina envió el +update_fulfill_htlc+ a Chan, Chan envió +update_fulfill_htlc+ a Bob, y Bob envió +update_fulfill_htlc+ a Alice. La preimagen de pago se ha propagado hasta Alice.

==== Bob liquida el HTLC con Alice.

Cuando Bob envía el +update_fulfill_htlc+ a Alice, éste contendrá la misma +payment_preimage+ que Dina seleccionó para su invoice. Esa +imagen_de_pago+ ha viajado hacia atrás a lo largo de la ruta de pago. En cada paso, el +canal_id+ será diferente y el +id+ (HTLC ID) puede ser diferente. Pero la preimagen es la misma.

Alice también validará la +imagen_de_pago+ recibida de Bob. Comparará su hash con el hash del pago en el HTLC que ofreció a Bob. También encontrará que esta preimagen coincide con el hash de la invoice de Dina. Esto es una prueba de que Dina fue pagada.

El flujo de mensajes entre Alice y Bob se muestra en <<htlc_fulfillment_message_flow>>. 

[[htlc_fulfillment_message_flow]]
.The HTLC fulfillment message flow
image::images/mtln_0911.png[The HTLC fulfillment message flow]

Tanto Alice como Bob pueden ahora eliminar el HTLC de las transacciones de compromiso y actualizar sus balances de canal.

Crean nuevos compromisos (Compromiso #4), como se muestra en <<htlc_fulfillment_commitments_added>>. 

[[htlc_fulfillment_commitments_added]]
.The HTLC is removed and balances are updated in new commitments
image::images/mtln_0912.png[The HTLC is removed and balances are updated in new commitments]

[role="pagebreak-before"]
Next, they complete two rounds of commitment and revocation. First, Alice sends +commitment_signed+ to sign Bob's new commitment transaction. Bob responds with +revoke_and_ack+ to revoke his old commitment. Una vez que Bob ha movido el estado del canal hacia adelante, los compromisos se ven como vemos en <<htlc_fulfillment_commitments_bob_commit>>. 

[[htlc_fulfillment_commitments_bob_commit]]
.Alice signs Bob's new commitment and Bob revoked the old one
image::images/mtln_0913.png[Alice signs Bob's new commitment and Bob revoked the old one]

[role="pagebreak-before"]
Finalmente, Bob firma el compromiso de Alice enviándole un mensaje +commitment_signed+. Entonces Alice reconoce y revoca su antiguo compromiso enviando +revoke_and_ack+ a Bob. El resultado final es que tanto Alice como Bob han movido su estado de canal al Compromiso #4, han eliminado el HTLC, y han actualizado sus balances. Su estado actual del canal está representado por las transacciones de compromiso que se muestran en <<alice_bob_htlc_fulfilled>>.

[[alice_bob_htlc_fulfilled]]
.Alice and Bob settle the HTLC and update balances
image::images/mtln_0914.png[Alice and Bob settle the HTLC and update balances]

[role="pagebreak-before less_space"]
=== Eliminación de un HTLC por error o caducidad.

Si un HTLC no se puede cumplir, se puede eliminar del compromiso del canal utilizando el mismo proceso de compromiso y revocación.

En lugar de +update_fulfill_htlc+, Bob enviaría un +update_fail_htlc+ o +update_fail_malformed_htlc+. Estos dos mensajes están definidos en https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md#removing-an-htlc-update_fulfill_htlc-update_fail_htlc-and-update_fail_malformed_htlc[BOLT #2: Peer Protocol, Removing an HTLC].

El mensaje +update_fail_htlc+ se muestra en lo siguiente:

[[update_fail_htlc_message]]
.The +update_fail_htlc+ message
----
[channel_id:channel_id]
[u64:id]
[u16:len]
[len*byte:reason]
----

Es bastante autoexplicativo. El campo multibyte +reason+ está definido en https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#failure-messages[BOLT #4: Onion Routing], que describiremos en <<onion_routing>>. 

Si Alice recibiera un +update_fail_htlc+ de Bob, el proceso se desarrollaría de forma muy similar: los dos socios del canal eliminarían el HTLC, crearían transacciones de compromiso actualizadas y pasarían por dos rondas de compromiso/revocación para avanzar el estado del canal hasta el siguiente compromiso. La única diferencia: los saldos finales volverían a ser los que eran sin el HTLC, esencialmente devolviendo a Alice el valor del HTLC.

=== Hacer un pago local.

Llegados a este punto, comprenderás fácilmente por qué los HTLC se utilizan tanto para los pagos remotos como para los locales. Cuando Alice paga a Bob por un café, no sólo actualiza el balance del canal y se compromete con un nuevo estado. En su lugar, el pago se realiza con un HTLC, de la misma manera que Alice pagó a Dina. El hecho de que sólo haya un salto de canal no supone ninguna diferencia. Funcionaría así:
[start=1]
. Alice pide un café en la página de la tienda de Bob.
. La tienda de Bob envía una invoice con un hash de pago.
. Alice construye un HTLC a partir de ese hash de pago.
. Alice ofrece el HTLC a Bob con +update_add_htlc+.
. Alice y Bob intercambian compromisos y revocaciones añadiendo el HTLC a sus transacciones de compromiso.
. Bob envía +update_fulfill_htlc+ a Alice con la preimagen de pago.
. Alice y Bob intercambian compromisos y revocaciones eliminando el HTLC y actualizando los saldos del canal.

Tanto si un HTLC se reenvía a través de muchos canales como si se cumple en un solo "salto" de canal, el proceso es exactamente el mismo

=== Conclusión.

En este capítulo hemos visto cómo las transacciones de compromiso (de <<payment_channels>>) y los HTLCs (de <<routing>>) trabajan juntos. Hemos visto cómo se añade un HTLC a una commitment transaction, y cómo se cumple. Vimos cómo el sistema asimétrico, retrasado y revocable para hacer cumplir el estado del canal se extiende a los HTLCs.

También vimos cómo un pago local y un pago enrutado multisalto se manejan de manera idéntica: usando HTLCs.

En el próximo capítulo veremos el sistema de enrutamiento de mensajes encriptados llamado _onion routing_.

[[onion_routing]]
== Enrutamiento de cebolla.

En este capítulo describiremos el mecanismo de enrutamiento en cebolla de la Red Relámpago. La invención del _enrutamiento cebolla_ precede a la Red Relámpago en 25 años. El onion routing fue inventado por investigadores de la Marina estadounidense como protocolo de seguridad de las comunicaciones. El enrutamiento de cebolla es más famoso por Tor, la superposición de Internet con enrutamiento de cebolla que permite a los investigadores, activistas, agentes de inteligencia y a todos los demás utilizar Internet de forma privada y anónima.

En este capítulo nos centramos en la parte de "Source-based onion routing (SPHINX)" de la arquitectura del protocolo Lightning, resaltada por un esquema en el centro (capa de enrutamiento) de <<LN_protocol_onion_highlight>>. 

[[LN_protocol_onion_highlight]]
.Onion routing in the Lightning protocol suite
image::images/mtln_1001.png["Onion routing in the Lightning protocol suite"]

El onion routing describe un método de comunicación encriptada en el que el emisor de un mensaje construye sucesivas capas de encriptación anidadas que son "peladas" por cada nodo intermediario, hasta que la capa más interna es entregada al destinatario. El nombre "onion routing" describe este uso de la encriptación por capas que se van pelando de una en una, como la piel de una cebolla.

Cada uno de los nodos intermediarios sólo puede "pelar" una capa y ver quién es el siguiente en la ruta de comunicación. El onion routing garantiza que nadie, excepto el remitente, conozca el destino o la longitud de la ruta de comunicación. Cada intermediario sólo conoce el salto anterior y el siguiente.

La Red Relámpago utiliza una implementación del protocolo de onion routing basada en Sphinx,footnote:[George Danezis e Ian Goldberg, "Sphinx: A Compact and Provably Secure Mix Format", en _IEEE Symposium on Security and Privacy_ (Nueva York: IEEE, 2009), 269-282.] desarrollado en 2009 por George Danezis e Ian Goldberg.

La implementación del onion routing en la Red Relámpago se define en https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md[BOLT #4: Onion Routing Protocol].

=== Un ejemplo físico que ilustra el onion routing.

Hay muchas maneras de describir el onion routing, pero una de las más fáciles es utilizar el equivalente físico de los sobres cerrados. Un sobre representa una capa de encriptación, que sólo permite al destinatario nombrado abrirlo y leer el contenido.

Digamos que Alicia quiere enviar una carta secreta a Dina, indirectamente a través de algunos intermediarios.

==== Selección de una ruta.

La Lightning Network utiliza el _enrutamiento de origen_, lo que significa que la ruta de pago es seleccionada y especificada por el remitente, y sólo por el remitente. En este ejemplo, la carta secreta de Alice a Dina será el equivalente a un pago. Para asegurarse de que la carta llega a Dina, Alice creará una ruta desde ella hasta Dina, utilizando a Bob y Chan como intermediarios.

[TIP]
====
Puede haber muchos caminos que hagan posible que Alice llegue a Dina. Explicaremos el proceso de selección del camino _óptimo_ en <<path_finding>>. Por ahora, supondremos que el camino seleccionado por Alice utiliza a Bob y Chan como intermediarios para llegar a Dina.
====

[role="pagebreak-before"]
Como recordatorio, el camino seleccionado por Alice se muestra en <<alice_dina_path>>. 

[[alice_dina_path]]
.Path: Alice to Bob to Chan to Dina
image::images/mtln_1002.png["Alice to Bob to Chan to Dina"]

Veamos cómo Alice puede utilizar esta ruta sin revelar información a los intermediarios Bob y Chan.

.Source-Based Routing
****
El enrutamiento basado en la fuente no es la forma en que los paquetes se enrutan típicamente en Internet hoy en día, aunque el enrutamiento de la fuente fue posible en los primeros días.
El enrutamiento en Internet se basa en la "conmutación de paquetes" en cada nodo de enrutamiento intermedio. Un paquete IPv4, por ejemplo, incluye las direcciones IP del remitente y del destinatario, y cada uno de los otros nodos de enrutamiento IP decide cómo reenviar cada paquete hacia el destino.
Sin embargo, la falta de privacidad de este mecanismo de enrutamiento, en el que cada nodo intermediario ve al remitente y al destinatario, lo convierte en una mala opción para su uso en una red de pago.
****

==== Construyendo las capas.

Alice comienza escribiendo una carta secreta a Dina.  A continuación, sella la carta dentro de un sobre y escribe "Para Dina" en el exterior (véase <<dina_envelope>>). El sobre representa la encriptación con la clave pública de Dina para que sólo Dina pueda abrir el sobre y leer la carta.

[[dina_envelope]]
.Dina's secret letter, sealed in an envelope
image::images/mtln_1003.png["Dina's secret letter, sealed in an envelope"]

La carta de Dina será entregada a Dina por Chan, que está inmediatamente antes de Dina en el "camino". Así, Alice pone el sobre de Dina dentro de un sobre dirigido a Chan (ver <<chan_envelope>>). La única parte que Chan puede leer es el destino (instrucciones de enrutamiento): "Para Dina". Sellar esto dentro de un sobre dirigido a Chan representa encriptarlo con la clave pública de Chan para que sólo Chan pueda leer la dirección del sobre. Chan sigue sin poder abrir el sobre de Dina. Todo lo que ve son las instrucciones en el exterior (la dirección). 

[[chan_envelope]]
.Chan's envelope, containing Dina's sealed envelope
image::images/mtln_1004.png["Chan's envelope, containing Dina's sealed envelope"]

Ahora, esta carta será entregada a Chan por Bob. Así que Alice la pone dentro de un sobre dirigido a Bob (ver <<bob_envelope>>). Como antes, el sobre representa un mensaje encriptado para Bob que sólo éste puede leer. Bob sólo puede leer el exterior del sobre de Chan (la dirección), por lo que sabe que debe enviarlo a Chan.

[[bob_envelope]]
.Bob's envelope, containing Chan's sealed envelope
image::images/mtln_1005.png["Bob's envelope, containing Chan's sealed envelope"]

Ahora, si pudiéramos mirar a través de los sobres (¡con rayos X!) veríamos los sobres anidados uno dentro de otro, como se muestra en <<nested_envelopes>>. 

[[nested_envelopes]]
.Nested envelopes
image::images/mtln_1006.png[Nested envelopes]

==== Pelando las capas.

Alice tiene ahora un sobre que dice "Para Bob" en el exterior. Representa un mensaje encriptado que sólo Bob puede abrir (descifrar). Alice comenzará ahora el proceso enviando esto a Bob. Todo el proceso se muestra en <<sending_nested_envelopes>>. 

[[sending_nested_envelopes]]
.Sending the envelopes
image::images/mtln_1007.png[Sending the envelopes]

Como puedes ver, Bob recibe el sobre de Alice. Sabe que viene de Alice, pero no sabe si Alice es la remitente original o sólo alguien que reenvía sobres. Lo abre y encuentra un sobre dentro que dice "Para Chan". Como está dirigido a Chan, Bob no puede abrirlo. No sabe qué hay dentro y no sabe si Chan está recibiendo una carta u otro sobre para reenviar. Bob no sabe si Chan es el destinatario final o no. Bob reenvía el sobre a Chan.

Chan recibe el sobre de Bob. No sabe que viene de Alice. No sabe si Bob es un intermediario o el remitente de la carta. Chan abre el sobre y encuentra otro sobre con la dirección "Para Dina", que no puede abrir. Chan lo reenvía a Dina, sin saber si ésta es la destinataria final.

Dina recibe un sobre de Chan. Al abrirlo, encuentra una carta en su interior, por lo que ahora sabe que ella es la destinataria del mensaje. Lee la carta, sabiendo que ninguno de los intermediarios sabe de dónde procede y que nadie más ha leído su carta secreta.

Esta es la esencia del "onion routing". El remitente envuelve un mensaje en capas, especificando exactamente cómo será enrutado e impidiendo que ninguno de los intermediarios obtenga información sobre la ruta o la carga útil. Cada intermediario pela una capa, ve sólo una dirección de reenvío y no sabe nada más que el salto anterior y el siguiente en la ruta.

Ahora, veamos los detalles de la implementación del onion routing en la Red Relámpago.

=== Introducción al enrutamiento en cebolla de los HTLC.

El enrutamiento en cebolla en la Lightning Network parece complejo a primera vista, pero una vez que se entiende el concepto básico, es realmente muy sencillo.

Desde un punto de vista práctico, Alice le dice a cada nodo intermediario qué HTLC debe establecer con el siguiente nodo de la ruta.

El último nodo, que es el receptor del pago o Dina en nuestro ejemplo, se denomina _nodo final_.

Cada nodo intermediario, o Bob y Chan en nuestro ejemplo, se llama _salto_. Cada salto debe establecer una _LLC de salida_ hacia el siguiente salto. La información comunicada a cada salto por Alice se llama _carga útil del salto_ o _datos del salto_. El mensaje que se encamina desde Alice a Dina se llama _onion_ y consiste en mensajes encriptados de _carga útil del salto_ o _datos del salto_ a cada salto.

Ahora que conocemos la terminología utilizada en el enrutamiento de cebolla Lightning, vamos a replantear la tarea de Alice: Alice debe construir una cebolla con datos de salto, indicando a cada salto cómo construir un HTLC saliente para enviar un pago al nodo final (Dina).

==== Alice selecciona la ruta.

A partir del "enrutamiento" sabemos que Alice enviará un pago de 50.000 satoshi a Dina a través de Bob y Chan. Este pago se transmite a través de una serie de HTLCs, como se muestra en <<alice_dina_htlc_path>>. 

[[alice_dina_htlc_path]]
.Payment path with HTLCs from Alice to Dina
image::images/mtln_1008.png[Payment path with HTLCs from Alice to Dina]

Como veremos en <<gossip>>, Alice es capaz de construir esta ruta hacia Dina porque los nodos Lightning anuncian sus canales a toda la Lightning Network utilizando el protocolo Lightning Gossip. Después del anuncio inicial del canal, Bob y Chan enviaron cada uno un mensaje adicional `channel_update` con su tarifa de enrutamiento y sus expectativas de bloqueo de tiempo para el enrutamiento de pago.

A partir de los anuncios y actualizaciones, Alice conoce la siguiente información sobre los canales entre Bob, Chan y Dina:

* Un +short_channel_id+ (ID de canal corto) para cada canal, que Alice puede usar para referenciar el canal cuando construye la ruta

* Un +cltv_expiry_delta+ (delta de bloqueo de tiempo), que Alice puede añadir al tiempo de expiración de cada HTLC

* A +fee_base_msat+ y +fee_proportional_millionths+, que Alice puede utilizar para calcular la tarifa total de enrutamiento esperada por ese nodo para la retransmisión en ese canal.

En la práctica, también se intercambia otra información, como los HTLCs más grandes (`htlc_maximum_msat`) y más pequeños (`htlc_minimum_msat`) que un canal transportará, pero estos no se utilizan tan directamente durante la construcción de la ruta de la cebolla como los campos anteriores.

Esta información es utilizada por Alice para identificar los nodos, canales, fees y timelocks para la siguiente ruta detallada, mostrada en <<alice_dina_path_detail>>. 

[[alice_dina_path_detail]]
.A detailed path constructed from gossiped channel and node information
image::images/mtln_1009.png[A path constructed from gossiped channel and node information]

Alice ya conoce su propio canal hacia Bob y por lo tanto no necesita esta información para construir la ruta. Observa también que Alice no necesita una actualización del canal de Dina porque tiene la actualización de Chan para ese último canal en la ruta.

==== Alice construye las cargas útiles.

Un formato heredado de longitud fija llamado _datos del salto_ y un formato más flexible basado en valores de longitud de tipo (TLV) llamado _carga útil del salto_. El formato de mensaje TLV se explica con más detalle en <<tlv>>. Ofrece flexibilidad al permitir que se añadan campos al protocolo a voluntad.

[NOTE]
====
Ambos formatos están especificados en https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#packet-structure[BOLT #4: Onion Routing Protocol, Packet Structure].
====

Alice comenzará a construir los datos de los saltos desde el final de la ruta hacia atrás: Dina, Chan, luego Bob.

===== Carga útil del nodo final para Dina.

Alice construye primero la carga útil que será entregada a Dina. Dina no construirá un "HTLC saliente", porque Dina es el nodo final y el receptor del pago. Por esta razón, la carga útil para Dina es diferente a todas las demás (utiliza todos los ceros para el "short_channel_id"), pero sólo Dina lo sabrá porque estará encriptada en la capa más interna de la cebolla. Esencialmente, esta es la "carta secreta a Dina" que vimos en nuestro ejemplo del sobre físico.

La carga útil del salto para Dina debe coincidir con la información de la invoice generada por Dina para Alice y contendrá (al menos) los siguientes campos en formato TLV:

+amt_to_forward+:: El importe de este pago en milisatoshis. Si se trata de una sola parte de un pago de varias partes, el importe es inferior al total. En caso contrario, se trata de un único pago completo y es igual al importe de la invoice y al valor de +total_msat+.

+valor_cltv+ de salida:: El plazo de caducidad del pago fijado en el valor +min_final_cltv_expiry+ de la invoice.

+secreto_de_pago+:: Un valor secreto especial de 256 bits de la invoice, que permite a Dina reconocer este pago entrante. Esto también evita una clase de sondeo que anteriormente hacía inseguras las facturas de valor cero. El sondeo por parte de los nodos intermedios se mitiga, ya que este valor está cifrado para _sólo_ el destinatario, lo que significa que no pueden reconstruir un paquete final que "parezca" legítimo.

+total_msat+:: El importe total que corresponde a la invoice. Puede omitirse si sólo hay una parte, en cuyo caso se asume que coincide con +amt_to_forward+ y debe ser igual al importe de la invoice.

La invoice que Alice recibió de Dina especificaba el importe como 50.000 satoshis, que son 50.000.000 milisatoshis. Dina especificó la caducidad mínima para el pago +min_final_cltv_expiry+ como 18 bloques (3 horas, dados los bloques de Bitcoin de 10 minutos de media). En el momento en que Alice intenta realizar el pago, digamos que la blockchain de Bitcoin ha registrado 700.000 bloques. Así que Alice debe establecer el +outgoing_cltv_value+ a una altura de bloque _mínima_ de 700.018.

Alice construye el payload del salto para Dina como sigue:

----
amt_to_forward : 50,000,000
outgoing_cltv_value: 700,018
payment_secret: fb53d94b7b65580f75b98f10...03521bdab6d519143cd521d1b3826
total_msat: 50,000,000
----

Alice lo serializa en formato TLV, como se muestra (simplificado) en <<dina_onion_payload>>. 

[[dina_onion_payload]]
.Dina's payload is constructed by Alice
image::images/mtln_1010.png[Dina's payload is constructed by Alice]

===== Carga útil de saltos para Chan.

A continuación, Alice construye la carga útil del salto para Chan. Esto le dirá a Chan cómo configurar un HTLC saliente hacia Dina.

La carga útil de salto para Chan incluye tres campos: +id_corto_canal+, +amt_to_forward+, y +outgoing_cltv_value+:

----
short_channel_id: 010002010a42be
amt_to_forward: 50,000,000
outgoing_cltv_value: 700,018
----

Alice serializa esta carga útil en formato TLV, como se muestra (simplificado) en <<chan_onion_payload>>. 

[[chan_onion_payload]]
.Chan's payload is constructed by Alice
image::images/mtln_1011.png[Chan's payload is constructed by Alice]

===== Carga útil del salto para Bob.

Finalmente, Alice construye el payload de salto para Bob, que también contiene los mismos tres campos que el payload de salto para Chan, pero con valores diferentes:

----
short_channel_id: 000004040a61f0
amt_to_forward: 50,100,000
outgoing_cltv_value: 700,038
----

Como puedes ver, el campo +amt_to_forward+ es de 50.100.000 milisatoshis, es decir, 50.100 satoshis. Esto se debe a que Chan espera una comisión de 100 satoshis para encaminar un pago a Dina. Para que Chan "gane" esa comisión de enrutamiento, el HTLC entrante de Chan debe ser 100 satoshis más que el HTLC saliente de Chan. Como el HTLC de entrada de Chan es el HTLC de salida de Bob, las instrucciones a Bob reflejan la comisión que gana Chan. En términos sencillos, hay que decirle a Bob que envíe 50.100 satoshi a Chan, para que éste pueda enviar 50.000 satoshi y quedarse con 100 satoshi.

Del mismo modo, Chan espera un delta de bloqueo de tiempo de 20 bloques. Así que el HTLC entrante de Chan debe expirar 20 bloques _más tarde_ que el HTLC saliente de Chan. Para lograr esto, Alice le dice a Bob que haga que su HTLC saliente a Chan expire a una altura de bloque de 700.038-20 bloques más tarde que el HTLC de Chan a Dina.

[TIP]
====
Las expectativas de tasas y delta de bloqueo de tiempo para un canal son establecidas por la diferencia entre los HTLCs entrantes y salientes. Puesto que el HTLC entrante es creado por el _nodo precedente_, el honorario y el delta del timelock se fijan en el payload de la cebolla a ese nodo precedente. A Bob se le indica cómo hacer un HTLC que cumpla con las expectativas de tasa y timelock de Chan.
====

Alice serializa este payload en formato TLV, como se muestra (simplificado) en <<bob_onion_payload>>. 

[[bob_onion_payload]]
.Bob's payload is constructed by Alice
image::images/mtln_1012.png[Bob's payload is constructed by Alice]

===== Cargas útiles de salto terminadas.

Alice ha construido ahora las tres cargas útiles de salto que se envolverán en una cebolla. Una vista simplificada de las cargas útiles se muestra en <<onion_hop_payloads>>.

[[onion_hop_payloads]]
.Hop payloads for all the hops
image::images/mtln_1013.png[Hop payloads for all the hops]

[role="pagebreak-before less_space"]
==== Generación de claves.

Alice debe ahora generar varias claves que se utilizarán para cifrar las distintas capas de la cebolla.

Con estas claves, Alice puede conseguir un alto grado de privacidad e integridad:

* Alice puede encriptar cada capa de la cebolla para que sólo el destinatario previsto pueda leerla.
* Cada intermediario puede comprobar que el mensaje no ha sido modificado.
* Nadie en el camino sabrá quién envió esta cebolla o a dónde va. Alice no revela su identidad como remitente ni la de Dina como destinataria.
* Cada salto sólo conoce el anterior y el siguiente.
* Nadie puede saber cuán largo es el camino, o en qué parte del camino se encuentra.

[WARNING]
====
Como una cebolla picada, los siguientes detalles técnicos pueden hacerte llorar. Siéntase libre de saltar a la siguiente sección si se confunde. Vuelve a esto y lee https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#packet-construction[BOLT #4: Onion Routing, Packet Construction], si quieres aprender más.
====


La base de todas las claves usadas en la cebolla es un _secreto compartido_ que Alice y Bob pueden generar independientemente usando el algoritmo de Curva Elíptica Diffie-Hellman (ECDH). A partir del secreto compartido (ss), pueden generar independientemente cuatro claves adicionales denominadas ++rho++, ++mu++, ++um++ y ++pad++:

++rho++:: Se utiliza para generar un flujo de bytes aleatorios a partir de un cifrado de flujo (utilizado como CSPRNG). Estos bytes se utilizan para encriptar/desencriptar el cuerpo del mensaje, así como los bytes de relleno cero durante el procesamiento de paquetes Sphinx.

++mu++:: Utilizado en el código de autenticación de mensajes basado en hash (HMAC) para la verificación de integridad/autenticidad.

++um++:: Utilizado en la notificación de errores.

++pad++:: Utilizado para generar bytes de relleno para rellenar la cebolla a una longitud fija.

La relación entre las distintas claves y cómo se generan está diagramada en <<onion_keygen>>. 

[[onion_keygen]]
.Onion key generation
image::images/mtln_1014.png[Onion Key Generation]

[[session_key]]
===== La clave de sesión de Alice.

Para evitar revelar su identidad, Alice no utiliza la clave pública de su propio nodo para construir la cebolla. En su lugar, Alice crea una clave temporal de 32 bytes (256 bits) llamada _clave privada de sesión_ y la correspondiente _clave pública de sesión_. Esto sirve como "identidad" y clave temporal _sólo para esta cebolla_. A partir de esta clave de sesión, Alice construirá todas las demás claves que se utilizarán en esta cebolla. 

[[keygen_details]]
===== Detalles de la generación de claves.
La generación de claves, la generación de bytes aleatorios, las claves efímeras y cómo se utilizan en la construcción de paquetes se especifican en tres secciones de BOLT #4:

* https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#key-generation[Generación de claves]]
* https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#pseudo-random-byte-stream[Flujo de bytes aleatorios]
* https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#packet-construction[Construcción de paquetes]

Para simplificar y evitar ponernos demasiado técnicos, no hemos incluido estos detalles en el libro. Consulta los enlaces anteriores si quieres ver el funcionamiento interno.

[[shared_secret]]
===== Generación de secretos compartidos.

Se basa en la invención del intercambio de claves Diffie-Hellman (DH) en los años 70, que revolucionó la criptografía. El enrutamiento de cebollas de Lightning utiliza la curva elíptica Diffie-Hellman (ECDH) en la curva +secp256k1+ de Bitcoin. Es un truco tan genial que intentamos explicarlo en términos sencillos en <<ecdh_explained>>. 


// Para el editor: ¿Tal vez poner esto en un apéndice en lugar de una barra lateral?

[[ecdh]]
[[ecdh_explained]]
.Elliptic Curve Diffie–Hellman Explained
****
Assume Alice's private key is _a_ and Bob's private key is _b_. Using the elliptic curve, Alice and Bob each multiply their private key by the generator point _G_ to produce their public keys _A_ and _B_, respectively:

++++
<ul class="simplelist">
<li><em>A</em> = <em>aG</em></li>
<li><em>B</em> = <em>bG</em></li>
</ul>
++++

Now Alice and Bob can use _Elliptic Curve Diffie–Hellman Key Exchange_ to create a shared secret _ss_, a value that they can both calculate independently without exchanging any information

The shared secret _ss_ is calculated by each by multiplying their own private key with the _other's_ public key, such that:

++++
<ul class="simplelist">
<li><em>ss</em> = <em>aB</em> = <em>bA</em></li>
</ul>
++++

But why would these two multiplications result in the same value _ss_?
Follow along, as we demonstrate the math that proves this is possible:

++++
<ul class="simplelist">
<li><em>ss</em></li>
<li>= <em>aB</em></li>
</ul>
++++

calculated by Alice who knows both _a_ (her private key) and _B_ (Bob's public key)

++++
<ul class="simplelist">
<li>= <em>a</em>(<em>bG</em>)</li>
</ul>
++++

because we know that _B_ = _bG_, we substitute

++++
<ul class="simplelist">
<li> = (<em>ab</em>)<em>G</em></li>
</ul>
++++

because of associativity, we can move the parentheses

++++
<ul class="simplelist">
<li>= (<em>ba</em>)<em>G</em></li>
</ul>
++++

because _xy_ = _yx_ (the curve is an abelian group)

++++
<ul class="simplelist">
<li>= <em>b</em>(<em>aG</em>)</li>
</ul>
++++

because of associativity, we can move the parentheses

++++
<ul class="simplelist">
<li>= <em>bA</em></li>
</ul>
++++

and we can substitute _aG_ with _A_.

The result _bA_ can be calculated independently by Bob who knows _b_ (his private key) and _A_ (Alice's public key).

We have therefore shown that:

++++
<ul class="simplelist">
<li><em>ss</em> = <em>aB</em> (Alice can calculate this)</li>
<li><em>ss</em> = <em>bA</em> (Bob can calculate this)</li>
</ul>
++++

Thus, they can each independently calculate _ss_ which they can use as a shared key to symmetrically encrypt secrets between the two of them without communicating the shared secret.

****

A unique trait of Sphinx as a mix-net packet format is that rather than include a distinct session key for each hop in the route, which would increase the size of the mix-net packet dramatically, a clever _blinding_ scheme is used to deterministically randomize the session key at each hop.

In practice, this little trick allows us to keep the onion packet as compact as possible while still retaining the desired security properties.

The session key for hop `i` is derived using the node public key, and derived shared secret of hop `i – 1`:
```
session_key_i = session_key_{i-1} * SHA-256(node_pubkey_{i-1} || shared_secret_{i-1})
```

En otras palabras, tomamos la clave de sesión del salto anterior y la multiplicamos por un valor derivado de la clave pública y el secreto compartido derivado para ese salto.

Como la multiplicación por curva elíptica puede realizarse sobre una clave pública sin conocer la clave privada, cada salto puede volver a aleatorizar la clave de sesión para el siguiente salto de forma determinista.

El creador del paquete cebolla conoce todos los secretos compartidos (ya que ha cifrado el paquete de forma única para cada salto), y por lo tanto es capaz de derivar todos los factores de cegamiento.

Este conocimiento les permite derivar todas las claves de sesión utilizadas por adelantado durante la generación del paquete.

Ten en cuenta que el primer salto utiliza la clave de sesión original generada porque esta clave se utiliza para iniciar el cegamiento de la clave de sesión por cada salto posterior


[[wrapping_the_onion]]
=== Envolviendo las capas de la cebolla.

El proceso de envolver la cebolla se detalla en https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#packet-construction[BOLT #4: Enrutamiento de la cebolla, construcción de paquetes].

En esta sección describiremos este proceso a un nivel alto y algo simplificado, omitiendo ciertos detalles.
 

[[fixed_length_onions]]
==== Cebollas de longitud fija.

Hemos mencionado el hecho de que ninguno de los nodos de "salto" sabe la longitud del camino, ni en qué parte del mismo se encuentra. ¿Cómo es esto posible?

Si tienes un conjunto de direcciones, aunque estén encriptadas, ¿no puedes saber a qué distancia estás del principio o del final simplemente mirando _en qué lugar_ de la lista de direcciones te encuentras?

El truco utilizado en el onion routing es hacer que la ruta (la lista de direcciones) tenga siempre la misma longitud para cada nodo. Esto se consigue manteniendo el paquete cebolla de la misma longitud en cada paso.

En cada salto, la carga útil del salto aparece al principio de la carga útil de la cebolla, seguida de _lo que parecen ser_ 19 cargas útiles de saltos más. Cada salto se ve como el primero de 20 saltos.

[TIP]
====
La carga útil de la cebolla es de 1.300 bytes. Cada carga útil de salto es de 65 bytes o menos (rellenado a 65 bytes si es menor). Por lo tanto, la carga útil total de la cebolla puede encajar en 20 cargas útiles de saltos (1300 = 20 & veces; 65). Por lo tanto, la ruta máxima de la cebolla es de 20 saltos.
====

A medida que se "pela" cada capa, se añaden más datos de relleno (esencialmente basura) al final de la carga útil de la cebolla, de modo que el siguiente salto recibe una cebolla del mismo tamaño y vuelve a ser el "primer salto" de la cebolla.

El tamaño de la cebolla es de 1.366 bytes, estructurados como se muestra en <<onion_packet>>: 

1 byte:: Un byte de versión
33 bytes:: Una clave de sesión pública comprimida (<<session_key>>) a partir de la cual se puede generar el secreto compartido por salto (<<shared_secret>>) sin revelar la identidad de Alice
1.300 bytes:: La carga útil real de la _onión_ que contiene las instrucciones para cada salto
32 bytes:: Una suma de control de integridad HMAC

[[onion_packet]]
.The onion packet
image::images/mtln_1015.png[]

Un rasgo único de Sphinx como formato de paquete mixto es que en lugar de incluir una clave de sesión distinta para cada salto en la ruta, lo que aumentaría el tamaño del paquete mixto dramáticamente, en su lugar se utiliza un esquema inteligente de _blinding_ para aleatorizar de forma determinista la clave de sesión en cada salto.

En la práctica, este pequeño truco nos permite mantener el paquete cebolla tan compacto como sea posible mientras se mantienen las propiedades de seguridad deseadas.

==== Envoltura de la Cebolla (Esquema).

Aquí está el proceso de envolver la cebolla, esbozado a continuación. Vuelve a esta lista cuando exploremos cada paso con nuestro ejemplo del mundo real.

Para cada salto, el remitente (Alice) repite el mismo proceso:

1. Alice genera el secreto compartido por salto y las claves ++rho++, ++mu++ y ++pad++.

2. Alice genera 1.300 bytes de relleno y rellena el campo de carga útil de cebolla de 1.300 bytes con este relleno.

3. Alice calcula el HMAC para la carga útil del salto (ceros para el salto final).

4. Alice calcula la longitud de la carga útil del salto + HMAC + espacio para almacenar la propia longitud.

5. Alice _desplaza a la derecha_ la carga útil de la cebolla en el espacio calculado necesario para que quepa la carga útil del salto. Los datos de "relleno" de la derecha se descartan, dejando suficiente espacio a la izquierda para la carga útil.

6. Alice inserta la longitud + la carga útil del salto + el HMAC en la parte delantera del campo de carga útil en el espacio creado por el desplazamiento del relleno.

7. Alice utiliza la clave ++rho++ para generar una almohadilla de un solo uso de 1.300 bytes.

8. Alice ofusca toda la carga útil de la cebolla mediante XOR con los bytes generados de ++rho++.

9. Alice calcula el HMAC de la carga útil de la cebolla, utilizando la clave ++mu++.

10. Alice añade la clave pública de la sesión (para que el salto pueda calcular el secreto compartido).

11. Alice añade el número de versión.

12. Alice vuelve a cifrar de forma determinista la clave de sesión utilizando un valor derivado del hash del secreto compartido y de la clave pública del salto anterior.

A continuación, Alice repite el proceso. Se calculan las nuevas claves, se desplaza la carga útil de la cebolla (dejando caer más basura), se añade la carga útil del nuevo salto al frente, y se cifra toda la carga útil de la cebolla con el flujo de bytes ++rho++ para el siguiente salto.

Para el salto final, el HMAC incluido en el paso 3 sobre las instrucciones de texto plano es en realidad _todo cero_.
El salto final utiliza esta señal para determinar que efectivamente es el último salto de la ruta.
Alternativamente, también se puede utilizar el hecho de que el `short_chan_id` incluido en la carga útil para denotar el "siguiente salto" es todo cero.

Nótese que en cada fase la clave ++mu++ se utiliza para generar un HMAC sobre el paquete de cebolla _encriptado_ (desde el punto de vista del nodo que procesa la carga útil), así como sobre el contenido del paquete con una sola capa de encriptación eliminada.
Este HMAC externo permite al nodo que procesa el paquete verificar la integridad del paquete cebolla (sin bytes modificados).
El HMAC interno se revela entonces durante la rutina inversa de "cambiar y encriptar" descrita anteriormente, que sirve como el HMAC _externo_ para el siguiente salto. 

==== Envolviendo la carga útil del salto de Dina.

Como recordatorio, la cebolla se envuelve empezando por el final de la ruta desde Dina, el nodo final o receptor. Luego la ruta se construye en sentido inverso hasta el remitente, Alice.

Alice comienza con un campo vacío de 1.300 bytes, la _carga útil de la cebolla_ de longitud fija. Luego, rellena la carga útil de cebolla con un flujo de bytes pseudoaleatorio "de relleno" que se genera a partir de la clave ++pad++.

Esto se muestra en <<onion_payload_filler>>. 

[NOTE]
====
La generación del flujo de bytes aleatorio utiliza el algoritmo ChaCha20, como generador criptográfico seguro de números pseudoaleatorios (CSPRNG). Dicho algoritmo generará un flujo determinista, largo y no repetitivo de bytes aparentemente aleatorios a partir de una semilla inicial. Los detalles se especifican en https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#pseudo-random-byte-stream[BOLT #4: Onion Routing, Pseudo Random Byte Stream].
====

[[onion_payload_filler]]
.Filling the onion payload with a random byte stream
image::images/mtln_1016.png[]

Alice insertará ahora la carga útil del salto de Dina en el lado izquierdo de la matriz de 1.300 bytes, desplazando el relleno hacia la derecha y descartando todo lo que se desborde. Esto se visualiza en <<onion_add_dina>>. 

[[onion_add_dina]]
.Adding Dina's hop payload
image::images/mtln_1017.png[]

Otra forma de ver esto es que Alice mide la longitud de la carga útil del salto de Dina, desplaza el relleno hacia la derecha para crear un espacio igual en el lado izquierdo de la carga útil de la cebolla, e inserta la carga útil de Dina en ese espacio.

En la siguiente fila vemos el resultado: la carga útil de cebolla de 1.300 bytes contiene la carga útil de salto de Dina y luego el flujo de bytes de relleno que rellena el resto del espacio.

A continuación, Alice ofusca toda la carga útil de la cebolla para que _sólo Dina_ pueda leerla.

Para ello, Alice genera un flujo de bytes utilizando la clave ++rho++ (que Dina también conoce). Alice utiliza una exclusiva de bits o (XOR) entre los bits de la carga útil de la cebolla y el flujo de bytes creado a partir de ++rho++. El resultado aparece como un flujo de bytes aleatorio (o encriptado) de 1.300 bytes de longitud. Este paso se muestra en <<onion_obfuscate_dina>>. 

[[onion_obfuscate_dina]]
.Obfuscating the onion payload
image::images/mtln_1018.png[]

Una de las propiedades de XOR es que si lo haces dos veces, vuelves a los datos originales. Como veremos en <<bobDeobfuscates>>, si Dina aplica la misma operación XOR con el flujo de bytes generado a partir de ++rho++, revelará el payload original de la cebolla.

[TIP]
====
XOR es una función _involutiva_, lo que significa que si se aplica dos veces, se deshace. En concreto, XOR(XOR(_a_, _b_), _b_) = _a_. Esta propiedad se utiliza mucho en la criptografía de clave simétrica.
====

Como sólo Alicia y Dina tienen la clave ++rho++ (derivada del secreto compartido de Alicia y Dina), sólo ellas pueden hacer esto. Efectivamente, esto encripta la carga útil de la cebolla sólo para los ojos de Dina.

Finalmente, Alice calcula un código de autenticación de mensajes basado en hash (HMAC) para la carga útil de Dina, que utiliza la clave ++mu++ como su clave de inicialización. Esto se muestra en <<dina_hop_payload_hmac>>. 

[[dina_hop_payload_hmac]]
.Adding an HMAC integrity checksum to Dina's hop payload
image::images/mtln_1019.png[]

===== Protección y detección de repeticiones en el enrutamiento de Onion.

El HMAC actúa como una suma de comprobación segura y ayuda a Dina a verificar la integridad de la carga útil del salto. El HMAC de 32 bytes se añade a la carga de saltos de Dina.
Ten en cuenta que calculamos el HMAC sobre los datos _encriptados_ en lugar de sobre los datos en texto plano.
Esto se conoce como _encrypt-then-mac_ y es la forma recomendada de utilizar una MAC, ya que proporciona tanto la integridad del texto plano como la del texto cifrado.

El cifrado autentificado moderno también permite el uso de un conjunto opcional de bytes de texto plano que también se autentifica, conocido como _datos asociados_.
En la práctica, esto suele ser algo así como una cabecera de paquete de texto plano u otra información auxiliar.
Al incluir estos datos asociados en la carga útil que se va a autenticar (MAC), el verificador de la MAC se asegura de que estos datos asociados no han sido manipulados (por ejemplo, cambiando la cabecera de texto plano en un paquete cifrado).

En el contexto de la Red Relámpago, estos datos asociados se utilizan para _fortalecer_ la protección contra reproducciones de este esquema.
Como aprenderemos a continuación, la protección contra repeticiones garantiza que un atacante no pueda _retransmitir_ (reproducir) un paquete en la red y observar su trayectoria resultante.
En su lugar, los nodos intermedios son capaces de utilizar las medidas de protección de repetición definidas para detectar y rechazar un paquete repetido.
El formato base de los paquetes Sphinx utiliza un registro de todas las claves secretas efímeras utilizadas para detectar las repeticiones.
Si una clave secreta se vuelve a utilizar, el nodo puede detectarla y rechazar el paquete. 

La naturaleza de los HTLC en la Lightning Network nos permite reforzar aún más la protección contra la repetición añadiendo un incentivo _económico_ adicional.
Recuerda que el hash de pago de un HTLC sólo puede utilizarse de forma segura (para un pago completo) una vez.
Si un hash de pago se utiliza de nuevo y atraviesa un nodo que ya ha visto el secreto de pago para ese hash, ¡entonces pueden simplemente sacar los fondos y cobrar la cantidad completa del pago sin reenviar!
Podemos utilizar este hecho para reforzar la protección contra repeticiones exigiendo que el _hash de pago_ se incluya en nuestro cálculo HMAC como dato asociado.
Con este paso añadido, intentar reproducir un paquete cebolla también requiere que el remitente se comprometa a utilizar el _mismo_ hash de pago.
Como resultado, además de la protección normal contra la repetición, un atacante también puede perder la cantidad total del HTLC reproducido.

Una de las cuestiones que hay que tener en cuenta con el creciente conjunto de claves de sesión almacenadas para la protección contra repeticiones es: ¿son los nodos capaces de recuperar este espacio?
En el contexto de la Red Relámpago, la respuesta es: sí.
Una vez más, debido a los atributos únicos de la construcción HTLC, podemos hacer una mejora adicional sobre el protocolo base Sphinx.
Dado que los HTLC son contratos con _tiempo bloqueado_ basados en la altura absoluta del bloque, una vez que un HTLC ha expirado, el contrato queda cerrado de forma permanente.
Como resultado, los nodos pueden usar esta altura de expiración de CLTV (operador CHECKLOCKTIMEVERIFY) como un indicador para saber cuándo es seguro recolectar la basura de una entrada en el registro anti-reproducción.

==== Envoltura de la carga útil del salto de Chan.

En <<chan_onion_wrapping>> vemos los pasos utilizados para envolver el hop payload de Chan en la cebolla. Estos son los mismos pasos que Alice utilizó para envolver la carga útil del salto de Dina.

[[chan_onion_wrapping]]
.Wrapping the onion for Chan
image::images/mtln_1020.png[]

Alice comienza con la carga útil de cebolla de 1.300 creada para Dina. Los primeros 65 (o menos) bytes de esto son la carga útil de Dina ofuscada y el resto es relleno. Alice debe tener cuidado de no sobrescribir la carga útil de Dina.

A continuación, Alice necesita localizar la clave pública efímera (que se generó al principio de cada salto) que se añadirá al paquete de enrutamiento en este salto.

Recuerda que en lugar de incluir una clave pública efímera única (que el remitente y el nodo intermedio utilizan en una operación ECDH para generar un secreto compartido), Sphinx utiliza una única clave pública efímera que se aleatoriza de forma determinista en cada salto.

Al procesar el paquete, Dina utilizará su secreto compartido y su clave pública para obtener el valor de cegado (`b_dina`) y lo utilizará para volver a aleatorizar la clave pública efímera, en una operación idéntica a la que realiza Alice durante la construcción inicial del paquete.

Alice añade una suma de comprobación HMAC interna a la carga útil de Chan y la inserta en el "frente" (lado izquierdo) de la carga útil de la cebolla, desplazando la carga útil existente hacia la derecha en una cantidad igual.
Recuerda que hay efectivamente _dos_ HMACs usados en el esquema: el HMAC exterior y el HMAC interior.
En este caso, el HMAC _interior_ de Chan es en realidad el HMAC _exterior_ de Dina.

Ahora la carga útil de Chan está en la parte delantera de la cebolla. Cuando Chan ve esto, no tiene idea de cuántas cargas útiles vinieron antes o después. ¡Parece el primero de 20 saltos siempre!

Luego, Alice ofusca toda la carga útil por XOR con el flujo de bytes generado por la clave ++rho++ de Alice-Chan. Sólo Alice y Chan tienen esta clave ++rho++, y sólo ellos pueden producir el flujo de bytes para ofuscar y desofuscar la cebolla.
Finalmente, como hicimos en el paso anterior, calculamos el HMAC externo de Chan, que es lo que usará para verificar la integridad del paquete de cebolla encriptado.

==== Envolviendo la carga útil del salto de Bob.

En <<bob_onion_wrapping>> vemos los pasos utilizados para envolver la carga útil del salto de Bob en la cebolla.

Muy bien, ¡a estas alturas esto es fácil!

Comienza con el payload de la cebolla (ofuscado) que contiene los payloads de salto de Chan y Dina.

Obtén la clave de sesión para este salto derivada del factor de cegamiento generado por el salto anterior.
Incluir el HMAC externo del salto anterior como el HMAC interno de este salto.
Insertar la carga útil del salto de Bob al principio y desplazar todo lo demás a la derecha, eliminando un trozo del tamaño de la carga útil del salto de Bob al final (de todas formas era relleno).

Ofuscar todo el asunto XOR con la clave ++rho++ del secreto compartido Alice-Bob para que sólo Bob pueda desenvolverlo.

Calcula el HMAC exterior y pégalo al final de la carga útil del salto de Bob.

[[bob_onion_wrapping]]
.Wrapping the onion for Bob
image::images/mtln_1021.png[]


==== El paquete final de la cebolla.

La carga útil final de la cebolla está lista para ser enviada a Bob. Alice no necesita añadir más payloads de saltos.

Alice calcula un HMAC para la carga útil de la cebolla para asegurarla criptográficamente con una suma de control que Bob pueda verificar.

Alice añade una clave de sesión pública de 33 bytes que será utilizada por cada salto para generar un secreto compartido y las claves ++rho++, ++mu++ y ++pad++.

Finalmente Alice pone el número de versión de la cebolla (+0+ actualmente) en el frente. Esto permite futuras actualizaciones del formato de los paquetes de cebolla.

El resultado se puede ver en <<onion_packet_2>>.  

[[onion_packet_2]]
.The onion packet
image::images/mtln_1015.png[]

=== Envío de la cebolla.

En esta sección veremos cómo se reenvía el paquete cebolla y cómo se despliegan los HTLC a lo largo de la ruta.

==== El mensaje update_add_htlc.

Los paquetes Onion se envían como parte del mensaje +update_add_htlc+. Si recuerdas de <<update_add_htlc>>, en <<channel_operation>>, vimos que el contenido del mensaje +update_add_htlc+ es el siguiente:

----
[channel_id:channel_id]
[u64:id]
[u64:amount_msat]
[sha256:payment_hash]
[u32:cltv_expiry]
[1366*byte:onion_routing_packet]
----

Recordarás que este mensaje es enviado por un socio del canal para pedir al otro socio del canal que añada un HTLC. Así es como Alice pedirá a Bob que añada un HTLC para pagar a Dina. Ahora entiendes el propósito del último campo, +onion_routing_packet+, que tiene 1.366 bytes de longitud. ¡Es el paquete cebolla completamente envuelto que acabamos de construir!

==== Alice envía la cebolla a Bob.

Alice enviará el mensaje +update_add_htlc+ a Bob. Veamos lo que contendrá este mensaje:

+channel_id+:: Este campo contiene el ID del canal Alice-Bob, que en nuestro ejemplo es +0000031e192ca1+ (ver <<alice_dina_path_detail>>).

+id+:: El ID de este HTLC en este canal, empezando por +0+.

+importe_msat+:: El importe del HTLC: 50.200.000 milisatoshis.

+payment_hash+:: El hash de pago RIPEMD160(SHA-256):
+
+9e017f6767971ed7cea17f98528d5f5c0ccb2c71+.

+cltv_expiry+:: El timelock de expiración para el HTLC será de 700,058. Alice añade 20 bloques al conjunto de expiración en la carga útil de Bob según el +cltv_expiry_delta+ negociado por Bob.

+paquete_de_enrutamiento+:: El paquete cebolla final que Alice construyó con todas las cargas útiles de los saltos.

==== Bob comprueba la cebolla.

Como vimos en <<channel_operation>>, Bob añadirá el HTLC a las transacciones de compromiso y actualizará el estado del canal con Alice.

Bob desenvolverá la cebolla que recibió de Alice de la siguiente manera:

1. Bob toma la clave de sesión del paquete cebolla y obtiene el secreto compartido Alice-Bob.

2. Bob genera la clave ++mu++ a partir del secreto compartido y la utiliza para verificar la suma de comprobación HMAC del paquete de cebolla.

Ahora que Bob ha generado la clave compartida y verificado el HMAC, puede empezar a desenvolver la carga útil de cebolla de 1.300 bytes dentro del paquete de cebolla. El objetivo es que Bob recupere su propia carga útil de salto y luego reenvíe el resto de la cebolla al siguiente salto.

Si Bob extrae y elimina su carga útil de salto, la cebolla restante no tendrá 1.300 bytes, ¡será más corta! Así, el siguiente salto sabrá que no es el primer salto y podrá detectar la longitud del camino. Para evitar esto, Bob necesita añadir más relleno para rellenar la cebolla.

==== Bob genera relleno.

Bob genera el relleno de una manera ligeramente diferente a la de Alice, pero siguiendo el mismo principio general.

Primero, Bob _extiende_ la carga útil de la cebolla en 1.300 bytes y los rellena con valores +0+. Ahora el paquete cebolla tiene 2.600 bytes, con la primera mitad conteniendo los datos que Alice envió y la siguiente mitad conteniendo ceros. Esta operación se muestra en <<bob_extends>>. 

[[bob_extends]]
.Bob extends the onion payload by 1,300 (zero-filled) bytes
image::images/mtln_1023.png["Bob extends the onion payload by 1,300 (zero-filled) bytes"]

Este espacio vacío se ofuscará y se convertirá en "relleno" por el mismo proceso que Bob utiliza para desofuscar su propia carga útil del salto. Veamos cómo funciona.

[[bobDeobfuscates]]
==== Bob desofusca su carga útil de salto.

A continuación, Bob generará la clave ++rho++ a partir de la clave compartida Alice-Bob. Usará esto para generar un flujo de 2.600 bytes, usando el algoritmo ChaCha20.

[TIP]
====
Los primeros 1.300 bytes del flujo de bytes generado por Bob son exactamente los mismos que los generados por Alice usando la clave ++rho++.
====

A continuación, Bob aplica los 2.600 bytes del flujo de bytes ++rho++ a la carga útil de la cebolla de 2.600 bytes con una operación XOR a nivel de bits.

Los primeros 1.300 bytes serán desofuscados por esta operación XOR, porque es la misma operación que aplicó Alice y XOR es involuntaria. Así que Bob _revelará_ su carga de salto seguida de algunos datos que parecen revueltos.

Al mismo tiempo, aplicando el flujo de bytes ++rho++ a los 1.300 ceros que se añadieron a la carga útil de la cebolla los convertirá en datos de relleno aparentemente aleatorios. Esta operación se muestra en <<bob_deobfuscates>>.

[[bob_deobfuscates]]
.Bob de-obfuscates the onion, obfuscates the filler
image::images/mtln_1024.png["Bob de-obfuscates the onion, obfuscates the filler"]

==== Bob extrae el HMAC exterior para el siguiente salto.

Recuerda que se incluye un HMAC interno para cada salto, que luego se convertirá en el HMAC externo para el _siguiente_ salto.
En este caso, Bob extrae el HMAC interno (ya ha verificado la integridad del paquete encriptado con el HMAC externo), y lo pone a un lado porque lo añadirá al paquete desofuscado para permitir a Chan verificar el HMAC de su paquete encriptado. 

==== Bob retira su carga útil y desplaza la cebolla hacia la izquierda.

Ahora Bob puede eliminar su carga útil de salto de la parte delantera de la cebolla y desplazar a la izquierda los datos restantes. Una cantidad de datos igual a la carga útil de salto de Bob de la segunda mitad de 1.300 bytes de relleno se desplazará ahora al espacio de carga útil de la cebolla. Esto se muestra en <<bob_removes_shifts>>. 

Ahora Bob puede mantener la primera mitad de 1.300 bytes, y descartar los 1.300 bytes extendidos (de relleno).

Bob tiene ahora un paquete cebolla de 1.300 bytes para enviar al siguiente salto. Es casi idéntico a la carga útil de cebolla que Alice había creado para Chan, excepto que los últimos 65 bytes de relleno fueron puestos por Bob y serán diferentes.

[[bob_removes_shifts]]
.Bob removes the hop payload and left-shifts the rest, filling the gap with new filler
image::images/mtln_1025.png["Bob removes the hop payload and left-shifts the rest, filling the gap with new filler"]

[role="pagebreak-before"]
Nadie puede decir la diferencia entre el relleno puesto por Alice y el relleno puesto por Bob. ¡El relleno es el relleno! De todos modos, todo son bytes aleatorios. Ten en cuenta que si Bob (o uno de los otros alias de Bob) está presente en la ruta en dos lugares distintos, entonces pueden notar la diferencia porque el protocolo base siempre utiliza el mismo hash de pago a través de toda la ruta. Los pagos atómicos multitrayectoria (AMP) y los contratos de tiempo fijo (PTLC) eliminan el vector de correlación al aleatorizar el identificador de pago en cada ruta/salto.

==== Bob construye el nuevo paquete de cebolla.

Bob ahora copia la carga útil de la cebolla en el paquete de cebolla, añade el HMAC externo para chan, vuelve a aleatorizar la clave de sesión (de la misma manera que Alice el remitente) con la operación de multiplicación de la curva elíptica, y añade un byte de versión fresco.

Para volver a aleatorizar la clave de sesión, Bob primero calcula el factor de cegamiento para su salto, utilizando su clave pública de nodo y el secreto compartido que obtuvo:
```
b_bob = SHA-256(P_bob || shared_secret_bob)
```

Una vez generado esto, Bob vuelve a aleatorizar la clave de sesión realizando una multiplicación EC utilizando su clave de sesión y el factor de cegamiento:
```
session_key_chan = session_key_bob * b_bob
```

La clave pública de `clave_de_sesión_chan` será entonces añadida al frente del paquete de cebolla para ser procesada por Chan.

==== Bob verifica los detalles del HTLC.

La carga útil del salto de Bob contiene las instrucciones necesarias para crear un HTLC para Chan.

En la carga útil del salto, Bob encuentra un +id_corto_canal+, +amt_to_forward+, y +cltv_expiry+.

Primero, Bob comprueba si tiene un canal con ese ID corto. Comprueba que tiene ese canal con Chan.

A continuación, Bob confirma que la cantidad saliente (50.100 satoshis) es menor que la cantidad entrante (50.200 satoshis) y, por lo tanto, se cumplen las expectativas de pago de Bob.

Del mismo modo, Bob comprueba que el +cltv_expiry+ saliente es menor que el +cltv_expiry+ entrante, lo que da a Bob tiempo suficiente para reclamar el HTLC entrante si hay un incumplimiento.

==== Bob envía el update_add_htlc a Chan.

Bob ahora construye y HTLC para enviar a Chan, como sigue:

+channel_id+:: Este campo contiene el ID del canal Bob-Chan, que en nuestro ejemplo es +000004040a61f0+ (ver <<alice_dina_path_detail>>).

+id+:: El ID de este HTLC en este canal, empezando por +0+.

+importe_msat+:: El importe del HTLC: 50.100.000 milisatoshis.

+payment_hash+:: El hash de pago RIPEMD160(SHA-256):
+
+9e017f6767971ed7cea17f98528d5f5c0ccb2c71+. 
+
Esto es lo mismo que el hash de pago del HTLC de Alice.

+cltv_expiry+:: El timelock de expiración del HTLC será de 700.038.

+paquete_de_enrutamiento+:: El paquete de cebolla que Bob reconstruyó después de eliminar su carga útil de saltos.

==== Chan reenvía la cebolla.

Chan repite exactamente el mismo proceso que Bob:

1. Chan recibe el +update_add_htlc+ y procesa la petición HTLC, añadiéndola a las transacciones de compromiso.

2. Chan genera la clave compartida Alice-Chan y la subclave ++mu++.

3. Chan verifica el HMAC del paquete de cebolla, y luego extrae la carga útil de cebolla de 1.300 bytes.

4. Chan extiende la carga útil de la cebolla en 1.300 bytes extra, llenándola de ceros.

5. Chan utiliza la clave ++rho++ para producir 2.600 bytes.

6. Chan utiliza el flujo de bytes generado para XOR y desofuscar la carga útil de la cebolla. Simultáneamente, la operación XOR ofusca los 1.300 ceros extra, convirtiéndolos en relleno. 

7. Chan extrae el HMAC interno de la carga útil, que se convertirá en el HMAC externo para Dina.

8. Chan elimina su carga útil del salto y desplaza a la izquierda la carga útil de la cebolla en la misma cantidad. Parte del relleno generado en los 1.300 bytes extendidos se mueve hacia la primera mitad de los 1.300 bytes, convirtiéndose en parte de la carga útil de la cebolla.

9. Chan construye el paquete cebolla para Dina con esta carga útil cebolla.

10. Chan construye un mensaje +update_add_htlc+ para Dina e inserta en él el paquete cebolla.

11. Chan envía el +update_add_htlc+ a Dina.

12. Chan vuelve a aleatorizar la clave de sesión como hizo Bob en el salto anterior para Dina. 

==== Dina recibe la carga de pago final.

Cuando Dina recibe el mensaje +update_add_htlc+ de Chan, sabe por el +payment_hash+ que se trata de un pago para ella. Sabe que es el último salto de la cebolla.

Dina sigue exactamente el mismo proceso que Bob y Chan para verificar y desenvolver la cebolla, excepto que no construye un nuevo relleno y no reenvía nada. En su lugar, Dina responde a Chan con +update_fulfill_htlc+ para canjear el HTLC. El +update_fulfill_htlc+ fluirá hacia atrás a lo largo del camino hasta llegar a Alice. Todos los HTLCs son redimidos y los balances de los canales son actualizados. El pago se ha completado.

=== Devolución de errores.

Hasta ahora hemos visto la propagación hacia adelante de la cebolla estableciendo los HTLCs y la propagación hacia atrás del secreto de pago desenrollando los HTLCs una vez que el pago es exitoso.

Hay otra función muy importante del enrutamiento de la cebolla: La devolución de errores. Si hay un problema con el pago, la cebolla o los saltos, debemos propagar un error hacia atrás para informar a todos los nodos del fallo y deshacer cualquier HTLC.

Los errores se dividen generalmente en tres categorías: fallos de la cebolla, fallos del nodo y fallos del canal. Además, pueden subdividirse en errores permanentes y transitorios. Por último, algunos errores contienen actualizaciones del canal para ayudar en futuros intentos de entrega de pagos.

[NOTE]
====
A diferencia de los mensajes del protocolo peer-to-peer (P2P) (definido en https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md[BOLT #2: Peer Protocol for Channel Management]), los errores no se envían como mensajes P2P, sino que se envuelven dentro de paquetes de retorno de cebolla y siguen el camino inverso al de la cebolla (back-propagating).
====

La devolución de errores se define en https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#returning-errors[BOLT #4: Onion Routing, Returning Errors].

Los errores son codificados por el nodo que los devuelve (el que descubrió un error) en un _paquete de retorno_ como sigue:

----
    [32*byte:hmac]
    [u16:failure_len]
    [failure_len*byte:failuremsg]
    [u16:pad_len]
    [pad_len*byte:pad]
----

La suma de verificación HMAC del paquete de retorno se calcula con la clave ++um++, generada a partir del secreto compartido establecido por la cebolla.

[TIP]
====
El nombre de la clave ++um++ es el reverso del nombre ++mu++, indicando el mismo uso pero en la dirección opuesta (retropropagación). 
====

A continuación, el nodo de retorno genera una clave +ammag+ (inversa de la palabra "gamma") y ofusca el paquete de retorno mediante una operación XOR con un flujo de bytes generado a partir de +ammag+.

Finalmente, el nodo de retorno envía el paquete de vuelta al salto del que recibió la cebolla original.

Cada salto que reciba un error generará una clave +ammag+ y ofuscará el paquete de retorno de nuevo utilizando una operación XOR con el flujo de bytes de +ammag+.

Finalmente, el remitente (nodo de origen) recibe un paquete de retorno. Entonces generará las claves +ammag+ y ++um++ para cada salto y desofuscará el error de retorno iterativamente hasta que revele el paquete de retorno.

[[failure_messages]]
==== Mensajes de fallo.

El +failuremsg+ está definido en https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#failure-messages[BOLT #4: Onion Routing, Failure Messages].

Un mensaje de fallo consiste en un +código de fallo+ de dos bytes seguido de los datos aplicables a ese tipo de fallo.

El byte superior del +código de fallo+ es un conjunto de banderas binarias que pueden combinarse (con OR binario):


0x8000 (`BADONION`):: Cebolla no parsable encriptada por el peer emisor
0x4000 (`PERM`):: Fallo permanente (si no, transitorio)
0x2000 (`NODE`):: Fallo del nodo (en caso contrario, canal)
0x1000 (`UPDATE`):: Se adjunta una nueva actualización del canal


Los tipos de fallo mostrados en <<failure_types_table>> están definidos actualmente.

include::failure_types_table.asciidoc[]

[[stuck_payments]]
===== Pagos atascados.

En la implementación actual de la Lightning Network, existe la posibilidad de que un intento de pago se quede _atrapado_: ni se cumple ni se cancela por un error. Esto puede ocurrir debido a un error en un nodo intermediario, a que un nodo se desconecte mientras maneja HTLCs, o a que un nodo malicioso retenga HTLCs sin informar de un error. En todos estos casos, el HTLC no puede resolverse hasta que expire. El bloqueo de tiempo (CLTV) que se establece en cada HTLC ayuda a resolver esta condición (entre otros posibles fallos de enrutamiento y canal de HTLC).

Sin embargo, esto significa que el remitente del HTLC tiene que esperar hasta que expire, y los fondos comprometidos en ese HTLC siguen sin estar disponibles hasta que el HTLC expire. Además, el remitente no puede reintentar ese mismo pago, porque si lo hace, corre el riesgo de que tanto el pago original como el reintentado tengan éxito: el destinatario recibe dos veces el pago. Esto se debe a que, una vez enviado, un HTLC no puede ser "cancelado" por el remitente, sino que tiene que fallar o expirar. Los pagos atascados, aunque raros, crean una experiencia de usuario no deseada, en la que el monedero del usuario no puede pagar o cancelar un pago. 

[[keysend]]
=== Pagos espontáneos de Keysend.

En el flujo de pago descrito anteriormente en el capítulo, asumimos que Dina recibió una invoice de Alice "fuera de banda", o la obtuvo a través de algún mecanismo no relacionado con el protocolo (típicamente copiar/pegar o escaneos de códigos QR). Este rasgo significa que el proceso de pago siempre tiene dos pasos: en primer lugar, el remitente obtiene una invoice y, en segundo lugar, utiliza el hash del pago (codificado en la invoice) para encaminar con éxito un HTLC. El viaje de ida y vuelta adicional necesario para obtener una invoice antes de realizar un pago puede ser un cuello de botella en las aplicaciones que implican la transmisión de micropagos a través de Lightning. ¿Qué pasaría si pudiéramos "empujar" un pago de forma espontánea, sin tener que obtener primero una invoice del destinatario? El protocolo `keysend` es una extensión de extremo a extremo (sólo el remitente y el destinatario son conscientes) del protocolo Lightning que permite los pagos push espontáneos.

==== Registros TLV personalizados de Onion.

El moderno protocolo Lightning utiliza la codificación TLV (Type-Length-Value) en la cebolla para codificar la información que indica a cada nodo _dónde_ y _cómo_ reenviar el pago. Aprovechando el formato TLV, cada pieza de información de enrutamiento
(como el siguiente nodo al que pasar el HTLC) se le asigna un tipo específico (o clave) codificado como un entero de longitud variable `BigSize` (de tamaño máximo como un entero de 64 bits). Estos tipos "esenciales" (valores invertidos por debajo de `65536`) se definen en BOLT #4, junto con el resto de los detalles de enrutamiento de la cebolla. Los tipos de cebolla con un valor superior a `65536` están destinados a ser utilizados por los monederos y las aplicaciones como "registros personalizados".

Los registros personalizados permiten a las aplicaciones de pago adjuntar metadatos adicionales o contexto a un pago como pares clave/valor en la cebolla. Dado que los registros personalizados se incluyen en la propia carga útil de la cebolla, al igual que el resto de los contenidos del salto, los registros están cifrados de extremo a extremo. Como los registros personalizados consumen efectivamente una parte del paquete de cebolla de tamaño fijo de 1300 bytes, codificar cada clave y valor de cada registro personalizado reduce la cantidad de espacio disponible para codificar el resto de la ruta. En la práctica, esto significa que cuanto más espacio de cebolla se utilice para los registros personalizados, más corta puede ser la ruta. Dado que cada paquete HTLC es de tamaño fijo, los registros personalizados no _añaden_ ningún dato adicional a un HTLC; más bien, reasignan bytes que de otro modo se habrían llenado con datos aleatorios.

==== Envío y recepción de pagos con llave.

Un pago `keysend` invierte el flujo típico de un HTLC en el que el receptor revela una preimagen secreta al emisor. En su lugar, el emisor incluye la preimagen _dentro_ de la cebolla al receptor, y dirige el HTLC al receptor. El receptor descifra entonces la carga útil de la cebolla, y utiliza la imagen previa incluida (que _debe_ coincidir con el hash de pago del HTLC) para liquidar el pago. Como resultado, los pagos `keysend` pueden llevarse a cabo sin obtener primero una invoice del receptor, ya que la imagen previa es "empujada" hacia el receptor. Un pago `keysend` utiliza un tipo de registro personalizado TLV de `5482373484` para codificar un valor de preimagen de 32 bytes.

==== Keysend y registros personalizados en aplicaciones Lightning.

Muchas aplicaciones Lightning de streaming utilizan el protocolo `keysend` para transmitir continuamente satoshis a un destino identificado por su clave pública en la red.
Normalmente, una aplicación también incluirá metadatos, como una nota de propina/donación u otra información a nivel de aplicación, además del registro `keysend`.

=== Conclusión.

El protocolo de enrutamiento de cebollas de Lightning Network está adaptado del protocolo Sphinx para servir mejor a las necesidades de una red de pagos. Como tal, ofrece una enorme mejora en la privacidad y la contra-vigilancia en comparación con la blockchain pública y transparente de Bitcoin.

En <<path_finding>> veremos cómo la combinación de source routing y onion routing es utilizada por Alice para encontrar una buena ruta y dirigir el pago a Dina. Para encontrar un camino, Alice primero necesita aprender sobre la topología de la red, que es el tema de <<gossip>>. 

[[gossip]]
== Chismes y el gráfico de canales.

En este capítulo describiremos el gossip protocol de la Red Relámpago y cómo lo utilizan los nodos para construir y mantener un gráfico de canales. También revisaremos el mecanismo de arranque del DNS utilizado para encontrar compañeros con los que "cotillear".

La sección "Tasas de enrutamiento y retransmisión de cotilleos" está resaltada por un esquema que abarca la capa de enrutamiento y la capa peer-to-peer de <<LN_protocol_gossip_highlight>>.

[[LN_protocol_gossip_highlight]]
.Gossip protocol in the Lightning protocol suite
image::images/mtln_1101.png["Gossip protocol in the Lightning protocol suite"]

Como ya hemos aprendido, la Lightning Network utiliza un protocolo de enrutamiento de cebolla basado en la fuente para entregar un pago de un remitente al destinatario.
Para ello, el nodo emisor debe ser capaz de construir una ruta de canales de pago que lo conecte con el receptor, como veremos en <<path_finding>>.
Así, el emisor tiene que ser capaz de mapear la Lightning Network construyendo un grafo de canales.
El _grafo de canales_ es el conjunto interconectado de canales anunciados públicamente y los nodos que estos canales interconectan.

Como los canales están respaldados por una funding transaction que está ocurriendo en la cadena, uno podría creer falsamente que los nodos Lightning podrían simplemente extraer los canales existentes de la blockchain de Bitcoin.
Sin embargo, esto sólo es posible hasta cierto punto.
Las transacciones de financiación son direcciones Pay-to-Witness-Script-Hash (P2WSH), y la naturaleza del script (un multisig 2-de-2) sólo se revelará una vez que se gaste la salida de la funding transaction.
Incluso si se conociera la naturaleza del script, es importante recordar que no todos los scripts 2-de-2 multisig corresponden a canales de pago.

Hay incluso más razones por las que mirar la blockchain de Bitcoin podría no ser útil.
Por ejemplo, en la Lightning Network, las claves de Bitcoin que se utilizan para firmar son rotadas por los nodos para cada canal y actualización.
Por lo tanto, incluso si pudiéramos detectar de forma fiable las transacciones de financiación en la blockchain de Bitcoin, no sabríamos qué dos nodos de la Lightning Network son los propietarios de ese canal en particular.

La Lightning Network resuelve este problema implementando un _protocolo de cotilleo_.
Los protocolos Gossip son típicos de las redes peer-to-peer (P2P) y permiten a los nodos compartir información con toda la red con sólo unas pocas conexiones directas con los pares.
Los nodos Lightning abren conexiones peer-to-peer encriptadas entre sí y comparten (gossip) la información que han recibido de otros peers.
En cuanto un nodo quiere compartir alguna información, por ejemplo, sobre un canal recién creado, envía un mensaje a todos sus pares.
Al recibir un mensaje, un nodo decide si el mensaje recibido es novedoso y, en caso afirmativo, reenvía la información a sus compañeros.
De este modo, si la red de pares está bien conectada, toda la información nueva que sea necesaria para el funcionamiento de la red acabará propagándose a todos los demás pares.

Obviamente, si un nuevo peer se une a la red por primera vez, necesita conocer a algunos otros peers de la red, para poder conectarse con otros y participar en la red.

En este capítulo, exploraremos exactamente _cómo_ los nodos del rayo se descubren entre sí, descubren y actualizan su estado de nodo, y se comunican entre sí.

Cuando la mayoría se refiere a la parte de la _red_ de la Lightning Network, se refiere al _grafo de canales_, que a su vez es una estructura de datos única y autentificada _anclada_ en la blockchain base de Bitcoin.

Sin embargo, la Lightning Network también es una red de nodos entre pares que cotillean información sobre los canales de pago y los nodos. Normalmente, para que dos pares mantengan un payment channel necesitan hablar entre ellos directamente, lo que significa que habrá una conexión entre pares.
Esto sugiere que el gráfico de canales es una subred de la red de pares.
Sin embargo, esto no es cierto porque los canales de pago pueden permanecer abiertos incluso si uno o ambos pares se desconectan temporalmente.

Volvamos a repasar parte de la terminología que hemos utilizado a lo largo del libro, y veamos específicamente lo que significan en términos del grafo de canales y de la red de pares (ver <<network_terminology>>).

[[network_terminology]]
.Terminology of the different networks
[options="header"]
|===
| Channel graph  |Peer-to-peer network
|  channel | connection
| open | connect
| close | disconnect
|  funding transaction | encrypted TCP/IP connection
| send	|	transmit
| payment |  message
|===

Dado que la Red Relámpago es una red entre pares, es necesario realizar un arranque inicial para que los pares se descubran mutuamente.  En este capítulo seguiremos la historia de un nuevo peer que se conecta a la red por primera vez y examinaremos cada paso del proceso de bootstrapping, desde el descubrimiento inicial del peer hasta la sincronización y validación del gráfico del canal. 

Como paso inicial, nuestro nuevo nodo necesita de alguna manera _descubrir_ al menos _un_ par que ya esté conectado a la red y tenga un gráfico de canal completo (como veremos más adelante, no hay una versión canónica del gráfico de canal). Usando uno de los muchos protocolos de arranque iniciales para encontrar ese primer par, después de establecer una conexión, nuestro nuevo par necesita ahora _descargar_ y _validar_ el gráfico del canal. Una vez validado el gráfico de canales, nuestro nuevo peer está listo para empezar a abrir canales y enviar pagos en la red.

Después del arranque inicial, un nodo en la red necesita continuar manteniendo su visión del gráfico de canales procesando nuevas actualizaciones de la política de enrutamiento de canales, descubriendo y validando nuevos canales, eliminando los canales que han sido cerrados en la cadena, y finalmente podando los canales que no envían un "latido" adecuado cada dos semanas aproximadamente.

Una vez completado este capítulo, entenderás un componente clave de la Lightning Network peer-to-peer: concretamente, cómo los peers se descubren entre sí y mantienen una copia local (perspectiva) del gráfico de canales. Comenzaremos explorando la historia de un nuevo nodo que acaba de arrancar y necesita encontrar otros pares a los que conectarse en la red.

[role="pagebreak-before less_space"]
=== Descubrimiento de pares.

En esta sección, comenzaremos a seguir a un nuevo nodo Lightning que desea unirse a la red a través de tres pasos:

. Descubrir un conjunto de peers de arranque
. Descargar y validar el gráfico del canal
. Comenzar el proceso de mantenimiento continuo del propio gráfico del canal


==== P2P Bootstrapping.

Antes de hacer cualquier otra cosa, nuestro nuevo nodo necesita descubrir un conjunto de pares que ya formen parte de la red. Llamamos a este proceso bootstrapping inicial de pares, y es algo que toda red peer-to-peer necesita implementar adecuadamente para asegurar una red robusta y saludable.

La incorporación de nuevos usuarios a redes peer-to-peer ya existentes es un problema muy estudiado con varias soluciones conocidas, cada una con sus propias ventajas y desventajas. La solución más simple a este problema es simplemente empaquetar un conjunto de pares de arranque _hardcoded_ en el software de nodo P2P empaquetado. Esto es simple en el sentido de que cada nuevo nodo tiene una lista de pares de arranque en el software que están ejecutando, pero bastante frágil dado que si el conjunto de pares de arranque se desconecta, entonces ningún nuevo nodo será capaz de unirse a la red. Debido a esta fragilidad, esta opción se suele utilizar como alternativa en caso de que ninguno de los otros mecanismos de arranque P2P funcione correctamente.

En lugar de codificar el conjunto de pares de arranque dentro del propio software/binario, podemos permitir que los pares obtengan dinámicamente un nuevo conjunto de pares de arranque que puedan utilizar para unirse a la red. Llamaremos a este proceso _descubrimiento inicial de pares_. Normalmente, aprovecharemos los protocolos de Internet existentes para mantener y distribuir un conjunto de pares de arranque. Una lista no exhaustiva de protocolos que se han utilizado en el pasado para realizar el descubrimiento inicial de pares incluye:

  * Servicio de nombres de dominio (DNS)
  * Internet Relay Chat (IRC)
  * Protocolo de transferencia de hipertexto (HTTP)

Al igual que el protocolo de Bitcoin, el principal mecanismo de descubrimiento inicial de pares utilizado en la Lightning Network se realiza a través del DNS. Dado que el descubrimiento inicial de pares es una tarea crítica y universal para la red, el proceso ha sido _estandarizado_ en https://github.com/lightningnetwork/lightning-rfc/blob/master/10-dns-bootstrap.md[BOLT #10: DNS Bootstrap].

==== Bootstrapping de DNS.

El documento https://github.com/lightningnetwork/lightning-rfc/blob/master/10-dns-bootstrap.md[BOLT #10] describe una forma estandarizada de implementar el descubrimiento de pares utilizando el DNS. La versión de Lightning del bootstrapping basado en DNS utiliza hasta tres tipos de registros distintos:

  *Registros +SRV+ para descubrir un conjunto de _claves públicas de nodo_.
  * Registros +A+ para asignar la clave pública de un nodo a su dirección +IPv4+ actual.
  * Registros +AAA+ para asignar la clave pública de un nodo a su dirección +IPv6+ actual.

Aquellos que estén algo familiarizados con el protocolo DNS puede que ya conozcan los tipos de registro +A+ (nombre a dirección IPv4) y +AAA+ (nombre a dirección IPv6), pero no el tipo +SRV+. El tipo de registro +SRV+ es utilizado por los protocolos construidos sobre el DNS para determinar la _localización_ de un servicio específico. En nuestro contexto, el servicio en cuestión es un nodo de rayos determinado, y la ubicación es su dirección IP. Necesitamos utilizar este tipo de registro adicional porque, a diferencia de los nodos dentro del protocolo Bitcoin, necesitamos tanto una clave pública _y_ una dirección IP para conectarnos a un nodo. Como vemos en <<wire_protocol>>, el protocolo de encriptación de transporte utilizado en la Lightning Network requiere conocer la clave pública de un nodo antes de conectarse, para implementar la ocultación de la identidad de los nodos en la red. 

===== Flujo de trabajo de arranque de un nuevo peer.

Antes de entrar en los detalles de https://github.com/lightningnetwork/lightning-rfc/blob/master/10-dns-bootstrap.md[BOLT #10], describiremos primero el flujo de alto nivel de un nuevo nodo que desea utilizar BOLT #10 para unirse a la red.

En primer lugar, un nodo necesita identificar un único servidor DNS o un conjunto de servidores DNS que entiendan BOLT #10 para poder utilizarlo en el arranque P2P.

Aunque BOLT #10 utiliza _lseed.bitcoinstats.com_ como servidor de semillas, no existe un conjunto "oficial" de semillas DNS para este propósito, sino que cada una de las principales implementaciones mantiene su propia semilla DNS, y se consultan mutuamente las semillas con fines de redundancia. En <<dns_seeds>> verás una lista no exhaustiva de algunos servidores de semillas DNS populares.

[[dns_seeds]]
.Table of known Lightning DNS seed servers
[options="header"]
|===
| DNS server     | Maintainer
| _lseed.bitcoinstats.com_ | Christian Decker
| _nodes.lightning.directory_ | Lightning Labs (Olaoluwa Osuntokun)
| _soa.nodes.lightning.directory_ | Lightning Labs (Olaoluwa Osuntokun)
| _lseed.darosior.ninja_ | Antoine Poinsot
|===


Existen semillas DNS tanto para la red principal de Bitcoin como para la red de pruebas. Por el bien de nuestro ejemplo, asumiremos la existencia de una semilla DNS BOLT #10 válida en _nodes.lightning.directory_.

A continuación, nuestro nuevo nodo emitirá una consulta +SRV+ para obtener un conjunto de _candidatos a ser bootstrap peers_. La respuesta a nuestra consulta será una serie de claves públicas codificadas en bech32. Dado que el DNS es un protocolo basado en texto, no podemos enviar datos binarios en bruto, por lo que es necesario un esquema de codificación. BOLT #10 especifica una codificación bech32 debido a su uso en el ecosistema más amplio de Bitcoin. El número de claves públicas codificadas que se devuelven depende del servidor que devuelve la consulta, así como de todos los resolvedores que se interponen entre el cliente y el servidor autorizado.

Utilizando la herramienta de línea de comandos +dig+, ampliamente disponible, podemos consultar la versión _testnet_ de la semilla DNS mencionada anteriormente con el siguiente comando:

----
$ dig @8.8.8.8 test.nodes.lightning.directory SRV
----

Utilizamos el argumento +@+ para forzar la resolución a través del servidor de nombres de Google (con la dirección IP 8.8.8.8) porque no filtra las respuestas de consulta SRV grandes. Al final del comando, especificamos que sólo queremos que se devuelvan registros +SRV+. Un ejemplo de respuesta se parece a <<ex1101>>.

[[ex1101]]
.Querying the DNS seed for reachable nodes
====
----
$ dig @8.8.8.8 test.nodes.lightning.directory SRV

; <<>> DiG 9.10.6 <<>> @8.8.8.8 test.nodes.lightning.directory SRV
; (1 server found)
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 43610
;; flags: qr rd ra; QUERY: 1, ANSWER: 25, AUTHORITY: 0, ADDITIONAL: 1

;; QUESTION SECTION:
;test.nodes.lightning.directory.	IN	SRV

;; ANSWER SECTION:
test.nodes.lightning.directory.	59 IN	SRV	10 10 9735 <1>
ln1qfkxfad87fxx7lcwr4hvsalj8vhkwta539nuy4zlyf7hqcmrjh40xx5frs7.test.nodes.lightning.directory. <2>
test.nodes.lightning.directory.	59 IN	SRV	10 10 15735 ln1qtgsl3efj8verd4z27k44xu0a59kncvsarxatahm334exgnuvwhnz8dkhx8.test.nodes.lightning.directory.

 [...]

;; Query time: 89 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Thu Dec 31 16:41:07 PST 2020
----
<1> TCP port number where the LN node can be reached.
<2> Node public key (ID) encoded as a virtual domain name.
====

Hemos truncado la respuesta para ser breves y mostrar sólo dos de las respuestas devueltas. Las respuestas contienen un nombre de dominio "virtual" para un nodo de destino, luego a la izquierda tenemos el _puerto TCP_ donde se puede alcanzar este nodo. La primera respuesta utiliza el puerto TCP estándar para la Lightning Network: +9735+. La segunda respuesta utiliza un puerto personalizado, que está permitido por el protocolo.

A continuación, intentaremos obtener el otro dato que necesitamos para conectarnos a un nodo: su dirección IP. Sin embargo, antes de poder consultarla, primero _decodificaremos_ la codificación bech32 de la clave pública del nombre de dominio virtual:

----
ln1qfkxfad87fxx7lcwr4hvsalj8vhkwta539nuy4zlyf7hqcmrjh40xx5frs7
----

Decodificando esta cadena bech32 obtenemos lo siguiente válido
+secp256k1+ clave pública:

----
026c64f5a7f24c6f7f0e1d6ec877f23b2f672fb48967c2545f227d70636395eaf3
----

Ahora que tenemos la clave pública en bruto, pediremos al servidor DNS que _resuelva_ el host virtual dado para poder obtener la información IP (registro +A+) del nodo, como se muestra en <<ex1102>>. 

++++
<div id="ex1102" data-type="example">
<h5>Obtaining the latest IP address for a node</h5>

<pre data-type="programlisting">$ dig ln1qfkxfad87fxx7lcwr4hvsalj8vhkwta539nuy4zlyf7hqcmrjh40xx5frs7.test.nodes.lightning.directory A

; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; ln1qfkxfad87fxx7lcwr4hvsalj8vhkwta539nuy4zlyf7hqcmrjh40xx5frs7.test.nodes.lightning.directory A
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 41934
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;ln1qfkxfad87fxx7lcwr4hvsalj8vhkwta539nuy4zlyf7hqcmrjh40xx5frs7.test.nodes.lightning.directory. IN A

;; ANSWER SECTION:
ln1qfkxfad87fxx7lcwr4hvsalj8vhkwta539nuy4zlyf7hqcmrjh40xx5frs7.test.nodes.lightning.directory. 60 IN A <em>X.X.X.X</em> <a class="co" id="comarker1" href="#c01"><img src="callouts/1.png" alt="1"/></a>

;; Query time: 83 msec
;; SERVER: 2600:1700:6971:6dd0::1#53(2600:1700:6971:6dd0::1)
;; WHEN: Thu Dec 31 16:59:22 PST 2020
;; MSG SIZE  rcvd: 138</pre>

<dl class="calloutlist">
<dt><a class="co" id="c01" href="#comarker1"><img src="callouts/1.png" alt="1"/></a></dt>
<dd><p>The DNS server returns an IP address <code><em>X.X.X.X</em></code>. We’ve replaced it with X’s in the text here so as to avoid presenting a real IP address.</p></dd>
</dl></div>
++++

In the preceding command, we've queried the server so we can obtain an IPv4 (<code>A</code> record) address for our target node (replaced by ++__X.X.X.X__++ in the preceding example). Now that we have the raw public key, IP address, and TCP port, we can connect to the node transport protocol at:

----
026c64f5a7f24c6f7f0e1d6ec877f23b2f672fb48967c2545f227d70636395eaf3@X.X.X.X:9735
----

Querying the current DNS +A+ record for a given node can also be used to look up the _latest_ set of addresses. Such queries can be used to more quickly sync the latest addressing information for a node, compared to waiting for address updates on the gossip network (see <<node_announcement>>).

En este punto de nuestro viaje, nuestro nuevo nodo Lightning ha encontrado su primer par y ha establecido su primera conexión. Ahora podemos empezar la segunda fase de la creación de nuevos pares: la sincronización y validación del gráfico del canal.

En primer lugar, vamos a explorar más de las complejidades de BOLT # 10 sí mismo para echar un vistazo más profundo en cómo las cosas funcionan bajo el capó.

==== Opciones de consulta SRV.

El estándar https://github.com/lightningnetwork/lightning-rfc/blob/master/10-dns-bootstrap.md[BOLT #10] es altamente extensible debido a su uso de subdominios anidados como capa de comunicación para opciones de consulta adicionales. El protocolo bootstrapping permite a los clientes especificar aún más el _tipo_ de nodos que intentan consultar frente a la recepción por defecto de un subconjunto aleatorio de nodos en las respuestas de consulta.

El esquema de subdominio de la opción de consulta utiliza una serie de pares clave-valor en los que la propia clave es una _sola letra_ y el conjunto de texto restante es el propio valor. En la versión actual del documento normativo https://github.com/lightningnetwork/lightning-rfc/blob/master/10-dns-bootstrap.md[BOLT #10] existen los siguientes tipos de consulta:

+r+:: El byte _realm_ que se utiliza para determinar para qué cadena o reino deben devolverse las consultas. Tal como está, el único valor para esta clave es +0+ que denota "Bitcoin".

+a+:: Permite a los clientes filtrar los nodos devueltos en función de los _tipos_ de direcciones que anuncian. Como ejemplo, esto se puede utilizar para obtener sólo los nodos que anuncian una dirección IPv6 válida. El valor que sigue a este tipo se basa en un campo de bits que _incide_ en el conjunto de _tipos de dirección_ especificados que se definen en https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md[BOLT #7]. El valor por defecto de este campo es +6+, que representa tanto a IPv4 como a IPv6 (los bits 1 y 2 están activados).

+l+:: Una clave pública de nodo válida serializada en formato comprimido. Esto permite a un cliente consultar un nodo específico en lugar de recibir un conjunto de nodos aleatorios.

+n+:: El número de registros a devolver. El valor por defecto de este campo es +25+.

Un ejemplo de consulta con opciones de consulta adicionales se parece a lo siguiente:

----
r0.a2.n10.nodes.lightning.directory
----

Si desglosamos la consulta por pares clave-valor, obtendremos los siguientes datos:

+r0+:: La consulta se dirige al reino de Bitcoin
+a2+:: La consulta sólo quiere que se devuelvan las direcciones IPv4
+n10+:: La consulta solicita

Pruebe usted mismo algunas combinaciones de los distintos indicadores utilizando la herramienta de línea de comandos +dig+ DNS:

----
dig @8.8.8.8 r0.a6.nodes.lightning.directory SRV
----
 

=== El gráfico del canal.

Ahora que nuestro nuevo nodo es capaz de utilizar el protocolo de arranque DNS para conectarse a su primer par, puede empezar a sincronizar el gráfico del canal. Sin embargo, antes de sincronizar el gráfico del canal, necesitaremos aprender exactamente _qué_ queremos decir con el gráfico del canal. En esta sección exploraremos la _estructura_ precisa del grafo del canal y examinaremos los aspectos únicos del grafo del canal comparado con la típica estructura de datos "grafo" abstracta que es bien conocida/usada en el campo de la ciencia de la computación.

==== Un grafo dirigido.

Un _grafo_ en informática es una estructura de datos especial compuesta por vértices (típicamente denominados nodos) y aristas (también conocidas como enlaces). Dos nodos pueden estar conectados por una o más aristas. El gráfico de canales también es _dirigido_, ya que un pago puede fluir en cualquier dirección por una arista determinada (un canal). Un ejemplo de un _grafo dirigido_ se muestra en <<directed_graph>>.

[[directed_graph]]
.A directed graph 
image::images/mtln_1102.png["A directed graph"]

En el contexto de la Lightning Network, nuestros vértices son los propios nodos Lightning, y nuestras aristas son los canales de pago que conectan estos nodos. Como lo que nos interesa es _encaminar los pagos_, en nuestro modelo un nodo sin aristas (sin canales de pago) no se considera parte del gráfico, ya que no es útil.

Dado que los canales en sí mismos son UTXOs (direcciones multisig financiadas 2 de 2), podemos ver el gráfico de canales como un subconjunto especial del conjunto de UTXOs de Bitcoin, sobre el que podemos añadir alguna información adicional (los nodos, etc.) para llegar a la estructura superpuesta final, que es el gráfico de canales. Este anclaje de los componentes fundamentales del grafo del canal en la blockchain base de Bitcoin significa que es imposible _falsificar_ un grafo del canal válido, lo que tiene propiedades útiles cuando se trata de prevenir el spam, como veremos más adelante.

=== Mensajes de gossip protocol.

La información del gráfico del canal se propaga a través de la red P2P Lightning como tres mensajes, que se describen en https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md[BOLT #7]:

+node_announcement+:: El vértice de nuestro gráfico que comunica la clave pública de un nodo, así como la forma de llegar al nodo a través de Internet y algunos metadatos adicionales que describen el conjunto de _características_ que soporta el nodo.

+anuncio_de_canal+:: Una prueba anclada en blockchain de la existencia de un canal entre dos nodos individuales. Cualquier tercero puede verificar esta prueba para asegurarse de que se está anunciando un canal _real_. Al igual que el +node_announcement+, este mensaje también contiene información que describe las _capacidades_ del canal, lo cual es útil cuando se intenta enrutar un pago.

+actualización_del_canal+:: Un _par_ de estructuras que describe el conjunto de políticas de enrutamiento para un canal determinado. Los mensajes +channel_update+ vienen en un _par_ porque un canal es un borde dirigido, por lo que cada lado del canal puede especificar su propia política de enrutamiento personalizada.

Es importante señalar que cada componente del grafo del canal está _autenticado_, lo que permite a un tercero asegurarse de que el propietario de un canal/actualización/nodo es realmente el que envía una actualización. Esto hace que el grafo del canal sea un tipo único de _estructura de datos autentificada_ que no puede ser falsificada. Para la autenticación, utilizamos una firma digital +secp256k1+ ECDSA (o una serie de ellas) sobre el compendio serializado del propio mensaje. En este capítulo no entraremos en la estructura/serialización específica de la mensajería utilizada en la Lightning Network, ya que cubriremos esa información en <<wire_protocol>>.

Una vez expuesta la estructura de alto nivel del gráfico del canal, nos sumergiremos ahora en la estructura precisa de cada uno de los tres mensajes utilizados para cotillear el gráfico del canal. También explicaremos cómo se puede verificar cada mensaje y componente del grafo del canal.

[[node_announcement]]
==== El mensaje node_announcement.

Primero, tenemos el mensaje +node_announcement+, que sirve para dos propósitos principales:

 1. Anunciar la información de conexión para que otros nodos puedan conectarse a un nodo, ya sea para arrancar en la red o para intentar establecer un nuevo payment channel con ese nodo.

 2. 2. Comunicar el conjunto de características a nivel de protocolo (capacidades) que un nodo entiende/soporta. La negociación de características entre nodos permite a los desarrolladores añadir nuevas características de forma independiente y soportarlas con cualquier otro nodo sobre la base de un opt-in.

A diferencia de los anuncios de canales, los anuncios de nodos no están anclados en la blockchain base. Por lo tanto, los anuncios de nodos sólo se consideran válidos si se han propagado con un anuncio de canal correspondiente. En otras palabras, siempre rechazamos los nodos sin canales de pago para garantizar que un compañero malicioso no pueda inundar la red con nodos falsos que no forman parte del gráfico de canales. 

===== La estructura del mensaje node_announcement.

El +node_announcement+ se compone de los siguientes campos:

 +firma+:: Una firma ECDSA válida que cubre el compendio serializado de todos los campos enumerados a continuación. Esta firma debe corresponder a la clave pública del nodo anunciado.

 +características+:: Un vector de bits que describe el conjunto de características del protocolo que este nodo entiende. Cubriremos este campo con más detalle en <<feature_bits>> sobre la extensibilidad del protocolo Lightning. En un nivel alto, este campo lleva un conjunto de bits que representan las características que un nodo entiende. Como ejemplo, un nodo puede señalar que entiende el último tipo de canal.

+timestamp+:: Un sello de tiempo codificado con la época de Unix. Esto permite a los clientes imponer un orden parcial sobre las actualizaciones del anuncio de un nodo.

+node_id+:: La clave pública +secp256k1+ a la que pertenece este anuncio de nodo. Sólo puede haber un único +anuncio_de_nodo+ para un nodo determinado en el gráfico del canal en un momento dado. Como resultado, un +anuncio de nodo+ puede sustituir a un +anuncio de nodo+ anterior para el mismo nodo si lleva una marca de tiempo más alta (posterior).

+rgb_color+:: Un campo que permite a un nodo especificar un color RGB para ser asociado con él, a menudo utilizado en visualizaciones de gráficos de canales y directorios de nodos.

+alias+:: Una cadena UTF-8 que sirve de apodo para un nodo determinado. Tenga en cuenta que no se requiere que estos alias sean globalmente únicos, ni se verifican de ninguna manera. Por lo tanto, no se debe confiar en ellos como una forma de identidad, ya que pueden ser fácilmente falsificados.

+direcciones+:: Conjunto de direcciones públicas accesibles en Internet que se asocian a un nodo determinado. En la versión actual del protocolo, se admiten cuatro tipos de direcciones: IPv4 (tipo: 1), IPv6 (tipo: 2), Tor v2 (tipo: 3), y Tor v3 (tipo: 4). En el mensaje +node_announcement+, cada uno de estos tipos de dirección se denota con un tipo entero que se incluye entre paréntesis después del tipo de dirección.

===== Validación de los anuncios de nodo.

La validación de un +node_announcement+ entrante es sencilla. Al examinar un anuncio de nodo se deben mantener las siguientes afirmaciones:

  * Si ya se conoce un +anuncio de nodo+ para ese nodo, entonces el campo +timestamp+ de un nuevo +anuncio de nodo+ entrante debe ser mayor que el anterior.

    * Con esta restricción, imponemos un nivel forzado de "frescura".

  * Si no existe un +anuncio de nodo+ para el nodo en cuestión, entonces debe existir un +anuncio de canal+ que haga referencia al nodo en cuestión (más adelante se hablará de ello) en el gráfico del canal local.

  * La +firma+ incluida debe ser una firma ECDSA válida verificada utilizando la clave pública del +id_nodo+ incluido y el resumen doble-SHA-256 de la codificación del mensaje en bruto (menos la firma y la cabecera de la trama) como mensaje.

  * Todas las +direcciones+ incluidas deben estar clasificadas en orden ascendente según su identificador de dirección.

  * Los bytes de +alias+ incluidos deben ser una cadena UTF-8 válida.

==== El mensaje channel_announcement.

A continuación, tenemos el mensaje +channel_announcement+, que se utiliza para _anunciar_ un nuevo canal _público_ a la red en general. Tenga en cuenta que el anuncio de un canal es _opcional_. Sólo es necesario anunciar un canal si se pretende utilizarlo para el enrutamiento por parte de la Lightning Network. Los nodos de enrutamiento activo pueden querer anunciar todos sus canales. Sin embargo, algunos nodos, como los nodos móviles, probablemente no tienen el tiempo de actividad o el deseo de ser un nodo de enrutamiento activo. Como resultado, estos nodos móviles (que normalmente utilizan clientes ligeros para conectarse a la red Bitcoin P2P) pueden tener canales puramente _no anunciados_ (privados).

===== Canales no anunciados (privados).

Un canal no anunciado no forma parte del gráfico de canales públicos conocidos, pero puede ser utilizado para enviar/recibir pagos. Un lector astuto puede preguntarse ahora cómo un canal que no forma parte del gráfico de canales públicos puede recibir pagos. La solución a este problema es un conjunto de "ayudantes de búsqueda de rutas" que llamamos pistas de enrutamiento. Como veremos en <<invoices>>, las facturas creadas por nodos con canales no anunciados incluirán información para ayudar al remitente a dirigirse a ellos, suponiendo que el nodo tenga al menos un único canal con un nodo de enrutamiento público existente.

Debido a la existencia de canales no anunciados, el tamaño _verdadero_ del gráfico de canales (tanto los componentes públicos como los privados) es desconocido. 

===== Localización de un canal en la blockchain de bitcoin.

Como se mencionó anteriormente, el gráfico del canal está autenticado debido a su uso de criptografía de clave pública, así como el blockchain de Bitcoin como sistema de prevención de spam. Para que un nodo acepte un nuevo +anuncio de canal+, el anuncio debe _probar_ que el canal existe realmente en la blockchain de Bitcoin. Este sistema de prueba añade un coste inicial a la adición de una nueva entrada al gráfico del canal (las tasas en la cadena que uno debe pagar para crear el UTXO del canal). Como resultado, mitigamos el spam y nos aseguramos de que un nodo deshonesto de la red no pueda llenar la memoria de un nodo honesto sin coste alguno con canales falsos.

Dado que necesitamos construir una prueba de la existencia de un canal, una pregunta natural que surge es: ¿cómo "señalamos" o referenciamos un canal determinado para el verificador? Dado que un payment channel está anclado en una salida de transacción no gastada (véase <<utxo>>), una primera idea podría ser intentar anunciar primero el punto de salida completo (+txid:index+) del canal. Dado que el punto de salida es globalmente único y confirmado en la cadena, esto parece una buena idea; sin embargo, tiene un inconveniente: el verificador debe mantener una copia completa del conjunto UTXO para verificar los canales. Esto funciona bien para los nodos completos de Bitcoin, pero los clientes que dependen de la verificación ligera no suelen mantener un conjunto completo de UTXO. Como queremos asegurarnos de que podemos admitir nodos móviles en la Lightning Network, nos vemos obligados a encontrar otra solución.

¿Y si en lugar de referenciar un canal por su UTXO, lo referenciamos en función de su "ubicación" en la cadena? Para ello, necesitaremos un esquema que nos permita referenciar un bloque determinado, luego una transacción dentro de ese bloque y, por último, una salida específica creada por esa transacción. Un identificador de este tipo se describe en https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md[BOLT #7] y se denomina _identificador de canal corto_, o +scid+.
El +scid+ se utiliza en +channel_announcement+ (y +channel_update+) así como dentro del paquete de enrutamiento encriptado en cebolla incluido dentro de los HTLCs, como aprendimos en <<onion_routing>>.

[[short_channel_id]]
[[scid]]
===== El ID del canal corto.

Basándonos en la información anterior, tenemos tres piezas de información que necesitamos codificar para referenciar de forma única un canal determinado. Como queremos una representación compacta, intentaremos codificar la información en un _solo_ entero. Nuestro formato de entero elegido es un entero de 64 bits sin signo, compuesto por 8 bytes.

Primero, la altura del bloque. Utilizando 3 bytes (24 bits) podemos codificar 16.777.216 bloques. Eso nos deja 5 bytes para codificar el índice de transacción y el índice de salida, respectivamente. Utilizaremos los siguientes 3 bytes para codificar el índice de transacción _dentro_ de un bloque. Esto es más que suficiente dado que sólo es posible fijar decenas de miles de transacciones en un bloque con los tamaños de bloque actuales. Esto nos deja 2 bytes para codificar el índice de salida del canal dentro de la transacción.

Nuestro formato final de +scid+ se parece a:
----
block_height (3 bytes) || transaction_index (3 bytes) || output_index (2 bytes)
----

Usando técnicas de empaquetamiento de bits, primero codificamos los 3 bytes más significativos como la altura del bloque, los siguientes 3 bytes como el índice de la transacción, y los 2 bytes menos significativos como el índice de salida de que crea el UTXO del canal.

Un ID de canal corto puede representarse como un único entero
(+695313561322258433+) o como una cadena más amigable: +632384x1568x1+. Aquí vemos que el canal fue minado en el bloque +632384+, fue la ++1568++ª transacción en el bloque, con la salida del canal como la segunda (los UTXOs están indexados a cero) salida producida por la transacción.

Ahora que somos capaces de señalar sucintamente una salida de financiación de canal dada en la cadena, podemos examinar la estructura completa del mensaje +channel_announcement+, así como ver cómo verificar la prueba de existencia incluida en el mensaje.

===== La estructura del mensaje channel_announcement.

Un +channel_announcement+ comunica principalmente dos cosas:

 1. Una prueba de que existe un canal entre el nodo A y el nodo B con ambos nodos controlando las claves mulitsig en la salida de ese canal.

 2. El conjunto de capacidades del canal (qué tipos de HTLC puede enrutar, etc.).

Al describir la prueba, normalmente nos referiremos al nodo +1+ y al nodo +2+. De los dos nodos que conecta un canal, el "primer" nodo es el que tiene una codificación de clave pública "más baja" cuando comparamos la clave pública de los dos nodos en formato comprimido codificado en hexadecimal en orden lexicográfico. En consecuencia, además de una clave pública de nodo en la red, cada nodo debe controlar también una clave pública dentro del blockchain de Bitcoin.

Al igual que el mensaje +node_announcement+, todas las firmas incluidas del mensaje +channel_announcement+ deben ser firmadas/verificadas contra la codificación en bruto del mensaje (menos la cabecera) que sigue _después_ de la firma final (porque no es posible que una firma digital se firme a sí misma). 

Dicho esto, un mensaje +channel_announcement+ tiene los siguientes campos:

+firma_nodo_1+:: La firma del primer nodo sobre el compendio del mensaje.

+firma_nodo_2+:: La firma del segundo nodo sobre el compendio del mensaje.

+firma_bitcoin_1+:: La firma de la clave multisig (en la salida de fondos) del primer nodo sobre el compendio del mensaje.

+bitcoin_signature_2+::  La firma de la clave multisig (en la salida de financiación) del segundo nodo sobre el compendio del mensaje.

+características+:: Un vector de bits de características que describe el conjunto de características a nivel de protocolo soportadas por este canal.

+chain_hash+:: Un hash de 32 bytes que suele ser el hash del bloque génesis de la blockchain (por ejemplo, la red principal de Bitcoin) en la que se abrió el canal.

+short_channel_id+:: El +scid+ que localiza de forma única la salida de fondos del canal dado dentro de la blockchain.

+node_id_1+:: La clave pública del primer nodo de la red.

+node_id_2+:: La clave pública del segundo nodo de la red.

+clave_bitcoin_1+:: La clave multisig de la salida de financiación del canal para el primer nodo de la red.

+bitcoin_key_2+:: La clave multisig para la salida de la financiación del canal para el segundo nodo de la red.

===== Validación del anuncio del canal.

Ahora que sabemos lo que contiene un +anuncio_de_canal+, podemos ver cómo verificar la existencia del canal en la cadena.

Armado con la información del +anuncio_de_canal+, cualquier nodo Lightning (incluso uno sin una copia completa de la blockchain de Bitcoin) puede verificar la existencia y autenticidad del payment channel.

En primer lugar, el verificador utilizará el ID corto del canal para encontrar qué bloque de Bitcoin contiene la salida de financiación del canal. Con la información de la altura del bloque, el verificador puede solicitar sólo ese bloque específico a un nodo Bitcoin. El bloque puede entonces ser vinculado de nuevo al bloque génesis siguiendo la cadena de la cabecera del bloque hacia atrás (verificando la prueba de trabajo), confirmando que este es de hecho un bloque que pertenece a la blockchain de Bitcoin.

A continuación, el verificador utiliza el número de índice de la transacción para identificar el ID de la transacción que contiene el payment channel. La mayoría de las bibliotecas modernas de Bitcoin permitirán indexar la transacción de un bloque basándose en el índice de la transacción dentro del bloque mayor.

A continuación, el verificador utiliza una biblioteca de Bitcoin (en el lenguaje del verificador) para extraer la transacción relevante según su índice dentro del bloque. El verificador validará la transacción (comprobando que está correctamente firmada y que produce el mismo ID de transacción cuando se hace el hash).

A continuación, el verificador extraerá la salida Pay-to-Witness-Script-Hash (P2WSH) referenciada por el número de índice de salida del ID de canal corto. Esta es la dirección de la salida de financiación del canal. Además, el verificador se asegurará de que el tamaño del supuesto canal coincide con el valor de la salida producida en el índice de salida especificado.

Por último, el verificador reconstruirá la secuencia de comandos multisig de +bitcoin_key_1+ y +bitcoin_key_2+ y confirmará que produce la misma dirección que en la salida.

El verificador ha verificado de forma independiente que el payment channel en el anuncio está financiado y confirmado en el blockchain de Bitcoin.

==== El mensaje channel_update.

El tercer y último mensaje utilizado en el gossip protocol es el mensaje +channel_update+. Se generan dos de ellos para cada payment channel (uno por cada socio del canal) anunciando sus fees de enrutamiento, expectativas de bloqueo de tiempo y capacidades.

El mensaje +channel_update+ también contiene una marca de tiempo, lo que permite a un nodo actualizar sus fees de enrutamiento y otras expectativas y capacidades mediante el envío de un nuevo mensaje +channel_update+ con una marca de tiempo más alta (posterior) que reemplaza cualquier actualización anterior.

El mensaje +channel_update+ contiene los siguientes campos:


+firma+:: Una firma digital que coincide con la clave pública del nodo, para autenticar la fuente y la integridad de la actualización del canal

+chain_hash+:: El hash del bloque génesis de la cadena que contiene el canal

+id_canal_corto+:: El ID corto del canal para identificar el canal

+timestamp+:: La marca de tiempo de esta actualización, para permitir a los receptores secuenciar las actualizaciones y reemplazar las más antiguas

+message_flags+:: Un campo de bits que indica la presencia de campos adicionales en el mensaje +channel_update

+bandas_de_canal+:: Un campo de bits que indica la dirección del canal y otras opciones del mismo

+cltv_expiry_delta+:: Las expectativas de delta de bloqueo de tiempo de este nodo para el enrutamiento (ver <<onion_routing>>)

+htlc_minimum_msat+:: La cantidad mínima de HTLC que se enrutará

+fee_base_msat+:: La tarifa base que se cobrará por el enrutamiento

+fee_proportional_millionths+:: La tasa proporcional que se cobrará por el enrutamiento

+htlc_maximum_msat+ (+option_channel_htlc_max+):: La cantidad máxima que se enrutará

Un nodo que reciba el mensaje +channel_update+ puede adjuntar estos metadatos a la arista del gráfico del canal para habilitar el pathfinding, como veremos en <<path_finding>>. 

=== Mantenimiento continuo del gráfico de canales.

La construcción de un gráfico de canales no es un evento único, sino una actividad continua. Cuando un nodo se incorpora a la red, empieza a recibir "chismes" en forma de tres mensajes de actualización. Utilizará estos mensajes para empezar a construir inmediatamente un gráfico de canal validado.

Cuanta más información reciba un nodo, mejor será su "mapa" de la Lightning Network y más eficaz será en la búsqueda de rutas y la entrega de pagos.

Un nodo no sólo añadirá información al gráfico de canales. También llevará la cuenta de la última vez que se actualizó un canal y borrará los canales "obsoletos" que no se hayan actualizado en más de dos semanas. Por último, si ve que algún nodo ya no tiene ningún canal, también lo eliminará.

La información recogida por el gossip protocol no es la única que puede almacenarse en el gráfico de canales. Las diferentes implementaciones de los nodos Rayo pueden adjuntar otros metadatos a los nodos y canales. Por ejemplo, algunas implementaciones de nodos calculan una "puntuación" que evalúa la "calidad" de un nodo como par de enrutamiento. Esta puntuación se utiliza como parte de la búsqueda de rutas para priorizar o despriorizar las rutas.

=== Conclusión.
En este capítulo, hemos aprendido cómo los nodos Rayo se descubren entre sí, descubren y actualizan su estado de nodo, y se comunican entre sí. Hemos aprendido cómo se crean y mantienen los gráficos de los canales, y hemos explorado algunas formas en las que la Lightning Network disuade a los malos actores o a los nodos deshonestos de hacer spam en la red.

[[path_finding]]
== Búsqueda de rutas y entrega de pagos.

La entrega de pagos en la Lightning Network depende de la búsqueda de una ruta desde el remitente hasta el destinatario, un proceso llamado _pathfinding_. Dado que el enrutamiento lo realiza el remitente, éste debe encontrar una ruta adecuada para llegar al destino. Este camino se codifica en una cebolla, como vimos en <<onion_routing>>.

En este capítulo examinaremos el problema de la búsqueda de rutas, entenderemos cómo la incertidumbre sobre los balances de los canales complica este problema, y veremos cómo una implementación típica de búsqueda de rutas intenta resolverlo.

=== Pathfinding en el Lightning Protocol Suite.

La búsqueda de rutas, la selección de rutas, los pagos multiparte (MPP) y el bucle de prueba y error del intento de pago ocupan la mayor parte de la capa de pago en la parte superior del conjunto de protocolos.

Estos componentes están resaltados por un contorno en el conjunto de protocolos, que se muestra en <<LN_protocol_pathfinding_highlight>>.

[[LN_protocol_pathfinding_highlight]]
.Payment delivery in the Lightning protocol suite
image::images/mtln_1201.png["Payment delivery in the Lightning protocol suite"]

==== ¿Dónde está el BOLT?

Hasta ahora hemos visto varias tecnologías que forman parte de la Lightning Network y hemos visto su especificación exacta como parte de un estándar BOLT. Quizá te sorprenda ver que la búsqueda de rutas no forma parte de los BOLT.

Esto se debe a que la búsqueda de rutas no es una actividad que requiera ningún tipo de coordinación o interoperabilidad entre diferentes implementaciones. Como hemos visto, la ruta es seleccionada por el emisor. Aunque los detalles del enrutamiento se especifican en detalle en los BOLTs, el descubrimiento y la selección de la ruta se dejan totalmente en manos del emisor. Así que cada implementación de nodo puede elegir una estrategia/algoritmo diferente para encontrar caminos. De hecho, las diferentes implementaciones de nodos/clientes y billeteras pueden incluso competir y utilizar su algoritmo de búsqueda de rutas como punto de diferenciación.

=== Pathfinding: ¿Qué problema estamos resolviendo?

El término pathfinding puede ser algo engañoso porque implica una búsqueda de _un único camino_ que conecte dos nodos. Al principio, cuando la Lightning Network era pequeña y no estaba bien interconectada, el problema consistía, efectivamente, en encontrar un camino que uniera los canales de pago para llegar al destinatario.

Pero, a medida que la Red Relámpago ha crecido de forma explosiva, la naturaleza del problema de búsqueda de caminos ha cambiado. A mediados de 2021, cuando terminamos este libro, la Lightning Network consta de 20.000 nodos conectados por al menos 55.000 canales públicos con una capacidad agregada de casi 2.000 BTC. Un nodo tiene una media de 8,8 canales, mientras que los 10 nodos más conectados tienen entre 400 y 2.000 canales _cada uno_. Una visualización de sólo un pequeño subconjunto del gráfico de canales de LN se muestra en <<lngraph>>.

[[lngraph]]
.A visualization of part of the Lightning Network as of July 2021
image::images/mtln_1202.png[]

[NOTE]
====
La visualización de la red en <<lngraph>> fue producida con un sencillo script de Python que puedes encontrar en code/lngraph en el repositorio del libro.
====

Si el emisor y el receptor están conectados a otros nodos bien conectados y tienen al menos un canal con la capacidad adecuada, habrá miles de caminos. El problema se convierte en seleccionar el _mejor_ camino que tendrá éxito en la entrega del pago, de entre una lista de miles de caminos posibles.
 

==== Seleccionar el mejor camino.

Para seleccionar el mejor camino, primero tenemos que definir qué entendemos por "mejor". Puede haber muchos criterios diferentes, como por ejemplo

* Trayectos con suficiente liquidez. Obviamente, si un camino no tiene suficiente liquidez para encaminar nuestro pago, entonces no es un camino adecuado.

* Trayectos con fees bajas. Si tenemos varios candidatos, es posible que queramos seleccionar los que tienen tasas más bajas.

* Vías con plazos cortos. Es posible que queramos evitar bloquear nuestros fondos durante demasiado tiempo y, por lo tanto, seleccionar trayectorias con plazos más cortos.

Todos estos criterios pueden ser deseables en cierta medida, y seleccionar trayectorias que sean favorables en muchas dimensiones no es una tarea fácil. Los problemas de optimización de este tipo pueden ser demasiado complejos para resolver la "mejor" solución, pero a menudo pueden resolverse con alguna aproximación al óptimo, lo cual es una buena noticia porque, de lo contrario, la búsqueda de caminos sería un problema intratable.


==== Pathfinding en matemáticas e informática.

La búsqueda de trayectorias en la Red Relámpago entra en la categoría general de la _teoría de los gráficos_ en matemáticas y en la categoría más específica de la _travesía de los gráficos_ en informática.

Una red como la Red Relámpago puede representarse como una construcción matemática llamada _grafo_, en la que los _nodos_ están conectados entre sí por _cuerdas_ (equivalentes a los canales de pago). Un gráfico dirigido con restricciones de capacidad numérica en sus aristas se denomina _red de flujo_, una construcción matemática utilizada para optimizar el transporte y otras redes similares. Los grafos de flujo pueden utilizarse como marco de trabajo cuando las soluciones deben lograr un flujo específico minimizando el coste, lo que se conoce como el problema de flujo de coste mínimo (MCFP).

==== Capacidad, equilibrio y liquidez.

Para entender mejor el problema del transporte de satoshis del punto A al punto B, necesitamos definir mejor tres términos importantes: capacidad, equilibrio y liquidez. Utilizamos estos términos para describir la capacidad de un payment channel para dirigir un pago.

In a payment channel connecting A<-->B:

Capacity:: This is the aggregate amount of satoshis that were funded into the 2-of-2 multisig with the funding transaction. It represents the maximum amount of value held in the channel. The channel capacity is announced by the gossip protocol and is known to nodes.

Balance:: This is the amount of satoshis held by each channel partner that can be sent to the other channel partner. A subset of the balance of A can be sent in the direction (A->B) toward node B. A subset of the balance of B can be sent in the opposite direction (A<-B).

Liquidity:: The available (subset) balance that can actually be sent across the channel in one direction. Liquidity of A is equal to the balance of A minus the channel reserve and any pending HTLCs committed by A.

The only value known to the network (via gossip announcements) is the aggregate capacity of the channel. Some unknown portion of that capacity is distributed as each partner's balance. Some subset of that balance is available to send across the channel in one direction:

++++
<ul class="simplelist">
<li>capacity = balance(A) + balance(B)</li>
<li>liquidity(A) = balance(A) – channel_reserve(A) – pending_HTLCs(A)</li>
</ul>
++++

==== Uncertainty of Balances.

If we knew the exact channel balances of every channel, we could compute one or more payment paths using any of the standard pathfinding algorithms taught in good computer science programs. Pero no conocemos los balances de los canales; sólo conocemos la capacidad agregada del canal, que es anunciada por los nodos en los anuncios de los canales. Para que un pago tenga éxito, debe haber un equilibrio adecuado en el lado emisor del canal. Si no sabemos cómo se distribuye la capacidad entre los socios del canal, no sabemos si hay suficiente equilibrio en la dirección a la que intentamos enviar el pago.

Los saldos no se anuncian en las actualizaciones del canal por dos razones: privacidad y escalabilidad. En primer lugar, anunciar los saldos reduciría la privacidad de la Lightning Network porque permitiría vigilar el pago mediante el análisis estadístico de los cambios en los saldos. En segundo lugar, si los nodos anunciaran los saldos (globalmente) con cada pago, la escalabilidad de la Lightning Network sería tan mala como la de las transacciones de Bitcoin en la cadena, que se transmiten a todos los participantes. Por lo tanto, los saldos no se anuncian. Para resolver el problema de la búsqueda de rutas ante la incertidumbre de los saldos, necesitamos estrategias innovadoras de búsqueda de rutas. Estas estrategias deben estar estrechamente relacionadas con el algoritmo de enrutamiento que se utiliza, que es el enrutamiento de cebolla basado en la fuente, donde es la responsabilidad del remitente encontrar un camino a través de la red.

El problema de la incertidumbre puede describirse matemáticamente como un _rango de liquidez_, que indica los límites inferior y superior de la liquidez en función de la información que se conoce. Dado que conocemos la capacidad del canal y conocemos el balance de reserva del canal (el balance mínimo permitido en cada extremo), la liquidez puede definirse como: 

++++
<ul class="simplelist">
<li>min(liquidity) = channel_reserve</li>
<li>max(liquidity) = capacity – channel_reserve</li>
</ul>
++++

[role="pagebreak-before"]
or as a range:

++++
<ul class="simplelist">
<li>channel_reserve &lt;= liquidity &lt;= (capacity – channel_reserve)</li>
</ul>
++++

Our channel liquidity uncertainty range is the range between the minimum and maximum possible liquidity. This is unknown to the network, except the two channel partners. However, as we will see, we can use failed HTLCs returned from our payment attempts to update our liquidity estimate and reduce uncertainty. If, for example, we get an HTLC failure code that tells us that a channel cannot fulfill an HTLC that is smaller than our estimate for maximum liquidity, that means the maximum liquidity can be updated to the amount of the failed HTLC. In simpler terms, if we think the liquidity can handle an HTLC of _N_ satoshis and we find out it fails to deliver _M_ satoshis (where _M_ is smaller), then we can update our estimate to __M__–1 as the upper bound. We tried to find the ceiling and bumped against it, so it's lower than we thought!

==== Pathfinding Complexity.

Encontrar un camino a través de un gráfico es un problema que los ordenadores modernos pueden resolver con bastante eficacia.
Developers mainly choose breadth-first search if the edges are all of equal weight.
In cases where the edges are not of equal weight, an algorithm based on Dijkstra's algorithm is used, such as https://en.wikipedia.org/wiki/A*_search_algorithm[A* (pronounced "A-star")].
En nuestro caso, los pesos de las aristas pueden representar las tasas de enrutamiento.
Sólo se incluirán en la búsqueda las aristas con una capacidad mayor que la cantidad a enviar.
En esta forma básica, la búsqueda de rutas en la Lightning Network es muy sencilla y directa.

Sin embargo, la liquidez del canal es desconocida para el emisor. Esto convierte nuestro sencillo problema informático teórico en un problema bastante complejo del mundo real.
Ahora tenemos que resolver un problema de búsqueda de rutas con un conocimiento parcial.
Por ejemplo, sospechamos qué aristas podrían reenviar un pago porque su capacidad parece lo suficientemente grande.
Pero no podemos estar seguros a menos que lo probemos o preguntemos directamente a los propietarios de los canales.
Incluso si pudiéramos preguntar directamente a los propietarios de los canales, su balance podría cambiar para cuando hayamos preguntado a otros, calculado una ruta, construido una cebolla y enviado la misma.
No sólo tenemos información limitada, sino que la información que tenemos es muy dinámica y puede cambiar en cualquier momento sin que lo sepamos.

==== Mantener la sencillez.

El mecanismo de búsqueda de rutas implementado en los nodos Lightning consiste en crear primero una lista de rutas candidatas, filtradas y ordenadas por alguna función. A continuación, el nodo o el monedero sondearán las rutas (intentando entregar un pago) en un bucle de prueba y error hasta que se encuentre una ruta que entregue el pago con éxito.

[NOTE]
====
Este sondeo lo realiza el nodo o monedero Lightning y no es observado directamente por el usuario del software.
Sin embargo, el usuario puede sospechar que se está produciendo un sondeo si el pago no se completa instantáneamente.
====

Aunque el sondeo a ciegas no es óptimo y deja un amplio margen de mejora, cabe señalar que incluso esta estrategia simplista funciona sorprendentemente bien para pagos pequeños y nodos bien conectados.

La mayoría de las implementaciones de nodos y billeteras Lightning mejoran este enfoque ordenando/ponderando la lista de rutas candidatas. Algunas implementaciones ordenan las rutas candidatas por el coste (tasas) o alguna combinación de coste y capacidad.

=== Proceso de búsqueda de rutas y entrega de pagos.

La búsqueda de rutas y la entrega de pagos implican varios pasos, que enumeramos aquí. Diferentes implementaciones pueden utilizar diferentes algoritmos y estrategias, pero los pasos básicos son probablemente muy similares:

. Crear un _grafo de canales_ a partir de los anuncios y actualizaciones que contengan la capacidad de cada canal, y filtrar el gráfico, ignorando cualquier canal con capacidad insuficiente para la cantidad que queremos enviar.

. Encontrar rutas que conecten el remitente con el destinatario.

. Ordenar los caminos por algún peso (esto puede ser parte del algoritmo del paso anterior).

. Probar cada camino en orden hasta que el pago tenga éxito (el bucle de prueba y error).

. Opcionalmente, utilizar los retornos de los fallos de HTLC para actualizar nuestro gráfico, reduciendo la incertidumbre.

Podemos agrupar estos pasos en tres actividades principales:

* Construcción del gráfico del canal
* Búsqueda de rutas (filtradas y ordenadas por alguna heurística)
* Intento(s) de pago

Estas tres actividades pueden repetirse en una _ronda de pago_ si utilizamos las devoluciones de fallos para actualizar el gráfico, o si estamos haciendo pagos multiparte (ver <<mpp>>).

En las próximas secciones veremos cada uno de estos pasos con más detalle, así como estrategias de pago más avanzadas. 

=== Construcción del gráfico del canal.

En <<gossip>> cubrimos los tres mensajes principales que los nodos utilizan en sus chismes: +node_announcement+, +channel_announcement+, y +channel_update+. Estos tres mensajes permiten a cualquier nodo construir gradualmente un "mapa" de la Red Relámpago en forma de _grafo de canales_. Cada uno de estos mensajes proporciona una información fundamental para el gráfico de canales:

+node_announcement+:: Contiene información sobre un nodo de la Lightning Network, como su ID de nodo (clave pública), dirección de red (por ejemplo, IPv4/6 o Tor), capacidades/características, etc.

+anuncio_de_canal+:: Contiene la capacidad y el ID de canal de un canal público (anunciado) entre dos nodos y la prueba de la existencia y propiedad del canal.

+actualización_del_canal+:: Contiene las expectativas de tarifa y tiempo de espera (CLTV) de un nodo para enrutar un pago saliente (desde la perspectiva de ese nodo) a través de un canal especificado.

En términos de un gráfico matemático, el +anuncio_de_nodos+ es la información necesaria para crear los nodos o _vértices_ del gráfico. El +anuncio_de_canal+ nos permite crear las _cuerdas_ del gráfico que representan los canales de pago. Como cada dirección del payment channel tiene su propio balance, creamos un grafo dirigido. El +canal_actualización+ nos permite incorporar tasas y plazos para establecer el _coste_ o el _peso_ de las aristas del grafo.

Dependiendo del algoritmo que vayamos a utilizar para el pathfinding, podemos establecer varias funciones de coste diferentes para las aristas del grafo.

Por ahora, ignoremos la función de coste y establezcamos simplemente un gráfico de canales que muestre los nodos y los canales, utilizando los mensajes +node_announcement+ y +channel_announcement+.

En este capítulo veremos cómo Selena intenta encontrar un camino para pagar a Rashid un millón de satoshis. Para empezar, Selena construye un grafo de canales utilizando la información de los cotilleos de la Lightning Network para descubrir nodos y canales. A continuación, Selena explorará su grafo de canales para encontrar una ruta para enviar un pago a Rashid.

Este es el gráfico de canales de Selena. No existe _el_ grafo de canales, sólo existe siempre _un grafo de canales_, y siempre es desde la perspectiva del nodo que lo ha construido (ver <<map_territory_relation>>).

[TIP]
====
Selena no construye un gráfico de canal sólo cuando envía un pago. Más bien, el nodo de Selena está construyendo y actualizando _continuamente_ un gráfico de canales. Desde el momento en que el nodo de Selena se inicia y se conecta a cualquier compañero de la red, participará en el cotilleo y utilizará cada mensaje para aprender lo máximo posible sobre la red.
====

[[map_territory_relation]]
.The Map-Territory Relation
****
((("channel graph","map–territory relation")))From Wikipedia's https://en.wikipedia.org/wiki/Map%E2%80%93territory_relation[page on the Map-Territory Relation], "The map-territory relation describes the relationship between an object and a representation of that object, as in the relation between a geographical territory and a map of it."

La relación mapa-territorio se ilustra mejor en "Sylvie y Bruno Concluidos", un cuento de Lewis Carroll que describe un mapa ficticio que es una escala 1:1 del territorio que cartografía, por lo que tiene una precisión perfecta pero resulta completamente inútil ya que cubriría todo el territorio si se desplegara.

¿Qué significa esto para la Red del Rayo? La Red del Rayo es el territorio, y un gráfico de canales es un mapa de ese territorio.

Aunque podríamos imaginar un gráfico de canales teórico (ideal platónico) que representara el mapa completo y actualizado de la Red Relámpago, dicho mapa es simplemente la propia Red Relámpago. Cada nodo tiene su propio gráfico de canales, que se construye a partir de anuncios y es necesariamente incompleto, incorrecto y desactualizado.

El mapa nunca puede describir completamente y con precisión el territorio.
****

Selena escucha los mensajes de +nodo_anuncio+ y descubre otros cuatro nodos (además de Rashid, el destinatario previsto). El gráfico resultante representa una red de seis nodos: Selena y Rashid son el emisor y el receptor, respectivamente; Alice, Bob, Xavier y Yan son nodos intermediarios. El grafo inicial de Selena es sólo una lista de nodos, que se muestra en <<channel_graph_nodes>>.

[[channel_graph_nodes]]
.Node announcements
image::images/mtln_1203.png[]

Selena también recibe siete mensajes +channel_announcement+ con las correspondientes capacidades de los canales, lo que le permite construir un "mapa" básico de la red, mostrado en <<channel_graph_1>>. (Los nombres de Alice, Bob, Selena, Xavier, Yan y Rashid se han sustituido por sus iniciales: A, B, S, X y R, respectivamente).

[[channel_graph_1]]
.The channel graph
image::images/mtln_1204.png[]

===== Incertidumbre en el gráfico del canal.

Como se puede ver en <<channel_graph_1>>, Selena no conoce ninguno de los equilibrios de los canales. Su gráfico de canales inicial contiene el mayor nivel de incertidumbre. 

Pero espera: ¡Selena sí conoce los saldos de los canales! Conoce los saldos de los canales que su propio nodo ha conectado con otros nodos. Aunque esto no parece gran cosa, en realidad es una información muy importante para construir una ruta: Selena conoce la liquidez real de sus propios canales. Actualicemos el gráfico de canales para mostrar esta información. Utilizaremos un símbolo "?" para representar los saldos desconocidos, como se muestra en <<channel_graph_2>>.

[[channel_graph_2]]
.Channel graph with known and unknown balances
image::images/mtln_1205.png[]

Aunque el símbolo "?" parece ominoso, la falta de certeza no es lo mismo que la ignorancia total. Podemos _cuantificar_ la incertidumbre y _reducirla_ actualizando el gráfico con los HTLCs exitosos/fracasados que intentamos.

La incertidumbre se puede cuantificar, porque conocemos la liquidez máxima y mínima posible y podemos calcular las probabilidades para rangos más pequeños (más precisos).

Una vez que intentamos enviar un HTLC, podemos saber más sobre los saldos del canal: si tenemos éxito, entonces el balance era _al menos_ suficiente para transportar la cantidad específica. Mientras tanto, si obtenemos un error de "fallo temporal del canal", la razón más probable es la falta de liquidez para la cantidad específica.

[TIP]
====
Tal vez piense: "¿Qué sentido tiene aprender de un HTLC exitoso?". Al fin y al cabo, si ha tenido éxito "ya hemos terminado". Pero considere que podemos estar enviando una parte de un pago de varias partes. También es posible que enviemos otros pagos de una sola parte dentro de poco tiempo. Todo lo que aprendamos sobre la liquidez es útil para el siguiente intento.
====

==== Incertidumbre y probabilidad de la liquidez.

Para cuantificar la incertidumbre de la liquidez de un canal, podemos aplicar la teoría de la probabilidad. Un modelo básico de la probabilidad de entrega del pago nos llevará a algunas conclusiones bastante obvias, pero importantes:

* Los pagos más pequeños tienen más posibilidades de ser entregados con éxito a través de un canal.

* Los canales de mayor capacidad nos darán una mayor probabilidad de entrega del pago para una cantidad específica.

* Cuantos más canales (saltos), menor es la probabilidad de éxito.

Aunque esto puede resultar obvio, tiene importantes implicaciones, especialmente para el uso de pagos multiparte (véase <<mpp>>). Las matemáticas no son difíciles de seguir.

Utilicemos la teoría de la probabilidad para ver cómo llegamos a estas conclusiones.

En primer lugar, planteemos que un canal con capacidad _c_ tiene liquidez en un lado con un valor desconocido en el rango de (0, _c_) o "rango entre 0 y _c_". Por ejemplo, si la capacidad es 5, entonces la liquidez estará en el rango (0, 5). Ahora bien, de esto se desprende que si queremos enviar 5 satoshis, nuestra probabilidad de éxito es sólo de 1 entre 6 (16,66%), porque sólo tendremos éxito si la liquidez es exactamente 5.

Más sencillamente, si los valores posibles de la liquidez son 0, 1, 2, 3, 4 y 5, sólo uno de esos seis valores posibles será suficiente para enviar nuestro pago. Siguiendo con el ejemplo, si el importe de nuestro pago fuera 3, tendríamos éxito si la liquidez fuera 3, 4 o 5. Por tanto, nuestras probabilidades de éxito son de 3 entre 6 (50%). Expresado en matemáticas, la función de probabilidad de éxito para un solo canal es

[latexmath]
++++
$P_c(a) = (c + 1 - a) / (c + 1)$
++++

donde _a_ es la cantidad y _c_ es la capacidad.

De la ecuación vemos que si la cantidad es cercana a 0, la probabilidad es cercana a 1, mientras que si la cantidad supera la capacidad, la probabilidad es cero.

En otras palabras: "Los pagos más pequeños tienen más posibilidades de ser entregados con éxito" o "Los canales de mayor capacidad nos dan más posibilidades de entrega para un importe concreto" y "No se puede enviar un pago por un canal con capacidad insuficiente".

Ahora pensemos en la probabilidad de éxito a través de un camino formado por varios canales. Supongamos que nuestro primer canal tiene una probabilidad de éxito del 50% (_P_ = 0,5). Entonces, si nuestro segundo canal tiene una probabilidad de éxito del 50% (_P_ = 0,5), es intuitivo que nuestra probabilidad global es del 25% (_P_ = 0,25).

Podemos expresar esto como una ecuación que calcula la probabilidad de éxito de un pago como el producto de las probabilidades de cada canal en la(s) ruta(s):

[latexmath]
++++
$P_{payment} = \prod_{i=1}^n P_i$
++++

Donde __P__~__i__~ es la probabilidad de éxito en un camino o canal, y __P__~__pago__~ es la probabilidad global de un pago exitoso en todos los caminos/canales.

De la ecuación se desprende que, dado que la probabilidad de éxito en un solo canal es siempre menor o igual a 1, la probabilidad en muchos canales disminuirá exponencialmente.

En otras palabras, "cuantos más canales (saltos) se utilicen, menor será la probabilidad de éxito".

[NOTE]
====
Hay mucha teoría matemática y modelización detrás de la incertidumbre de la liquidez en los canales. El trabajo fundamental sobre el modelado de los intervalos de incertidumbre de la liquidez de los canales se puede encontrar en el artículo https://arxiv.org/abs/2103.08576["Security and Privacy of Lightning Network Payments with Uncertain Channel Balances"] de (coautor de este libro) Pickhardt et al.
==== 

==== Tarifas y otras métricas del canal.

A continuación, nuestro emisor añadirá al gráfico información procedente de los mensajes +channel_update+ recibidos de los nodos intermediarios. Como recordatorio, el +channel_update+ contiene una gran cantidad de información sobre un canal y las expectativas de uno de los socios del canal.

En <<channel_graph_3>> vemos cómo Selena puede actualizar el gráfico del canal basándose en los mensajes +channel_update+ de A, B, X e Y. Obsérvese que el ID y la dirección del canal (incluidos en +channel_flags+) indican a Selena a qué canal y a qué dirección se refiere esta actualización. Cada socio del canal cotillea uno o más mensajes +channel_update+ para anunciar sus expectativas de fees y otra información sobre el canal. Por ejemplo, en la parte superior izquierda vemos el +channel_update+ enviado por Alice para el canal A--B y la dirección A-to-B. Con esta actualización, Alice le dice a la red cuánto cobrará en concepto de tasas por encaminar un HTLC a Bob por ese canal específico. Bob puede anunciar una actualización del canal (no se muestra en este diagrama) para la dirección opuesta con expectativas de fees completamente diferentes. Cualquier nodo puede enviar una nueva +actualización_del_canal+ para cambiar las fees o las expectativas de bloqueo de tiempo en cualquier momento.

[[channel_graph_3]]
.Channel graph fees and other channel metrics
image::images/mtln_1206.png[]

La información de tasas y timelock es muy importante, no sólo como métricas de selección de rutas. Como vimos en <<onion_routing>>, el emisor necesita sumar tasas y timelocks (+cltv_expiry_delta+) en cada salto para hacer la cebolla. El proceso de cálculo de las tasas ocurre desde el destinatario hasta el emisor _hacia atrás_ a lo largo del camino porque cada salto intermedio espera un HTLC entrante con una cantidad y un timelock de expiración mayores que el HTLC saliente que enviarán al siguiente salto. Así, por ejemplo, si Bob quiere 1.000 satoshis en tasas y 30 bloques de delta de timelock de expiración para enviar un pago a Rashid, entonces esa cantidad y delta de expiración deben añadirse al HTLC _desde Alice_.

También es importante tener en cuenta que un canal debe tener liquidez suficiente no sólo para el importe del pago sino también para las tasas acumuladas de todos los saltos posteriores. Aunque el canal de Selena a Xavier (S->X) tiene suficiente liquidez para un pago de 1M de satoshi, _no_ tiene suficiente liquidez una vez que consideramos las tasas. Necesitamos conocer las tasas porque sólo se considerarán las rutas que tengan suficiente liquidez para _tanto el pago como todas las tasas_.

=== Encontrar trayectorias candidatas.

Encontrar un camino adecuado a través de un grafo dirigido como éste es un problema informático muy estudiado (conocido ampliamente como el _problema del camino más corto_), que puede ser resuelto por una variedad de algoritmos dependiendo de la optimización deseada y de las restricciones de recursos.

El algoritmo más famoso para resolver este problema fue inventado por el matemático holandés E. W. Dijkstra en 1956, conocido simplemente como https://en.wikipedia.org/wiki/Dijkstra's_algorithm[_algoritmo de Dijkstram_]. Además del algoritmo original de Dijkstra, existen muchas variaciones y optimizaciones, como https://en.wikipedia.org/wiki/A*_search_algorithm[A* ("A-star")], que es un algoritmo basado en la heurística.

Como se ha mencionado anteriormente, la "búsqueda" debe aplicarse _hacia atrás_ para tener en cuenta las tasas que se acumulan del destinatario al emisor. Así, Dijkstra, A* o algún otro algoritmo buscaría una ruta desde el destinatario hasta el remitente, utilizando las tasas, la liquidez estimada y el delta de bloqueo temporal (o alguna combinación) como función de coste para cada salto.

Utilizando uno de estos algoritmos, Selena calcula varios caminos posibles hacia Rashid, ordenados por el camino más corto:

1. S->A->B->R

2. S->X->Y->R

3. S->X->B->R

4. S->A->B->X->Y->R


Pero, como vimos anteriormente, el canal S->X no tiene suficiente liquidez para un pago de 1M de satoshi una vez consideradas las comisiones. Así que los caminos 2 y 3 no son viables. Eso deja los caminos 1 y 4 como posibles caminos para el pago.

Con dos caminos posibles, ¡Selena está lista para intentar la entrega!

=== Entrega del pago (Bucle de prueba y error).

El nodo de Selena comienza el bucle de prueba y error construyendo los HTLC, construyendo la cebolla e intentando la entrega del pago. Para cada intento, hay tres resultados posibles:

[role="pagebreak-before"]
- Un resultado exitoso (+update_fulfill_htlc+)
- Un error (+update_fail_htlc+)
- Un pago "atascado" sin respuesta (ni éxito ni fracaso)

Si el pago falla, se puede volver a intentar por una vía diferente actualizando el gráfico (cambiando las métricas de un canal) y recalculando una vía alternativa.

Hemos visto lo que ocurre si el pago está "atascado" en <<stuck_payments>>. El detalle importante es que un pago atascado es el peor resultado porque no podemos reintentar con otro HTLC ya que ambos (el atascado y el reintentado) podrían pasar eventualmente y causar un doble pago. 

==== Primer intento (camino nº 1).

Selena intenta el primer camino (S->A->B->R). Construye la cebolla y la envía, pero recibe un código de fallo del nodo de Bob. Bob informa de un +fallo temporal del canal+ con una +actualización_del_canal+ identificando el canal B->R como el que no puede entregar. Este intento se muestra en <<path_1_fail>>.

[[path_1_fail]]
.Path #1 attempt fails
image::images/mtln_1207.png[]

===== Aprendiendo del fracaso.

De este código de fallo, Selena deducirá que Bob no tiene suficiente liquidez para entregar el pago a Rashid en ese canal. Es importante destacar que este fallo reduce la incertidumbre de la liquidez de ese canal. Anteriormente, el nodo de Selena suponía que la liquidez en el lado del canal de Bob estaba en algún lugar del rango (0, 4M). Ahora, puede suponer que la liquidez está en el rango (0, 999999). Del mismo modo, Selena puede suponer ahora que la liquidez de ese canal en el lado de Rashid está en el rango (1M, 4M), en lugar de (0, 4M). Selena ha aprendido mucho de este fracaso.

==== Segundo intento (Ruta #4).

Ahora Selena intenta el cuarto camino candidato (S->A->B->X->Y->R). Este es un camino más largo e incurrirá en más gastos, pero ahora es la mejor opción para la entrega del pago.

Afortunadamente, Selena recibe un mensaje +update_fulfill_htlc+ de Alice, indicando que el pago fue exitoso, como se muestra en <<path_4_success>>.

[[path_4_success]]
.Path #4 attempt succeeds
image::images/mtln_1208.png[]

===== Aprendiendo del éxito.

Selena también ha aprendido mucho de este pago exitoso. Ahora sabe que todos los canales de la ruta S->A->B->X->Y->R tenían suficiente liquidez para realizar el pago. Además, ahora sabe que cada uno de estos canales ha trasladado la cantidad de HTLC (1M y tasas) al otro extremo del canal. Esto permite a Selena recalcular el rango de liquidez en el lado receptor de todos los canales en esa ruta, sustituyendo la liquidez mínima por las tasas de 1M.

===== ¿Conocimiento antiguo?.

Selena tiene ahora un "mapa" mucho mejor de la Lightning Network (al menos en lo que respecta a estos siete canales). Este conocimiento será útil para cualquier pago posterior que Selena intente realizar.

Sin embargo, este conocimiento se convierte en algo "obsoleto" a medida que los otros nodos envían o enrutan los pagos. Selena nunca verá ninguno de estos pagos (a menos que sea la remitente). Incluso si participa en el enrutamiento de los pagos, el mecanismo de enrutamiento de la cebolla significa que sólo puede ver los cambios de un salto (sus propios canales).

Por lo tanto, el nodo de Selena debe considerar cuánto tiempo mantener este conocimiento antes de asumir que es obsoleto y ya no es útil.

[[mpp]]
=== Pagos multipartes .

Los pagos multiparte (MPP) son una característica que se introdujo en la Lightning Network en 2020 y que ya está muy extendida. Los pagos multiparte permiten dividir un pago en múltiples _partes_ que se envían como HTLCs a través de varias rutas diferentes al destinatario, preservando la _atomicidad_ del pago global. En este contexto, la atomicidad significa que, o bien todas las partes HTLC de un pago se cumplen finalmente, o bien todo el pago falla y todas las partes HTLC fallan. No existe la posibilidad de que el pago sea parcialmente exitoso.

Los pagos multiparte son una mejora significativa en la Lightning Network porque hacen posible enviar cantidades que no "caben" en ningún canal único, dividiéndolas en cantidades más pequeñas para las que hay suficiente liquidez. Además, se ha demostrado que los pagos multiparte aumentan la probabilidad de éxito de un pago, en comparación con un pago de una sola vía.

[TIP]
====
Ahora que el MPP está disponible, es mejor pensar en un pago de una sola vía como una subcategoría de un MPP. Esencialmente, un pago de una sola vía es sólo un multiparte de tamaño uno. Todos los pagos pueden considerarse como pagos multiparte a menos que el tamaño del pago y la liquidez disponible hagan posible la entrega con una sola parte.
====

==== Utilizar el MPP.

El MPP no es algo que el usuario seleccione, sino que es una estrategia de búsqueda de rutas de nodos y de entrega de pagos. Se implementan los mismos pasos básicos: crear un gráfico, seleccionar rutas y el bucle de prueba y error. La diferencia es que durante la selección de rutas también debemos considerar cómo dividir el pago para optimizar la entrega.

En nuestro ejemplo podemos ver algunas mejoras inmediatas en nuestro problema de búsqueda de caminos que son posibles con el MPP. En primer lugar, podemos utilizar el canal S->X que tiene una liquidez conocida como insuficiente para transportar 1M de satoshis más las tasas. Enviando una parte más pequeña por ese canal, podemos utilizar caminos que antes no estaban disponibles. En segundo lugar, tenemos la liquidez desconocida del canal B->R, que es insuficiente para transportar la cantidad de 1M, pero podría ser suficiente para transportar una cantidad menor. 

===== Dividir los pagos.

La cuestión fundamental es cómo dividir los pagos. Más concretamente, ¿cuál es el número óptimo de repartos y los importes óptimos para cada uno de ellos?

Se trata de un área de investigación en curso en la que están surgiendo nuevas estrategias. Los pagos multipartitos conducen a un enfoque algorítmico diferente al de los pagos de una sola ruta, aunque las soluciones de una sola ruta pueden surgir de una optimización multipartita (es decir, una sola ruta puede ser la solución óptima sugerida por un algoritmo de búsqueda de rutas multipartitas).

Si recuerdan, descubrimos que la incertidumbre de la liquidez/los saldos lleva a algunas conclusiones (algo obvias) que podemos aplicar en la búsqueda de rutas de MPP, a saber

* Los pagos más pequeños tienen más posibilidades de éxito.

* Cuantos más canales se utilicen, la probabilidad de éxito es (exponencialmente) menor.

A partir de la primera de estas ideas, podríamos concluir que dividir un pago grande (por ejemplo, 1 millón de satoshis) en pequeños pagos aumenta la probabilidad de que cada uno de esos pagos más pequeños tenga éxito. El número de caminos posibles con suficiente liquidez será mayor si enviamos cantidades más pequeñas.

Para llevar esta idea al extremo, ¿por qué no dividir el pago de 1M de satoshis en un millón de partes separadas de un satoshi? Bueno, la respuesta está en nuestra segunda idea: como estaríamos usando más canales/caminos para enviar nuestro millón de HTLCs de un satoshi, nuestra probabilidad de éxito caería exponencialmente.

Por si no es obvio, las dos ideas anteriores crean un "punto óptimo" en el que podemos maximizar nuestras posibilidades de éxito: ¡dividir en pagos más pequeños pero sin demasiadas divisiones!

Cuantificar este equilibrio óptimo de tamaño/número de divisiones para un gráfico de canal determinado está fuera del alcance de este libro, pero es un área de investigación activa. Algunas implementaciones actuales utilizan una estrategia muy simple de dividir el pago en dos mitades, cuatro cuartos, etc.

[NOTE]
====
Para leer más sobre el problema de optimización conocido como flujos de coste mínimo que se plantea al dividir los pagos en diferentes tamaños y asignarlos a las rutas, véase el artículo https://arxiv.org/abs/2107.05322["Optimally Reliable & Cheap Payment Flows on the Lightning Network"] de (coautores de este libro) René Pickhardt y Stefan Richter.
====

En nuestro ejemplo, el nodo de Selena intentará dividir el pago de 1M de satoshi en 2 partes con 600k y 400k satoshi, respectivamente, y enviarlas por 2 caminos diferentes. Esto se muestra en <<mpp_paths>>.

Debido a que el canal S->X ahora puede ser utilizado, y (por suerte para Selena), el canal B->R tiene suficiente liquidez para 600k satoshis, las 2 partes son exitosas a través de caminos que antes no eran posibles.

[[mpp_paths]]
.Sending two parts of a multipart payment
image::images/mtln_1209.png[]

==== Prueba y error en múltiples "rondas".

Los pagos multiparte conducen a un bucle de prueba y error algo modificado para la entrega del pago. Como estamos intentando múltiples caminos en cada intento, tenemos cuatro posibles resultados:

* Todas las partes tienen éxito, el pago es exitoso.
* Algunas partes tienen éxito, algunas fallan con errores devueltos
* Todas las partes fallan con errores devueltos
* Algunas partes están "atascadas", no se devuelven errores

En el segundo caso, en el que algunas partes fallan con errores devueltos y otras tienen éxito, ahora podemos _repetir_ el bucle de prueba y error, pero _sólo para la cantidad residual_.

Supongamos, por ejemplo, que Selena tuviera un gráfico de canal mucho más grande con cientos de caminos posibles para llegar a Rashid. Su algoritmo de búsqueda de caminos podría encontrar una división óptima del pago que consistiera en 26 partes de diferentes tamaños. Después de intentar enviar las 26 partes en la primera ronda, 3 de esas partes fallaron con errores.

Si esas 3 partes consistieran en, digamos, 155k satoshis, entonces Selena reiniciaría el esfuerzo de búsqueda de rutas, sólo para 155k satoshis. La siguiente ronda podría encontrar caminos completamente diferentes (optimizados para la cantidad residual de 155k), ¡y dividir la cantidad de 155k en partes completamente diferentes!

[TIP]
====
Aunque parece que 26 partes divididas son muchas, las pruebas en la Lightning Network han entregado con éxito un pago de 0,3679 BTC dividiéndolo en 345 partes.
====

Además, el nodo de Selena actualizaría el gráfico del canal utilizando la información obtenida de los aciertos y errores de la primera ronda para encontrar las rutas y divisiones más óptimas para la segunda ronda.

Digamos que el nodo de Selena calcula que la mejor forma de enviar los 155k residuales es en 6 partes divididas en 80k, 42k, 15k, 11k, 6,5k y 500 satoshis. En la siguiente ronda, Selena sólo obtiene un error, indicando que la parte de 11k satoshis ha fallado. De nuevo, Selena actualiza el gráfico del canal basándose en la información obtenida y vuelve a ejecutar la búsqueda de rutas para enviar el residuo de 11k. Esta vez, tiene éxito con 2 partes de 6k y 5k satoshis, respectivamente.

Este ejemplo de envío de un pago mediante MPP se muestra en <<mpp_rounds>>.

[[mpp_rounds]]
.Sending a payment in multiple rounds with MPP
image::images/mtln_1210.png[]

Al final, el nodo de Selena utilizó 3 rondas de pathfinding para enviar el 1M de satoshis en 30 partes. 

=== Conclusión.

En este capítulo hemos visto la búsqueda de rutas y la entrega de pagos. Hemos visto cómo utilizar el gráfico de canales para encontrar rutas desde un emisor a un receptor. También hemos visto cómo el remitente intentará entregar los pagos en una ruta candidata y repetirlo en un bucle de prueba y error.

También examinamos la incertidumbre de la liquidez del canal (desde la perspectiva del remitente) y las implicaciones que tiene para la búsqueda de rutas. Hemos visto cómo podemos cuantificar la incertidumbre y utilizar la teoría de la probabilidad para sacar algunas conclusiones útiles. También vimos cómo podemos reducir la incertidumbre aprendiendo tanto de los pagos exitosos como de los fallidos.

Por último, vimos cómo la nueva función de pagos multiparte nos permite dividir los pagos en partes, aumentando la probabilidad de éxito incluso para los pagos más grandes.

[[wire_protocol]]
== Protocolo Wire: Encuadre y extensibilidad.

En este capítulo, nos sumergimos en el protocolo alámbrico de la Red Relámpago y también cubrimos todas las diversas palancas de extensibilidad que se han incorporado al protocolo. Al final de este capítulo, un lector ambicioso debería ser capaz de escribir su propio analizador de protocolo de cable para la Red Relámpago. Además de ser capaz de escribir un analizador de protocolo alámbrico personalizado, el lector de este capítulo obtendrá un profundo conocimiento de los diversos mecanismos de actualización que se han incorporado al protocolo.

=== Capa de mensajería en el conjunto de protocolos Lightning.

La messaging layer, que se detalla en este capítulo, consiste en "Framing y formato de mensaje", codificación "Type-Length-Value" y "Feature bits". Estos componentes están resaltados por un esquema en el conjunto de protocolos, que se muestra en <<LN_protocol_wire_message_highlight>>.

[[LN_protocol_wire_message_highlight]]
.Messaging layer in the Lightning protocol suite
image::images/mtln_1301.png["Messaging layer in the Lightning protocol suite"]

=== Wire Framing.

Comenzamos describiendo la estructura de alto nivel del _framing_ del cable dentro del protocolo. Cuando decimos "framing", nos referimos a la forma en que se empaquetan los bytes en el cable para _codificar_ un determinado mensaje de protocolo. Si no se conoce el sistema de encuadre utilizado en el protocolo, una cadena de bytes en el cable se asemejaría a una serie de bytes aleatorios porque no se ha impuesto ninguna estructura. Aplicando el encuadre adecuado para decodificar estos bytes en el cable, seremos capaces de extraer la estructura y finalmente parsear esta estructura en mensajes de protocolo dentro de nuestro lenguaje de alto nivel.

Es importante tener en cuenta que la Red Relámpago es un protocolo encriptado _de extremo a extremo_, y el encuadre del cable está encapsulado en sí mismo dentro de una capa de transporte de mensajes _encriptada_. Como vemos en <<encrypted_message_transport>>, la Red Relámpago utiliza una variante personalizada del Protocolo de Ruido para manejar la encriptación del transporte. Dentro de este capítulo, cada vez que damos un ejemplo de wire framing, asumimos que la capa de encriptación ya ha sido despojada (al decodificar), o que aún no hemos encriptado el conjunto de bytes antes de enviarlos por el cable (codificación).

==== High-Level Wire Framing.

Dicho esto, estamos listos para describir el esquema de alto nivel utilizado para codificar los mensajes en el cable:

  * Los mensajes en el cable comienzan con un campo de tipo _2 bytes_, seguido por un
    carga útil del mensaje.
  * La carga útil del mensaje puede tener un tamaño de hasta 65 KB.
  * Todos los enteros se codifican en big-endian (orden de red).
  * Cualquier byte que siga después de un mensaje definido puede ser ignorado con seguridad.

Sí, eso es todo. Como el protocolo se basa en una capa de cifrado de protocolo de transporte _encapsulado_, no necesitamos una longitud explícita para cada tipo de mensaje. Esto se debe al hecho de que el cifrado de transporte funciona a nivel de _mensaje_, por lo que cuando estamos listos para decodificar el siguiente mensaje, ya sabemos el número total de bytes del propio mensaje. Utilizando 2 bytes para el tipo de mensaje
(codificado en big-endian) significa que el protocolo puede tener hasta 2^16 - 1 o
65.535 mensajes distintos. Como sabemos que todos los mensajes deben ser inferiores a
65 KB, esto simplifica nuestro análisis, ya que podemos utilizar un búfer de tamaño fijo y mantener fuertes límites en la cantidad total de memoria necesaria para analizar un mensaje entrante.

El último punto permite un grado de compatibilidad _retroactiva_ porque los nuevos nodos son capaces de proporcionar información en los mensajes de cable que los nodos más antiguos
(que pueden no entenderlos) pueden ignorar con seguridad. Como veremos más adelante, esta característica, combinada con un formato de extensibilidad de mensajes de cable muy flexible, permite que el protocolo logre también una compatibilidad _hacia adelante_.

==== Codificación de tipos.

Con estos antecedentes de alto nivel, ahora comenzamos con la capa más primitiva: el análisis de los tipos primitivos. Además de la codificación de enteros, el Protocolo Lightning también permite la codificación de una amplia gama de tipos, incluyendo trozos de bytes de longitud variable, claves públicas de curva elíptica, direcciones Bitcoin y firmas. Cuando describimos la _estructura_ de los mensajes cableados más adelante en este capítulo, nos referimos al tipo de alto nivel (el tipo abstracto) en lugar de la representación de bajo nivel de dicho tipo. En esta sección, pelamos esta capa de abstracción para asegurar que nuestro futuro analizador de cables sea capaz de codificar/decodificar correctamente cualquiera de los tipos de nivel superior.

En <<message_types>>, asignamos el nombre de un tipo de mensaje dado a la rutina de alto nivel utilizada para codificar/decodificar el tipo. 

[[message_types]]
.High-level message types
[options="header"]
|===
| High-level type | Framing | Comment
| `node_alias` | A 32-byte fixed-length byte slice      | When decoding, reject if contents are not a valid UTF-8 string
| `channel_id` | A 32-byte fixed-length byte slice that maps an outpoint to a 32-byte value     | Given an outpoint, one can convert it to a `channel_id` by taking the TxID of the outpoint and XORing it with the index (interpreted as the lower 2 bytes)
| `short_chan_id` | An unsigned 64-bit integer (`uint64`) | Composed of the block height (24 bits), transaction index (24 bits), and output index (16 bits) packed into 8 bytes
| `milli_satoshi` | An unsigned 64-bit integer (`uint64`) | Represents 1000th of a satoshi
| `satoshi` | An unsigned 64-bit integer (`uint64`) | The base unit of bitcoin
| `pubkey`  | An secp256k1 public key encoded in _compressed_ format, occupying 33 bytes | Occupies a fixed 33-byte length on the wire
| `sig`     | An ECDSA signature of the secp256k1 elliptic curve | Encoded as a _fixed_ 64-byte byte slice, packed as `R \|\| S`
| `uint8`   | An 8-bit integer  |
| `uint16`  | A 16-bit integer  |
| `uint64`  | A 64-bit integer  |
| `[]byte`  | A variable-length byte slice | Prefixed with a 16-bit integer denoting the length of the bytes
| `color_rgb` | RGB color encoding | Encoded as a series of 8-bit integers
| `net_addr` | The encoding of a network address | Encoded with a 1-byte prefix that denotes the type of address, followed by the address body
|===


En la siguiente sección, describimos la estructura de cada mensaje de red, incluyendo el tipo de prefijo del mensaje junto con el contenido de su cuerpo.

[[tlv_message_extensions]]
=== Extensiones de mensajes de tipo-longitud-valor.

Anteriormente en este capítulo mencionamos que los mensajes pueden tener un tamaño de hasta 65 KB, y que si al analizar un mensaje sobran bytes, estos deben ser ignorados. A primera vista, este requisito puede parecer algo arbitrario; sin embargo, este requisito permite una evolución desincronizada y desacoplada del propio protocolo Lightning. Lo discutiremos más a fondo al final del capítulo. Pero primero, nos centraremos en el uso exacto de esos "bytes extra" al final de un mensaje.

==== El formato de mensaje de los búferes de protocolo.

El formato de serialización de mensajes Protocol Buffers (Protobuf) comenzó como un formato interno utilizado en Google y se ha convertido en uno de los formatos de serialización de mensajes más populares utilizados por los desarrolladores a nivel mundial. El formato Protobuf describe cómo se codifica un mensaje (normalmente algún tipo de estructura de datos relacionada con una API) en el cable y se descodifica en el otro extremo. Existen varios "compiladores de Protobuf" en docenas de lenguajes que actúan como un puente que permite a cualquier lenguaje codificar un Protobuf que podrá ser decodificado por un decodificador compatible en otro lenguaje. Esta compatibilidad de estructuras de datos entre lenguajes permite un amplio abanico de innovaciones, ya que es posible transmitir estructuras e incluso estructuras de datos tipificadas a través de las fronteras del lenguaje y la abstracción.

Los protobufs también son conocidos por su flexibilidad con respecto a cómo manejan los cambios en la estructura de los mensajes subyacentes. Siempre que se respete el esquema de numeración de campos, es posible que una nueva escritura de Protobufs incluya información dentro de un Protobuf que puede ser desconocida para cualquier lector antiguo. Cuando el lector antiguo encuentra el nuevo formato serializado, si hay tipos/campos que no entiende, entonces simplemente los _ignora_. Esto permite la coexistencia de clientes antiguos y nuevos, ya que todos los clientes pueden analizar una parte del nuevo formato de mensaje.

==== Compatibilidad hacia adelante y hacia atrás.

Los protobufs son extremadamente populares entre los desarrolladores porque tienen soporte incorporado para la compatibilidad hacia adelante y hacia atrás. La mayoría de los desarrolladores están probablemente familiarizados con el concepto de compatibilidad hacia atrás. En términos simples, el principio establece que cualquier cambio en un formato de mensaje o API debe hacerse de manera que no rompa el soporte para clientes antiguos. Dentro de nuestros ejemplos de extensibilidad de Protobuf anteriores, la compatibilidad hacia atrás se logra asegurando que las nuevas adiciones al formato Protobuf no rompan las partes conocidas de los lectores más antiguos. La compatibilidad hacia adelante, por otro lado, es igual de importante para las actualizaciones desincronizadas; sin embargo, es menos conocida. Para que un cambio sea compatible con el futuro, los clientes deben simplemente ignorar cualquier información que no entiendan. El mecanismo de la soft fork de actualizar el sistema de consenso de Bitcoin puede decirse que es compatible tanto hacia adelante como hacia atrás: cualquier cliente que no se actualice puede seguir usando Bitcoin, y si se encuentra con cualquier transacción que no entiende, entonces simplemente la ignora ya que sus fondos no están usando esas nuevas características. 

[[tlv]]
=== Formato Type-Length-Value.

Para poder actualizar los mensajes de una manera que sea compatible tanto con el pasado como con el presente, además de los bits de características (más adelante se hablará de ello), la Lightning Network utiliza un formato de serialización de mensajes personalizado llamado simplemente Type-Length-Value, o TLV para abreviar. El formato se inspiró en el formato Protobuf, ampliamente utilizado, y toma prestados muchos conceptos simplificando significativamente la implementación, así como el software que interactúa con el análisis de los mensajes. Un lector curioso podría preguntarse: "¿por qué no usar simplemente Protobufs?". En respuesta, los desarrolladores de Lightning responderían que somos capaces de tener lo mejor de la extensibilidad de Protobufs mientras que también tenemos el beneficio de una implementación más pequeña y por lo tanto un ataque más pequeño. A partir de la versión 3.15.6, el compilador de Protobufs pesa más de 656.671 líneas de código.  En comparación, la implementación de LND del formato de mensaje TLV pesa sólo 2,3k líneas de código (incluyendo las pruebas).

Una vez presentados los antecedentes necesarios, estamos listos para describir el formato TLV en detalle. Se dice que una extensión de mensaje TLV es un flujo de registros TLV individuales. Un registro TLV individual tiene tres componentes: el tipo del registro, la longitud del registro y, por último, el valor opaco del registro:

`tipo`:: Un número entero que representa el nombre del registro que se está codificando
`length`:: La longitud del registro
`value`:: El valor opaco del registro

Tanto el `tipo` como la `longitud` se codifican utilizando un entero de tamaño variable que está inspirado en el entero de tamaño variable (varint) utilizado en el protocolo P2P de Bitcoin, llamado `BigSize` para abreviar.

==== Codificación de enteros BigSize.

En su forma más completa, un entero `BigSize` puede representar valores de hasta 64 bits. En contraste con el formato varint de Bitcoin, el formato `BigSize` codifica enteros usando un orden de bytes big-endian.

El varint `BigSize` tiene dos componentes: el discriminante y el cuerpo. En el contexto del entero `BigSize`, el discriminante comunica al descodificador el tamaño del entero de tamaño variable que le sigue. Recuerde que la particularidad de los enteros de tamaño variable es que permiten al analizador utilizar menos bytes para codificar enteros más pequeños que los más grandes, ahorrando espacio. La codificación de un entero `BigSize` sigue una de las cuatro opciones siguientes:

1. Si el valor es menor que `0xfd` (`253`): Entonces el discriminante no se utiliza realmente, y la codificación es simplemente el propio entero. Esto nos permite codificar enteros muy pequeños sin ninguna sobrecarga adicional.

2. Si el valor es menor o igual que `0xffff` (`65535`): El discriminante se codifica como `0xfd`, lo que indica que el valor que sigue es mayor que `0xfd`, pero menor que `0xffff`. El número se codifica entonces como un entero de 16 bits. Incluyendo el discriminante, podemos codificar un valor mayor que 253, pero menor que 65.535 utilizando 3 bytes.

3. Si el valor es inferior a `0xffffff` (`4294967295`): El discriminante se codifica como `0xfe`. El cuerpo se codifica utilizando un entero de 32 bits, incluyendo el discriminante, y podemos codificar un valor menor que `4.294.967.295` utilizando 5 bytes.

4. En caso contrario, simplemente codificamos el valor como un entero de 64 bits de tamaño completo.


==== Restricciones de codificación de TLV.

Dentro del contexto de un mensaje TLV, los tipos de registro por debajo de `2^16` se dice que están _reservados_ para su uso futuro. Los tipos más allá de este rango deben ser utilizados para extensiones de mensajes "personalizados" utilizados por protocolos de aplicación de nivel superior.

El "valor" de un registro depende del "tipo". En otras palabras, puede tomar cualquier forma porque los analizadores sintácticos intentarán interpretarlo dependiendo del contexto del propio tipo.

==== Codificación canónica de TLV.

Uno de los problemas del formato Protobuf es que las codificaciones del mismo mensaje pueden dar como resultado un conjunto de bytes completamente diferente cuando son codificadas por dos versiones diferentes del compilador. Estos casos de codificación no canónica no son aceptables en el contexto de Lightning, ya que muchos mensajes contienen una firma del compendio del mensaje. Si es posible que un mensaje sea codificado de dos maneras diferentes, entonces sería posible romper la autenticación de una firma inadvertidamente recodificando un mensaje usando un conjunto ligeramente diferente de bytes en el cable.

Para garantizar que todos los mensajes codificados sean canónicos, se definen las siguientes restricciones al codificar:

  * Todos los registros de un flujo TLV deben codificarse en orden estrictamente
    tipo creciente.

  * Todos los registros deben codificar mínimamente los campos `type` y `length`. En otras palabras, debe utilizarse siempre la representación `BigSize` más pequeña para un número entero.

  * Cada "tipo" sólo puede aparecer una vez en un flujo TLV determinado.

Además de estas restricciones de codificación, también se definen una serie de requisitos de interpretación de alto nivel basados en la _aridad_ de un determinado `tipo` de entero. Profundizaremos en estos detalles hacia el final del capítulo, una vez que describamos cómo se actualiza el Protocolo Relámpago en la práctica y en la teoría. 

[[feature_bits]]
=== Bits de características y extensibilidad del protocolo.

Dado que la Lightning Network es un sistema descentralizado, ninguna entidad puede imponer un cambio o modificación del protocolo a todos los usuarios del sistema. Esta característica también se observa en otras redes descentralizadas como Bitcoin.
Sin embargo, a diferencia de Bitcoin, no se requiere un consenso abrumador para cambiar un subconjunto de la Lightning Network. Lightning es capaz de evolucionar a su antojo sin una fuerte exigencia de coordinación porque, a diferencia de Bitcoin, en la Lightning Network no se requiere un consenso global. Debido a este hecho y a los diversos mecanismos de actualización integrados en la Lightning Network, sólo los participantes que deseen utilizar estas nuevas características de la Lightning Network necesitan actualizarse, y entonces pueden interactuar entre sí.

En esta sección, exploramos las diversas formas en que los desarrolladores y los usuarios pueden diseñar e implementar nuevas funciones en la Lightning Network. Los diseñadores de la Lightning Network original sabían que había muchas direcciones futuras posibles para la red y el protocolo subyacente. Por ello, se aseguraron de implementar varios mecanismos de extensibilidad dentro del sistema, que pueden utilizarse para actualizarlo parcial o totalmente de forma desacoplada, desincronizada y descentralizada.

==== Feature Bits como mecanismo de descubrimiento de actualizaciones.

Un lector astuto puede haber notado las diversas ubicaciones en las que se incluyen bits de características dentro del Protocolo Relámpago. Un _feature bit_ es un campo de bits que puede utilizarse para anunciar la comprensión o la adhesión a una posible actualización del protocolo de red. Los bits de características suelen asignarse en pares, lo que significa que cada nueva característica/actualización potencial siempre define dos bits dentro del campo de bits.
Un bit indica que la característica anunciada es _opcional_, lo que significa que el nodo conoce la característica y puede utilizarla, pero no la considera necesaria para su funcionamiento normal. El otro bit indica que la característica es _requerida_, lo que significa que el nodo no continuará operando si un posible compañero no entiende esa característica.

Usando estos dos bits (opcional y requerido), podemos construir una simple matriz de compatibilidad que los nodos/usuarios pueden consultar para determinar si un par es compatible con una característica deseada, como se muestra en la <<table1302>>.

[[table1302]]
.Feature bit compatibility matrix
[options="header"]
|===
|Bit type|Remote optional|Remote required|Remote unknown
|Local optional|✅|✅|✅
|Local required|✅|✅|❌
|Local unknown|✅|❌|❌
|===

A partir de esta matriz de compatibilidad simplificada, podemos ver que mientras la otra parte conozca nuestro bit de característica, entonces podemos interactuar con ellos usando el protocolo. Si la parte ni siquiera sabe a qué bit nos referimos
y requieren la característica, entonces somos incompatibles con ellos. Dentro de la red, las características opcionales se señalan utilizando un _número de bit impar_, mientras que las características requeridas se señalan utilizando un _número de bit par_. Por ejemplo, si un compañero señala que conoce una característica que utiliza el bit +15+, entonces sabemos que se trata de una característica opcional, y podemos interactuar con ellos o responder a sus mensajes aunque no conozcamos la característica. Si por el contrario señalan la característica usando el bit +16+, entonces sabemos que es una característica requerida, y no podemos interactuar con ellos a menos que nuestro nodo también entienda esa característica.

Los desarrolladores de Lightning han ideado una frase fácil de recordar que codifica esta matriz: "está bien ser impar". Esta sencilla regla permite un rico conjunto de interacciones dentro del protocolo, ya que una simple operación de máscara de bits entre dos vectores de bits de características permite a los pares determinar si ciertas interacciones son compatibles entre sí o no. En otras palabras, los bits de características se utilizan como un mecanismo de descubrimiento de actualizaciones: permiten fácilmente a los pares entender si son compatibles o no basándose en los conceptos de bits de características opcionales, requeridos y desconocidos.

Los bits de características se encuentran en los mensajes `node_announcement`, `channel_announcement` y
y en los mensajes "init" del protocolo. Como resultado, estos tres mensajes pueden ser utilizados para señalar el conocimiento y/o la comprensión de las actualizaciones del protocolo en la red. Los bits de características que se encuentran en el mensaje `node_announcement` pueden permitir a un par determinar si sus _conexiones_ son compatibles o no. Los bits de característica que se encuentran en los mensajes `channel_announcement` permiten a un peer determinar si un determinado tipo de pago o HTLC puede transitar por un determinado peer o no. Los bits de características dentro del mensaje `init` permiten a los pares entender si pueden mantener una conexión, y también qué características se negocian para el tiempo de vida de una determinada conexión. 

==== TLV para la compatibilidad hacia adelante y hacia atrás.

Como aprendimos anteriormente en el capítulo, los registros TLV pueden ser utilizados para extender los mensajes de una manera compatible hacia adelante y hacia atrás.
A lo largo del tiempo, estos registros se han utilizado para ampliar los mensajes existentes sin romper el protocolo utilizando el área "indefinida" dentro de un mensaje más allá de ese conjunto de bytes conocidos.

Como ejemplo, el protocolo Lightning original no tenía un concepto de la
"mayor cantidad de HTLC" que podía atravesar un canal según lo dictado por una política de enrutamiento. Más adelante, se añadió el campo `max_htlc` al mensaje `channel_update` para ir introduciendo este concepto con el tiempo. Los pares que reciben un mensaje
Los pares que reciben un `channel_update` que establece dicho campo pero que ni siquiera saben que existe la actualización no se ven afectados por el cambio, pero sus HTLCs son rechazados si están por encima del límite. En cambio, los compañeros más recientes pueden analizar, verificar y utilizar el nuevo campo.

Aquellos que estén familiarizados con el concepto de bifurcaciones suaves en Bitcoin pueden ver ahora algunas similitudes entre los dos mecanismos.  A diferencia de las bifurcaciones suaves a nivel de consenso de Bitcoin, las actualizaciones de la Lightning Network no requieren un consenso abrumador para ser adoptadas. En su lugar, como mínimo, sólo dos pares dentro de la red necesitan entender una nueva actualización para empezar a utilizarla. Normalmente, estos dos pares pueden ser el receptor y el emisor de un pago, o pueden ser los socios de un nuevo payment channel.

==== Una taxonomía de mecanismos de actualización.

En lugar de existir un único mecanismo de actualización ampliamente utilizado dentro de la red (como las bifurcaciones suaves de Bitcoin), existen varios mecanismos de actualización posibles dentro de la Lightning Network. En esta sección, enumeramos estos mecanismos de actualización y proporcionamos un ejemplo real de su uso en el pasado.

===== Actualizaciones internas de la red.

Comenzamos con el tipo de actualización que requiere más coordinación a nivel de protocolo: las actualizaciones de la red interna. Una actualización de la red interna se caracteriza por requerir que _cada nodo_ dentro de una ruta de pago prospectiva comprenda la nueva característica. Una actualización de este tipo es similar a cualquier actualización dentro de Internet que requiera actualizaciones a nivel de hardware dentro de la parte de enlace central de la actualización. Sin embargo, en el contexto de la Red del Rayo, tratamos con software puro, por lo que estas actualizaciones son más fáciles de desplegar, aunque siguen requiriendo mucha más coordinación que cualquier otro mecanismo de actualización en la red.

Un ejemplo de este tipo de actualización en la red fue la introducción de una codificación TLV para la información de enrutamiento codificada en los paquetes de cebolla. El formato anterior utilizaba un formato de mensaje de longitud fija codificado para comunicar información como el siguiente salto.
Como este formato era fijo, no era posible realizar nuevas actualizaciones a nivel de protocolo. El cambio al formato TLV, más flexible, significaba que tras esta actualización se podía desplegar a voluntad cualquier tipo de característica que modificara el tipo de información comunicada en cada salto.

Cabe mencionar que la actualización de TLV onion era una especie de actualización "suave" de la red interna, en el sentido de que si un pago no utilizaba ninguna característica nueva más allá de esa nueva codificación de la información de enrutamiento, entonces un pago podía transmitirse utilizando un conjunto mixto de nodos.

===== Actualizaciones de extremo a extremo.

Para contrastar la actualización de la red interna, en esta sección describimos la
actualización de la red de extremo a extremo. Este mecanismo de actualización difiere de la actualización de la red interna en que sólo requiere que los "extremos" del pago, el emisor y el receptor, se actualicen.

Este tipo de actualización permite una amplia gama de innovaciones sin restricciones dentro de la red. Debido a la naturaleza encriptada de la cebolla de los pagos dentro de la red, aquellos que reenvían HTLCs dentro del centro de la red pueden incluso no saber que se están utilizando nuevas características.

Un ejemplo de actualización de extremo a extremo dentro de la red fue el despliegue de los pagos multiparte (MPP). El MPP es una función a nivel de protocolo que permite dividir un solo pago en varias partes o rutas, que se ensamblan en el receptor para su liquidación. El despliegue de MPP ha ido acompañado de un nuevo bit de función a nivel de `nodo_anuncio` que indica que el receptor sabe cómo manejar los pagos parciales. Suponiendo que el remitente y el destinatario se conozcan (posiblemente a través de una invoice BOLT #11), podrán utilizar la nueva función sin necesidad de negociar.

Otro ejemplo de actualización de extremo a extremo son los distintos tipos de pagos _espontáneos_ desplegados en la red. Uno de los primeros tipos de pagos espontáneos llamado _keysend_ funcionaba simplemente colocando la imagen previa de un pago dentro de la cebolla encriptada. Al recibirlo, el destino descifraba la imagen previa y la utilizaba para liquidar el pago. Como todo el paquete está encriptado de extremo a extremo, este tipo de pago era seguro, ya que ninguno de los nodos intermedios puede desenvolver completamente la cebolla para descubrir la imagen previa del pago. 

==== Actualizaciones a nivel de construcción del canal.

La última categoría amplia de actualizaciones son las que ocurren en el nivel de construcción del canal, pero que no modifican la estructura del HTLC utilizado ampliamente dentro de la red. Cuando decimos construcción del canal, nos referimos a cómo se financia o crea el canal. Como ejemplo, el tipo de canal eltoo puede ser desplegado dentro de la red utilizando un nuevo bit de característica de nivel `node_announcement` así como un bit de característica de nivel `channel_announcement`. Sólo los dos pares en los lados de los canales necesitan entender y anunciar estas nuevas características. Este par de canales puede entonces ser utilizado para reenviar cualquier tipo de pago concedido el canal lo soporta.

Otro es el formato de canal _anchor outputs_ que permite que la comisión de compromiso sea golpeada a través del mecanismo de gestión de comisiones de Bitcoin Child-Pays-For-Parent (CPFP)

=== Conclusión.

El protocolo de cable de Lightning es increíblemente flexible y permite una rápida innovación e interoperabilidad sin un consenso estricto. Es una de las razones por las que la Lightning Network está experimentando un desarrollo mucho más rápido y es atractiva para muchos desarrolladores, que de otro modo podrían encontrar el estilo de desarrollo de Bitcoin demasiado conservador y lento.

[[transporte_de_mensajes_encriptados]]
== El transporte de mensajes encriptados de Lightning.

El protocolo de Lightning, que permite a los pares establecer una comunicación cifrada de extremo a extremo, autenticación y comprobación de integridad.

[NOTE]
====
Parte de este capítulo incluye algunos detalles muy técnicos sobre el protocolo de encriptación y los algoritmos de encriptación utilizados en el transporte encriptado de Lightning. Puedes decidir saltarte esa sección si no te interesan esos detalles.
====

=== Transporte encriptado en el conjunto de protocolos de Lightning.

El componente de transporte de la Lightning Network y sus diversos componentes se muestran en la parte más a la izquierda de la capa de conexión de red en <<LN_protocol_encrypted_transport_highlight>>.

[[LN_protocol_encrypted_transport_highlight]]
.Encrypted message transport in the Lightning protocol suite
image::images/mtln_1401.png["Encrypted message transport in the Lightning protocol suite"]

=== Introducción.

A diferencia de la red P2P de Bitcoin, cada nodo de la Lightning Network se identifica con una clave pública única que le sirve de identidad. Por defecto, esta clave pública se utiliza para cifrar de extremo a extremo _toda_ la comunicación dentro de la red. El cifrado por defecto en el nivel más bajo del protocolo garantiza que todos los mensajes se autentiquen, sean inmunes a los ataques del hombre en el medio (MITM) y al espionaje de terceros, y asegura la privacidad en el nivel de transporte fundamental. En este capítulo, conoceremos en detalle el protocolo de encriptación utilizado por la Lightning Network. Al terminar este capítulo, el lector estará familiarizado con el estado del arte de los protocolos de mensajería cifrada, así como con las diversas propiedades que dicho protocolo proporciona a la red. Vale la pena mencionar que el núcleo del transporte de mensajes cifrados es _agnóstico_ a su uso dentro del contexto de la Lightning Network. Como resultado, el transporte de mensajes encriptados personalizado que utiliza Lightning puede ser introducido en cualquier contexto que requiera una comunicación encriptada entre dos partes. 

=== El gráfico de canales como infraestructura de clave pública descentralizada.

Como aprendimos en <<routing>>, cada nodo tiene una identidad a largo plazo que se utiliza como identificador de un vértice durante la búsqueda de rutas y también se utiliza en las operaciones criptográficas asimétricas relacionadas con la creación de paquetes de enrutamiento encriptados de cebolla. Esta clave pública, que sirve como identidad a largo plazo de un nodo, se incluye en la respuesta de arranque del DNS, así como incrustada dentro del gráfico del canal. Como resultado, antes de que un nodo intente conectarse a otro nodo de la red P2P, ya conoce la clave pública del nodo al que desea conectarse.

Además, si el nodo al que se está conectando ya tiene una serie de canales públicos dentro del grafo, el nodo que se conecta puede verificar aún más la identidad del nodo. Dado que todo el grafo de canales está totalmente autentificado, se puede considerar como una especie de infraestructura de clave pública (PKI) descentralizada: para registrar una clave, se debe abrir un canal público en la blockchain de Bitcoin, y una vez que un nodo ya no tiene ningún canal público, entonces ha sido eliminado de la PKI.

Dado que Lightning es una red descentralizada, es imperativo que no se designe a ninguna parte central el poder de proporcionar una identidad de clave pública dentro de la red. En lugar de una parte central, la Lightning Network utiliza la blockchain de Bitcoin como mecanismo de mitigación de Sybil, ya que obtener una identidad en la red tiene un coste tangible: la tasa necesaria para crear un canal en la blockchain, así como el coste de oportunidad del capital asignado a sus canales. En el proceso de poner en marcha esencialmente una PKI específica del dominio, la Lightning Network es capaz de simplificar significativamente su protocolo de transporte encriptado, ya que no necesita lidiar con todas las complejidades que vienen junto con TLS, el protocolo de seguridad de la capa de transporte.

=== ¿Por qué no TLS?.

Los lectores familiarizados con el sistema TLS pueden preguntarse en este punto: ¿por qué no se utilizó TLS a pesar de los inconvenientes del sistema PKI existente? Es un hecho que los "certificados autofirmados" pueden utilizarse para eludir de forma efectiva el sistema PKI global existente, simplemente afirmando la identidad de una clave pública determinada entre un conjunto de pares. Sin embargo, incluso con el sistema PKI existente fuera del camino, TLS tiene varios inconvenientes que llevaron a los creadores de la Lightning Network a optar por un protocolo de cifrado personalizado más compacto.

Para empezar, TLS es un protocolo que existe desde hace varias décadas y, por lo tanto, ha evolucionado con el tiempo a medida que se han producido nuevos avances en el espacio del cifrado de transporte. Sin embargo, con el tiempo esta evolución ha hecho que el protocolo se dispare en tamaño y complejidad. En las últimas décadas, se han descubierto y parcheado varias vulnerabilidades en TLS, y cada evolución ha aumentado aún más la complejidad del protocolo. Como resultado de la antigüedad del protocolo, existen varias versiones e iteraciones, lo que significa que un cliente necesita entender muchas de las iteraciones anteriores del protocolo para comunicarse con una gran parte de la Internet pública, aumentando aún más la complejidad de la implementación.

En el pasado, se han descubierto varias vulnerabilidades de seguridad de memoria en implementaciones de SSL/TLS ampliamente utilizadas. Empaquetar dicho protocolo dentro de cada nodo Lightning serviría para aumentar la superficie de ataque de los nodos expuestos a la red pública peer-to-peer. Para aumentar la seguridad de la red en su conjunto y minimizar la superficie de ataque explotable, los creadores de la Lightning Network optaron por adoptar el marco de protocolo Noise. El protocolo Noise internaliza varias de las lecciones de seguridad y privacidad aprendidas a lo largo del tiempo debido al continuo escrutinio del protocolo TLS durante décadas. En cierto modo, la existencia de Noise permite a la comunidad "empezar de nuevo", con un protocolo más compacto y simplificado que conserva todas las ventajas añadidas de TLS.

=== El marco del protocolo Noise.

El marco del protocolo Noise es un protocolo de cifrado de mensajes moderno, extensible y flexible diseñado por los creadores del protocolo Signal. El Protocolo Signal es uno de los protocolos de cifrado de mensajes más utilizados en el mundo. Lo utilizan tanto Signal como Whatsapp, que en conjunto son utilizados por más de mil millones de personas en todo el mundo. El marco Noise es el resultado de décadas de evolución tanto en el ámbito académico como en la industria de los protocolos de cifrado de mensajes. Lightning utiliza el marco de protocolo Noise para implementar un protocolo de encriptación _orientado a mensajes_ utilizado por todos los nodos para comunicarse entre sí. 

Una sesión de comunicación mediante Ruido tiene dos fases distintas: la fase de apretón de manos y la fase de mensajería. Antes de que dos partes puedan comunicarse entre sí, tienen que llegar a un secreto compartido que sólo ellos conocen y que se utilizará para cifrar y autenticar los mensajes que se envíen. Para llegar a una clave final compartida entre las dos partes se utiliza un tipo de acuerdo de clave autenticada. En el contexto del protocolo Noise, este acuerdo de clave autentificada se denomina _handshake_. Una vez que se ha completado el handshake, ambos nodos pueden enviarse mensajes encriptados. Cada vez que los pares necesitan conectarse o reconectarse entre sí, se ejecuta una nueva iteración del protocolo handshake, lo que garantiza que se logre el secreto hacia adelante (la filtración de la clave de una transcripción anterior no compromete ninguna transcripción futura).

Dado que el protocolo Noise permite al diseñador del protocolo elegir entre varias primitivas criptográficas, como la encriptación simétrica y la criptografía de clave pública, es habitual que cada variante del protocolo Noise reciba un nombre único. En el espíritu de "Ruido", cada sabor del protocolo selecciona un nombre derivado de algún tipo de "ruido". En el contexto de la
Lightning Network, el sabor del Protocolo de Ruido utilizado se denomina a veces Brontide. Una _brontida_ es un ruido bajo y ondulante, similar al que se oiría durante una tormenta eléctrica cuando está muy lejos.

=== Transporte encriptado de rayos en detalle.

En esta sección desglosaremos el protocolo de transporte encriptado de Lightning y profundizaremos en los detalles de los algoritmos criptográficos y el protocolo utilizado para establecer comunicaciones encriptadas, autenticadas y con garantía de integridad entre pares. No dudes en saltarte esta sección si encuentras este nivel de detalle desalentador.

==== Noise_XK: el protocolo Noise Handshake de Lightning Network.

El protocolo Noise es extremadamente flexible, ya que anuncia varios handshakes, cada uno con diferentes propiedades de seguridad y privacidad para que un posible implementador del protocolo pueda elegir. Una exploración profunda de cada uno de los handshakes y sus diversas compensaciones está fuera del alcance de este capítulo.
Dicho esto, la Lightning Network utiliza un handshake específico denominado
`Noise_XK`. La única propiedad que ofrece este handshake es la __ocultación de la identidad__: para que un nodo pueda iniciar una conexión con otro nodo, debe conocer primero su clave pública. Mecánicamente, esto significa que la clave pública del respondedor nunca se transmite durante el contexto del apretón de manos. En su lugar, se utiliza una serie inteligente de comprobaciones de la curva elíptica Diffie-Hellman (ECDH) y del código de autenticación de mensajes (MAC) para autenticar al respondedor.

==== Notación del apretón de manos y flujo del protocolo.

Cada handshake suele constar de varios pasos. En cada paso se envía algún material (posiblemente) cifrado a la parte contraria, se realiza un ECDH (o varios), y el resultado del apretón de manos se "mezcla" en una _transcripción_ del protocolo. Esta transcripción sirve para autenticar cada paso del protocolo y ayuda a frustrar un tipo de ataques "man-in-the-middle". Al final del apretón de manos, se producen dos claves, `ck` y `k`, que se utilizan para cifrar los mensajes (`k`) y rotar las claves (`ck`) durante toda la sesión.

En el contexto de un apretón de manos, `s` suele ser una clave pública estática a largo plazo.
En nuestro caso, el sistema criptográfico de clave pública utilizado es uno de curva elíptica, instanciado con la curva `secp256k1`, que se utiliza en otras partes de Bitcoin.
Se generan varias claves efímeras a lo largo del handshake. Usamos `e` para referirnos a una nueva ephemeral key. Las operaciones ECDH entre dos claves se anotan como la concatenación de dos claves. Como ejemplo, "e" representa una operación ECDH entre dos claves efímeras.

==== Resumen de alto nivel.

Utilizando la notación expuesta anteriormente, podemos describir sucintamente el `Noise_XK` de la siguiente manera:
```
    Noise_XK(s, rs):
       <- rs
       ...
       -> e, e(rs)
       <- e, ee
       -> s, se
```

El protocolo comienza con la "pretransmisión" de la clave estática del respondedor (`rs`) al iniciador. Antes de ejecutar el handshake, el iniciador debe generar su propia clave estática (`s`). Durante cada paso del apretón de manos, todo el material enviado a través del cable y las claves enviadas/utilizadas se codifican incrementalmente en un "resumen del apretón de manos", "h". Este resumen nunca se envía a través del cable durante el apretón de manos, y en su lugar se utiliza como "datos asociados" cuando se envía AEAD (cifrado autenticado con datos asociados) a través del cable.
Los datos asociados (AD) permiten que un protocolo de cifrado autentifique información adicional junto con un paquete de texto cifrado. En otros dominios, el AD puede ser un nombre de dominio, o una porción de texto plano del paquete. 

La existencia de "h" garantiza que si se sustituye una parte de un mensaje de apretón de manos transmitido, la otra parte se dará cuenta. En cada paso, se comprueba un compendio MAC. Si la comprobación MAC tiene éxito, la parte receptora sabe que el apretón de manos ha tenido éxito hasta ese momento. De lo contrario, si la comprobación de la MAC falla, el proceso de intercambio de información ha fracasado y la conexión debe finalizar.

El protocolo también añade un nuevo dato a cada mensaje de enlace: la versión del protocolo. La versión inicial del protocolo es "0". En el momento de escribir esto, no se han creado nuevas versiones de protocolo. Por lo tanto, si un peer recibe una versión diferente a `0`, debe rechazar el intento de inicio del handshake.

En cuanto a las primitivas criptográficas, se utiliza SHA-256 como función hash, `secp256k1` como curva elíptica y `ChaChaPoly-130` como construcción AEAD
(cifrado simétrico).

Cada variante del Protocolo de Ruido tiene una cadena ASCII única para referirse a ella. Para garantizar que dos partes utilicen la misma variante del protocolo, la cadena ASCII se convierte en un resumen que se utiliza para inicializar el estado inicial del apretón de manos. En el contexto de la Lightning Network, la cadena ASCII que describe el protocolo es `Noise_XK_secp256k1_ChaChaPoly_SHA256`.

==== Handshake en tres actos.

La parte del apretón de manos puede separarse en tres "actos" distintos.
El apretón de manos completo lleva 1,5 viajes de ida y vuelta entre el iniciador y el respondedor.
En cada acto, se envía un único mensaje entre ambas partes. El mensaje del apretón de manos es una carga útil de tamaño fijo con el prefijo de la versión del protocolo.

El Protocolo de Ruido utiliza una notación inspirada en los objetos para describir el protocolo en cada paso. Durante la configuración del estado del apretón de manos, cada parte inicializará las siguientes variables:

`ck`:: La _clave de encadenamiento_. Este valor es el hash acumulado de todas las
   salidas anteriores de ECDH. Al final del handshake, `ck` se utiliza para derivar
   las claves de encriptación de los mensajes Lightning.

`h`:: El _handshake hash_. Este valor es el hash acumulado de _todos_ los
   datos del handshake que se han enviado y recibido hasta ahora durante el proceso
   de la negociación.

`temp_k1`, `temp_k2`, `temp_k3`:: Las _claves intermedias_. Se utilizan para
   cifrar y descifrar las cargas útiles AEAD de longitud cero al final de cada
   mensaje.

 `e`:: El _par de claves efímeras_ de una parte. Para cada sesión, un nodo debe generar una
   nueva ephemeral key con fuerte aleatoriedad criptográfica.

`s`:: El _par de claves estáticas_ de una parte (`ls` para la local, `rs` para la remota).

Dado este estado de sesión de handshake y mensajería, definiremos una serie de funciones que operarán sobre el estado de handshake y mensajería. Al describir el protocolo del apretón de manos, utilizaremos estas variables de forma similar al pseudocódigo para reducir la verbosidad de la explicación de cada paso del protocolo. Definiremos las primitivas _funcionales_ del handshake como:

`ECDH(k, rk)`:: Realiza una operación de Curva Elíptica Diffie-Hellman utilizando
    k`, que es una clave privada `secp256k1` válida, y `rk`, que es una clave pública válida.
+
El valor devuelto es el SHA-256 del formato comprimido del
      punto generado.

`HKDF(salt,ikm)`:: Una función definida en la `RFC 5869`,
    evaluada con un campo `info` de longitud cero.
+
Todas las invocaciones de `HKDF` devuelven implícitamente 64 bytes de
       aleatoriedad criptográfica utilizando el componente de extracción y expansión del
       HKDF.

EncriptarConAD(k, n, ad, texto plano)`:: Devuelve `encrypt(k, n, ad, plaintext)`.
+
Donde `encrypt` es una evaluación de `ChaCha20-Poly1305` (variante de Internet Engineering Task Force)
       con los argumentos pasados, con el nonce `n` codificado como 32 bits cero,
       seguido de un valor _little-endian_ de 64 bits. Nota: esto sigue la convención de Noise
       en lugar de nuestra convención normal endian.

DecryptWithAD(k, n, ad, ciphertext)`:: La salida es `decrypt(k, n, ad, ciphertext)`.
+
Donde `descifrar` es una evaluación de `ChaCha20-Poly1305` (variante IETF)
       con los argumentos pasados, con el nonce `n` codificado como 32 bits cero,
       seguido de un valor _little-endian_ de 64 bits.

GenerarClave()`:: Genera y devuelve un nuevo par de claves `secp256k1`.
+
El objeto devuelto por `generateKey` tiene dos atributos: `.pub`, que devuelve un objeto abstracto que representa la clave pública; y `.priv`, que representa la clave privada utilizada para generar la clave pública
+
El objeto también tiene un único método: `.serializeCompressed()`.

`a || b`:: Esto denota la concatenación de dos cadenas de bytes `a` y `b`. 

===== Inicialización del estado de la sesión de Handshake.

Antes de comenzar el proceso de handshake, ambos lados necesitan inicializar el estado inicial que usarán para avanzar en el proceso de handshake. Para empezar, ambos lados necesitan construir el resumen inicial del apretón de manos `h`.

 1. ++h = SHA-256(__protocoloNombre__)++
+
Donde ++__protocolName__ = "Noise_XK_secp256k1_ChaChaPoly_SHA256"++ codificado como
      una cadena ASCII.

 2. `ck = h`

 3. ++h = SHA-256(h || __prologue__)++
+
Donde ++__prólogo__++ es la cadena ASCII: `relámpago`.

Además del nombre del protocolo, también añadimos un "prólogo" adicional que se utiliza para vincular aún más el contexto del protocolo a la Lightning Network.

Para concluir el paso de inicialización, ambas partes mezclan la clave pública del respondedor en el resumen del apretón de manos. Dado que este compendio se utiliza mientras se envían los datos asociados con un texto cifrado de longitud cero (sólo la MAC), esto garantiza que el iniciador conoce efectivamente la clave pública del respondedor.

 * El nodo iniciador mezcla la clave pública estática del nodo respondedor
   serializada en el formato comprimido de Bitcoin: `h = SHA-256(h || rs.pub.serializeCompressed())`

 * El nodo que responde mezcla su clave pública estática local serializada en
   formato comprimido de Bitcoin: `h = SHA-256(h || ls.pub.serializeCompressed())`

===== Actúa el Handshake.

Después de la inicialización del handshake, podemos comenzar la ejecución real del proceso de handshake. El handshake se compone de una serie de tres mensajes enviados entre el iniciador y el respondedor, a partir de ahora denominados
"actos". Dado que cada acto es un único mensaje enviado entre las partes, un apretón de manos se completa en un total de 1,5 viajes de ida y vuelta (0,5 para cada acto).

El primer acto completa la parte inicial del intercambio de claves Diffie-Hellman (DH) triple incremental (utilizando una nueva ephemeral key generada por el iniciador) y también garantiza que el iniciador conoce realmente la clave pública a largo plazo del respondedor. Durante el segundo acto, el respondedor transmite al iniciador la ephemeral key que desea utilizar para la sesión y, una vez más, mezcla de forma incremental esta nueva clave en el triple apretón de manos DH. Durante el tercer y último acto, el iniciador transmite su clave pública estática a largo plazo al respondedor y ejecuta la operación DH final para mezclarla en el secreto compartido resultante.

====== Primer acto.

```
    -> e, es
```

El Acto Uno se envía desde el iniciador al respondedor. Durante el Acto Uno, el iniciador intenta satisfacer un reto implícito del respondedor. Para completar este desafío, el iniciador debe conocer la clave pública estática del respondedor.

El mensaje del apretón de manos tiene _exactamente_ 50 bytes: 1 byte para la versión del apretón de manos, 33 bytes para la clave pública efímera comprimida del iniciador y 16 bytes para la etiqueta `poly1305`.

Acciones del remitente:

1. `e = generateKey()`
2. h = SHA-256(h || e.pub.serializeCompressed())`.
+
La ephemeral key recién generada se acumula en el digesto del
       digest del apretón de manos.
3. `es = ECDH(e.priv, rs)`
+
El iniciador realiza un ECDH entre su ephemeral key recién generada
       y la clave pública estática del nodo remoto.
4. `ck, temp_k1 = HKDF(ck, es)`
+
Se genera una nueva clave de cifrado temporal, que se
       que se utiliza para generar la MAC de autenticación.
5. `c = encryptWithAD(temp_k1, 0, h, zero)`
+
Donde `cero` es un texto plano de longitud cero.
6. `h = SHA-256(h || c)`
+
Finalmente, el texto cifrado generado se acumula en el compendio del
       de autenticación del apretón de manos.
7. Enviar `m = 0 || e.pub.serializeCompressed() || c` al respondedor a través del buffer de red.

Acciones del receptor:

1. Leer _exactamente_ 50 bytes del buffer de red.
2. Parsear el mensaje leído (`m`) en `v`, `re`, y `c`:
    * Donde `v` es el _primer_ byte de `m`, `re` son los siguientes 33
      bytes de `m`, y `c` son los últimos 16 bytes de `m`.
    * Los bytes brutos de la clave pública efímera de la parte remota (`re`) deben ser
      deserializados en un punto de la curva usando coordenadas afines codificadas
      por el formato compuesto serializado de la clave.
3. Si `v` es una versión del apretón de manos no reconocida, entonces el respondedor debe
    abortar el intento de conexión.
4. `h = SHA-256(h || re.serializeCompressed())`
+
El respondedor acumula la ephemeral key del iniciador en el compendio del
      de autenticación del apretón de manos.
5. `es = ECDH(s.priv, re)`
+
El respondedor realiza un ECDH entre su clave privada estática y la
      clave pública efímera del iniciador.
6. `ck, temp_k1 = HKDF(ck, es)`
+
Se genera una nueva clave de cifrado temporal, que se
      que se utilizará en breve para comprobar la MAC de autenticación.
7. `p = decryptWithAD(temp_k1, 0, h, c)`
+
Si la comprobación de la MAC en esta operación falla, entonces el iniciador _no_
      no conoce la clave pública estática del respondedor. Si este es el caso, entonces el
      respondedor debe terminar la conexión sin más mensajes.
8. `h = SHA-256(h || c)`
+
El texto cifrado recibido se mezcla con el resumen del apretón de manos. Este paso sirve
       para asegurar que la carga útil no fue modificada por un MITM. 


====== Segundo acto.

```
   <- e, ee
```

El Acto Dos se envía desde el respondedor al iniciador. El Acto Dos _sólo_ tendrá lugar si el Acto Uno fue exitoso. El Acto Uno fue exitoso si el respondedor fue capaz de descifrar correctamente y comprobar la MAC de la etiqueta enviada al final del Acto Uno.

El apretón de manos es _exactamente_ 50 bytes: 1 byte para la versión del apretón de manos, 33 bytes para la clave pública efímera comprimida del respondedor y 16 bytes para la etiqueta `poly1305`.

Acciones del remitente:

1. `e = generateKey()`
2. h = SHA-256(h || e.pub.serializeCompressed())`.
+
La ephemeral key recién generada se acumula en el digesto del
       digest del apretón de manos.
3. `ee = ECDH(e.priv, re)`
+
Donde `re` es la ephemeral key del iniciador, que fue recibida
       durante el primer acto.
4. `ck, temp_k2 = HKDF(ck, ee)`
+
Se genera una nueva clave de cifrado temporal, que se
       utilizada para generar la MAC de autentificación.
5. `c = encryptWithAD(temp_k2, 0, h, zero)`
+
Donde `cero` es un texto plano de longitud cero.
6. `h = SHA-256(h || c)`
+
Finalmente, el texto cifrado generado se acumula en el compendio del
       de autenticación del apretón de manos.
7. Enviar `m = 0 || e.pub.serializeCompressed() || c` al iniciador a través del buffer de red.

Acciones del receptor:

1. Leer _exactamente_ 50 bytes del buffer de red.
2. Parsear el mensaje leído (`m`) en `v`, `re`, y `c`:
+
Donde `v` es el _primer_ byte de `m`, `re` son los siguientes 33
      bytes de `m`, y `c` son los últimos 16 bytes de `m`.
3. Si `v` es una versión de handshake no reconocida, entonces el respondedor debe
    abortar el intento de conexión.
4. `h = SHA-256(h || re.serializeCompressed())`
5. `ee = ECDH(e.priv, re)`
+
Donde `re` es la clave pública efímera del respondedor.
+
Los bytes brutos de la clave pública efímera de la parte remota (`re`) deben ser
      deserializados en un punto de la curva utilizando coordenadas afines codificadas
      por el formato compuesto serializado de la clave.
6. `ck, temp_k2 = HKDF(ck, ee)`
+
Se genera una nueva clave de cifrado temporal, que se
       utilizada para generar la MAC de autentificación.
7. `p = decryptWithAD(temp_k2, 0, h, c)`
+
Si la comprobación de la MAC en esta operación falla, el iniciador debe
      terminar la conexión sin más mensajes.
8. `h = SHA-256(h || c)`
+
El texto cifrado recibido se mezcla con el resumen del apretón de manos. Este paso sirve
       para asegurar que la carga útil no fue modificada por un MITM.

====== Tercer acto.

```
   -> s, se
```

El acto tres es la fase final del acuerdo de clave autenticada descrito en esta sección. Este acto se envía desde el iniciador al respondedor como paso final. El Acto Tres se ejecuta _si y sólo si_ el Acto Dos fue exitoso.
Durante el tercer acto, el iniciador transporta su clave pública estática al respondedor encriptada con _fuerte_ secreto hacia adelante, utilizando la clave secreta derivada del `HKDF` acumulada en este punto del apretón de manos.

El apretón de manos tiene _exactamente_ 66 bytes: 1 byte para la versión del apretón de manos, 33 bytes para la clave pública estática encriptada con el cifrado de flujo `ChaCha20`, 16 bytes para la etiqueta de la clave pública encriptada generada mediante la construcción AEAD, y 16 bytes para una etiqueta final de autenticación.

Acciones del remitente:

1. `c = encryptWithAD(temp_k2, 1, h, s.pub.serializeCompressed())`
+
Donde `s` es la clave pública estática del iniciador.
2. `h = SHA-256(h || c)`
3. `se = ECDH(s.priv, re)`
+
Donde `re` es la clave pública efímera del respondedor.
4. `ck, temp_k3 = HKDF(ck, se)`
+
El secreto compartido intermedio final se mezcla con la clave de encadenamiento en curso.
5. `t = encryptWithAD(temp_k3, 0, h, zero)`
+
Donde `cero` es un texto plano de longitud cero.
6. `sk, rk = HKDF(ck, cero)`
+
Donde "cero" es un texto plano de longitud cero,
       `sk` es la clave que utilizará el iniciador para cifrar los mensajes al
       responder,
       y `rk` es la clave que utilizará el iniciador para descifrar los mensajes enviados por
       el respondedor.
+
Las claves de cifrado finales, que se utilizarán para enviar y
       mensajes durante la duración de la sesión.
7. `rn = 0, sn = 0`
+
Los nonces de envío y recepción se inicializan a 0.
8. Enviar `m = 0 || c | t` por el buffer de la red. 

Acciones del receptor:

1. Leer _exactamente_ 66 bytes del buffer de red.
2. Analizar el mensaje leído (`m`) en `v`, `c` y `t`:
+
Donde `v` es el _primer_ byte de `m`, `c` son los siguientes 49
      bytes de `m`, y `t` son los últimos 16 bytes de `m`.
3. Si `v` es una versión de handshake no reconocida, entonces el respondedor debe
    abortar el intento de conexión.
4. `rs = decryptWithAD(temp_k2, 1, h, c)`
+
En este punto, el respondedor ha recuperado la clave pública estática del
       iniciador.
5. `h = SHA-256(h || c)`
6. `se = ECDH(e.priv, rs)`
+
Donde `e` es la ephemeral key original del respondedor.
7. `ck, temp_k3 = HKDF(ck, se)`
8. `p = decryptWithAD(temp_k3, 0, h, t)`
+
Si la comprobación de MAC en esta operación falla, entonces el respondedor debe
       terminar la conexión sin más mensajes.
9. `rk, sk = HKDF(ck, cero)`
+
Donde `cero` es un texto plano de longitud cero,
       `rk` es la clave que utilizará el respondedor para descifrar los mensajes enviados
       por el iniciador,
       y `sk` es la clave que utilizará el respondedor para cifrar los mensajes al
       al iniciador.
+
Las claves de cifrado finales, que se utilizarán para enviar y
       recibir mensajes durante la duración de la sesión, son generadas.
10. `rn = 0, sn = 0`
+
Los nonces de envío y recepción se inicializan a 0.

===== Cifrado de mensajes de transporte.

Al concluir el tercer acto, ambas partes han obtenido las claves de cifrado, que se utilizarán para cifrar y descifrar los mensajes durante el resto de la sesión.

Los mensajes reales del Protocolo Relámpago se encapsulan en textos cifrados AEAD.
Cada mensaje lleva como prefijo otro texto cifrado AEAD, que codifica la longitud total del siguiente mensaje Lightning (sin incluir su MAC).

El tamaño _máximo_ de _cualquier_ mensaje Lightning no debe superar los 65.535 bytes. Un tamaño máximo de 65.535 simplifica las pruebas, facilita la gestión de la memoria y ayuda a mitigar los ataques por agotamiento de memoria.

Para dificultar el análisis del tráfico, el prefijo de longitud de todos los mensajes Lightning cifrados también está cifrado. Además, una etiqueta de 16 bytes
al prefijo de longitud encriptado para garantizar que la longitud del paquete no se ha modificado durante el vuelo y también para evitar la creación de un oráculo de descifrado.

La estructura de los paquetes en el cable se asemeja al diagrama de <<noise_encrypted_packet>>.

[[noise_encrypted_packet]]
.Encrypted packet structure
image::images/mtln_1402.png["Encrypted Packet Structure"]

La longitud del mensaje prefijado se codifica como un entero big-endian de 2 bytes, para una longitud máxima total del paquete de 2 + 16 + 65.535 + 16 = 65.569 bytes.

====== Cifrado y envío de mensajes.

Para cifrar y enviar un mensaje Lightning (`m`) al flujo de red, dada una clave de envío (`sk`) y un nonce (`sn`), se completan los siguientes pasos:

[role="pagebreak-before"]
1. Sea `l = len(m)`.
+
Donde `len` obtiene la longitud en bytes del mensaje Relámpago.
2. Serializar `l` en 2 bytes codificados como un entero big-endian.
3. Encrypt `l` (using `ChaChaPoly-1305`, `sn`, and `sk`), to obtain `lc`
    (18 bytes).
    * The nonce `sn` is encoded as a 96-bit little-endian number. As the
      decoded nonce is 64 bits, the 96-bit nonce is encoded as 32 bits
      of leading zeros followed by a 64-bit value.
        * The nonce `sn` must be incremented after this step.
    * A zero-length byte slice is to be passed as the AD (associated data).
4. Finally, encrypt the message itself (`m`) using the same procedure used to
    encrypt the length prefix. Let this encrypted ciphertext be known as <code>c</code>.
+
The nonce `sn` must be incremented after this step.
5. Send `lc || c` over the network buffer.

====== Receiving and decrypting messages.

To decrypt the _next_ message in the network stream, the following steps are completed:

1. Read _exactly_ 18 bytes from the network buffer.
2. Let the encrypted length prefix be known as `lc`.
3. Decrypt `lc` (using `ChaCha20-Poly1305`, `rn`, and `rk`) to obtain the size of
    the encrypted packet `l`.
    * A zero-length byte slice is to be passed as the AD (associated data).
    * The nonce `rn` must be incremented after this step.
4. Read _exactly_ `l + 16` bytes from the network buffer, and let the bytes be
    known as <code>c</code>.
5. Decrypt `c` (using `ChaCha20-Poly1305`, `rn`, and `rk`) to obtain decrypted
    plain-text packet `p`.
+
The nonce `rn` must be incremented after this step.

===== Lightning message key rotation.

Changing keys regularly and forgetting previous keys is useful to prevent the decryption of old messages, in the case of later key leakage (i.e., backward secrecy).

Key rotation is performed for _each_ key (`sk` and `rk`) _individually_. A key is to be rotated after a party encrypts or decrypts 1,000 times with it (i.e., every 500 messages).  This can be properly accounted for by rotating the key once the nonce dedicated to it exceeds 1,000. 

La rotación de claves para una clave `k` se realiza según los siguientes pasos

1. Sea `ck` la clave de encadenamiento obtenida al final del tercer acto.
2. `ck', k' = HKDF(ck, k)`
3. Restablecer el nonce de la clave a `n = 0`.
4. `k = k'`
5. `ck = ck'`

=== Conclusión.

El cifrado de transporte subyacente de Lightning se basa en el protocolo Noise y ofrece fuertes garantías de seguridad de privacidad, autenticidad e integridad para todas las comunicaciones entre pares de Lightning.

A diferencia de Bitcoin, donde los pares se comunican a menudo "en claro" (sin encriptación), todas las comunicaciones de Lightning están encriptadas entre pares. Además del cifrado de transporte (peer-to-peer), en la Lightning Network, los pagos están _también_ cifrados en paquetes de cebolla (hop-to-hop) y los detalles del pago se envían fuera de banda entre el remitente y el destinatario (end-to-end). La combinación de todos estos mecanismos de seguridad es acumulativa y proporciona una defensa en capas contra la desanonimización, los ataques del hombre en el medio y la vigilancia de la red.

Por supuesto, ninguna seguridad es perfecta y veremos en <<security_and_privacy>> que estas propiedades pueden ser degradadas y atacadas. Sin embargo, la Lightning Network mejora significativamente la privacidad de Bitcoin.

[[invoices]]
== Solicitudes de pago de Lightning.

En este capítulo veremos las _solicitudes de pago Lightning_, o como se conocen más comúnmente, las _facturas Lightning_.

=== Facturas en el conjunto de protocolos Lightning.

Las _solicitudes de pago_, también conocidas como _facturas_, forman parte de la capa de pagos y se muestran en la parte superior izquierda de <<LN_payment_request_highlight>>.

[[LN_payment_request_highlight]]
.Payment requests in the Lightning protocol suite
image::images/mtln_1501.png["Payment requests in the Lightning protocol suite"]

=== Introducción.

Como hemos aprendido a lo largo del libro, para completar un pago con Lightning se necesitan mínimamente dos datos: un hash de pago y un destino. Como en la Lightning Network se utiliza SHA-256 para implementar los HTLC, esta información requiere 32 bytes para comunicarse. Los destinos, por su parte, son simplemente la clave pública `secp256k1` del nodo que desea recibir un pago.
El objetivo de una solicitud de pago en el contexto de la Lightning Network es comunicar estas dos informaciones del emisor al receptor. El formato de código QR para comunicar la información necesaria para completar un pago de receptor a remitente se describe en https://github.com/lightningnetwork/lightning-rfc/blob/master/11-payment-encoding.md[BOLT #11: Protocolo de facturación para pagos Lightning]. En la práctica, en una solicitud de pago se comunica algo más que el hash del pago y el destino para que la codificación sea más completa.

=== Solicitudes de Lightning payment frente a direcciones Bitcoin.

Una pregunta habitual cuando la gente se encuentra por primera vez con una solicitud de Lightning payment es: ¿por qué no se puede utilizar un formato de dirección estática normal en su lugar?

Para responder a esta pregunta, primero hay que interiorizar en qué se diferencia Lightning de la capa base de Bitcoin como método de pago. En comparación con una dirección de Bitcoin, que puede utilizarse para realizar un número potencialmente ilimitado de pagos
(aunque la reutilización de una dirección de Bitcoin puede degradar la privacidad de uno), una solicitud de pago de Lightning sólo debe utilizarse _una vez_.  Esto se debe al hecho de que el envío de un pago a una dirección Bitcoin utiliza esencialmente un criptosistema de clave pública para "codificar" el pago de manera que sólo el verdadero "propietario" de esa dirección Bitcoin pueda canjearlo.

En cambio, para completar un pago con Lightning, el receptor debe revelar un "secreto" a toda la ruta de pago, incluido el remitente. Esto puede interpretarse como el uso de una especie de criptografía simétrica específica del dominio, ya que la preimagen de pago es, a efectos prácticos, un nonce (número que sólo se utiliza una vez). Si el remitente intenta realizar otro pago utilizando ese hash de pago idéntico, se arriesga a perder los fondos porque el pago puede no llegar al destino. Es seguro asumir que después de que una imagen previa ha sido revelada, todos los nodos en la ruta la mantendrán para siempre, entonces en lugar de reenviar el HTLC para cobrar una tarifa de enrutamiento si el pago se completa, pueden simplemente liquidar el pago en esa instancia y ganar la cantidad total del pago a cambio. Como resultado, no es seguro utilizar una solicitud de pago más de una vez.

Existen nuevas variantes de la solicitud de pago original de Lightning que permiten al remitente reutilizarlas tantas veces como quiera. Estas variantes invierten el flujo de pago normal, ya que el remitente transmite una imagen previa dentro de la carga útil cifrada de la cebolla al receptor, que es el único que puede descifrarla y liquidar el pago. Alternativamente, suponiendo un mecanismo que permita al remitente solicitar típicamente una nueva solicitud de pago al receptor, entonces se puede utilizar un protocolo interactivo que permita cierto grado de reutilización de la solicitud de pago. 

=== BOLT #11: Serialización e interpretación de solicitudes de pago de Lightning.

En esta sección, describiremos el mecanismo utilizado para codificar el conjunto de información necesaria para completar un pago en la Lightning Network. Como se mencionó anteriormente, el hash y el destino del pago es la cantidad mínima de información requerida para completar un pago. Sin embargo, en la práctica, también se comunica más información, como la información de bloqueo de tiempo, la expiración de la solicitud de pago y, posiblemente, una dirección de reserva en la cadena. El documento de especificación completo es https://github.com/lightningnetwork/lightning-rfc/blob/master/11-payment-encoding.md[BOLT #11: Invoice Protocol for Lightning Payments].

==== Codificación de solicitudes de pago en la práctica.

En primer lugar, examinemos el aspecto de una solicitud de pago real en la práctica. La siguiente es una solicitud de pago válida que podría haberse utilizado para completar un pago en la red principal Lightning Network en el momento en que se creó:

----
lnbc2500u1pvjluezpp5qqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqypqdq5xysxxatsyp3k7enxv4jsxqzpuaztrnwngzn3kdzw5hydlzf03qdgm2hdq27cqv3agm2awhz5se903vruatfhq77w3ls4evs3ch9zw97j25emudupq63nyw24cg27h2rspfj9srp
----

==== El prefijo legible para el ser humano.

Si miramos la cadena, podemos extraer una parte que podemos analizar con nuestros ojos, mientras que el resto parece un conjunto aleatorio de cadenas. La parte que puede ser analizada por un ser humano se denomina "prefijo legible por el ser humano". Permite a un humano extraer rápidamente alguna información relevante de una solicitud de pago de un vistazo. En este caso, podemos ver que este pago es para la instancia de la red principal de la Lightning Network (`lnbc`), y solicita 2.500 uBTC (microbitcoin), o 25.000.000 satoshis. Esta última poción se denomina parte de datos y utiliza un formato extensible para codificar la información necesaria para completar un pago.

Cada versión de instancia de la Lightning Network (mainnet, testnet, etc.) tiene su propio prefijo legible por humanos (ver <<table1501>>). Esto permite al software cliente y también a los humanos determinar rápidamente si una solicitud de pago puede ser satisfecha por su nodo o no.

[role="pagebreak-before less_space"]
[[table1501]]
.BOLT #11 network prefixes
[options="header"]
|=============================
|Network       |BOLT #11 prefix
|mainnet       |`lnbc`
|testnet       |`lntb`
|simnet/regtest|`lnbcrt`
|=============================


La primera parte del prefijo legible para el ser humano es una expresión _compacta_ del importe de la solicitud de pago. El importe compacto se codifica en dos partes. En primer lugar, se utiliza un número entero como importe _base_. A continuación, le sigue un multiplicador que nos permite especificar distintos incrementos de orden de magnitud compensados por el importe base. Si volvemos a nuestro ejemplo inicial, podemos tomar la parte "2500u" y disminuirla en un factor de 1.000 para utilizar en su lugar "2500m" o (2.500 mBTC).  Como regla general, para conocer el importe de una invoice de un vistazo, tome el factor base y multiplíquelo por el multiplicador.

La lista completa de los multiplicadores definidos actualmente figura en la <<table1502>>.

[[table1502]]
.BOLT #11 amount multipliers
[options="header"]
|==============================================
|Multiplier|Bitcoin unit|Multiplication factor
|`m`|milli|0.001
|`u`|micro|0.000001
|`n`|nano|0.000000001
|`p`|pico|0.000000000001
|==============================================


==== bech32 y el segmento de datos.

Si la parte "ilegible" le resulta familiar, es porque utiliza el mismo esquema de codificación que las direcciones Bitcoin compatibles con SegWit utilizan hoy en día, es decir, bech32. Describir el esquema de codificación bech32 está fuera del alcance de este capítulo. En resumen, es una forma sofisticada de codificar cadenas cortas que tiene muy buenas propiedades de corrección y detección de errores.

La porción de datos puede separarse en tres secciones:

  * La marca de tiempo
  * Cero o más pares clave-valor etiquetados
  * La firma de la invoice completa

La marca de tiempo se expresa en segundos desde el año 1970, o la época de Unix. Esta marca de tiempo permite al remitente calibrar la antigüedad de la invoice y, como veremos más adelante, permite al receptor forzar que una invoice sólo sea válida durante un periodo de tiempo si así lo desea.

Al igual que el formato TLV que conocimos en <<tlv>>, el formato de invoice BOLT #11 utiliza una serie de pares clave-valor extensibles para codificar la información necesaria para satisfacer un pago. Como se utilizan pares clave-valor, es fácil añadir nuevos valores en el futuro si se introduce un nuevo tipo de pago o un requisito/funcionalidad adicional. 

Por último, se incluye una firma que abarca toda la invoice firmada por el destino del pago. Esta firma permite al remitente verificar que la solicitud de pago fue efectivamente creada por el destino del pago. A diferencia de las solicitudes de pago de Bitcoin, que no están firmadas, esto nos permite asegurar que una entidad concreta ha firmado la solicitud de pago. La propia firma se codifica utilizando un ID de recuperación, lo que permite utilizar una firma más compacta que permite la extracción de la clave pública. Al verificar la firma, el ID de recuperación extrae la clave pública y la coteja con la clave pública incluida en la invoice.

===== Campos de invoice etiquetados.

Los campos de invoice etiquetados se codifican en el cuerpo principal de la invoice. Estos campos representan diferentes pares clave-valor que expresan información adicional que puede ayudar a completar el pago o información que es
necesaria para completar el pago. Debido a que se utiliza una ligera variante de bech32, cada uno de estos campos está realmente en el dominio "base 5".

Un campo de etiqueta determinado está formado por tres componentes:

  * El "tipo" del campo (5 bits)
  * La longitud de los datos del campo (10 bits)
  * Los datos propiamente dichos, que tienen una longitud de 5 bytes.

La lista completa de todos los campos etiquetados definidos actualmente se encuentra en la <<table1503>>.

[[table1503]]
.BOLT #11 tagged invoice fields
[options="header"]
|===
|pass:[<span class="keep-together">Field tag</span>]|pass:[<span class="keep-together">Data length</span>]|Usage
|`p`|`52`|The SHA-256 payment hash.
|`s`|`52`|A 256-bit secret that increases the end-to-end privacy of a payment by mitigating probing by intermediate nodes.
|`d`|Variable|The description, a short UTF-8 string of the purpose of the payment.
|`n`|`53`|The public key of the destination node.
|`h`|`52`|A hash that represents a description of the payment itself. This can be used to commit to a description that's over 639 bytes in length.
|`x`|Variable|The expiry time, in seconds, of the payment. The default is 1 hour (3,600) if not specified.
|`c`|Variable|The `min_cltv_expiry` to use for the final hop in the route. The default is 9 if not specified.
|`f`|Variable|A fallback on-chain address to be used to complete the payment if the payment cannot be completed over the Lightning Network.
|`r`|Variable|One or more entries that allow a receiver to give the sender additional ephemeral edges to complete the payment.
|`9`|Variable|A set of 5-bit values that contain the feature bits that are required in order to complete the payment.
|===

Los elementos contenidos en el campo `r` se denominan comúnmente _pistas de enrutamiento_. Permiten al receptor comunicar un conjunto extra de aristas que pueden ayudar al emisor a completar su pago. Las pistas se utilizan normalmente cuando el receptor tiene algunos/todos los canales privados, y desea guiar al remitente hacia esta parte "no mapeada" del gráfico de canales. Una pista de enrutamiento codifica efectivamente la misma información que un mensaje normal `channel_update`.
La actualización está empaquetada en un solo valor con los siguientes campos:

 * La `pubkey` del nodo saliente en la arista (264 bits)
 * El `short_channel_id` de la arista "virtual" (64 bits)
 * La tarifa base (`fee_base_msat`) de la arista (32 bits)
 * La tarifa proporcional (`fee_proportional_millionths`) (32 bits)
 * El delta de expiración de CLTV (`cltv_expiry_delta`) (16 bits)

La parte final del segmento de datos es el conjunto de bits de características que comunican al emisor la funcionalidad necesaria para completar un pago. Por ejemplo, si se añade un nuevo tipo de pago en el futuro que no es compatible con el tipo de pago original, el receptor puede establecer un bit de característica _requerida_ para comunicar que el pagador necesita entender esa característica para completar el pago.

=== Conclusión.

Como hemos visto, las facturas son mucho más que una simple solicitud de un importe. Contienen información crítica sobre _cómo_ realizar el pago, como pistas de enrutamiento, la clave pública del nodo de destino, claves efímeras para aumentar la seguridad, y mucho más.

[[security_and_privacy]]
== Seguridad y privacidad de la Lightning Network.

En este capítulo, veremos algunas de las cuestiones más importantes relacionadas con la seguridad y la privacidad de la Lightning Network. En primer lugar, consideraremos la privacidad, lo que significa, cómo evaluarla y algunas cosas que puedes hacer para proteger tu propia privacidad mientras usas la Lightning Network. Luego exploraremos algunos ataques comunes y técnicas de mitigación. 

=== ¿Por qué es importante la privacidad?.

La propuesta de valor clave de la criptodivisa es el dinero resistente a la censura. Bitcoin ofrece a los participantes la posibilidad de almacenar y transferir su riqueza sin la interferencia de gobiernos, bancos o corporaciones. La Lightning Network continúa esta misión.

A diferencia de las soluciones de escalado triviales como los bancos de Bitcoin con custodia, la Lightning Network pretende escalar Bitcoin sin comprometer la autocustodia, lo que debería conducir a una mayor resistencia a la censura en el ecosistema Bitcoin. Sin embargo, la Lightning Network opera bajo un modelo de seguridad diferente, que introduce nuevos retos de seguridad y privacidad.

=== Definiciones de privacidad.

La pregunta "¿Es Lightning privado?" no tiene una respuesta directa. La privacidad es un tema complejo; a menudo es difícil definir con precisión lo que se entiende por privacidad, sobre todo si no se es un investigador de la privacidad. Afortunadamente, los investigadores de la privacidad utilizan procesos para analizar y evaluar las características de privacidad de los sistemas, ¡y nosotros también podemos utilizarlos! Veamos cómo un investigador de seguridad podría tratar de responder a la pregunta "¿Es privado el rayo?" en dos pasos generales.

En primer lugar, un investigador de la privacidad definiría un _modelo de seguridad_ que especifique lo que un adversario es capaz de hacer y lo que pretende conseguir.
A continuación, describiría las propiedades relevantes del sistema y comprobaría si se ajusta a los requisitos.

=== Proceso para evaluar la seguridad.

Un modelo de seguridad se basa en un conjunto de _supuestos de seguridad_ subyacentes.
En los sistemas criptográficos, estos supuestos suelen centrarse en las propiedades matemáticas de las primitivas criptográficas, como los cifrados, las firmas y las funciones hash.
Los supuestos de seguridad de la Red Relámpago son que las firmas ECDSA, la función hash SHA-256 y otras funciones criptográficas utilizadas en el protocolo se comportan dentro de sus definiciones de seguridad.
Por ejemplo, asumimos que es prácticamente imposible encontrar una preimagen (y una segunda preimagen) de una función hash.
Esto permite a la Lightning Network confiar en el mecanismo HTLC (que utiliza la preimagen de una función hash) para la atomicidad de los pagos multisalto: nadie, excepto el receptor final, puede revelar el secreto del pago y resolver el HTLC.
También asumimos un grado de conectividad en la red, es decir, que los canales de rayos forman un grafo conectado. Por lo tanto, es posible encontrar un camino desde cualquier emisor a cualquier receptor. Por último, suponemos que los mensajes de la red se propagan dentro de ciertos tiempos de espera.

Ahora que hemos identificado algunas de nuestras suposiciones subyacentes, vamos a considerar algunos posibles adversarios.

He aquí algunos modelos posibles de adversarios en la Lightning Network.
Un nodo emisor "honesto pero curioso" puede observar los importes de los pagos, los nodos inmediatamente anteriores y siguientes, y el gráfico de los canales anunciados con sus capacidades.
Un nodo muy bien conectado puede hacer lo mismo pero en mayor medida.
Por ejemplo, consideremos a los desarrolladores de un monedero popular que mantienen un nodo al que sus usuarios se conectan por defecto.
Este nodo sería responsable de enrutar una gran parte de los pagos hacia y desde los usuarios de ese monedero.
¿Qué ocurre si varios nodos están bajo el control de un adversario?
Si dos nodos coludidos se encuentran en la misma ruta de pago, entenderían que están reenviando HTLCs pertenecientes al mismo pago porque los HTLCs tienen el mismo hash de pago.

[NOTE]
====
Los pagos multiparte (ver <<mpp>>) permiten a los usuarios ofuscar sus importes de pago dado su tamaño de división no uniforme.
====

¿Cuáles pueden ser los objetivos de un atacante de Lightning?
La seguridad de la información suele describirse en términos de tres propiedades principales: confidencialidad, integridad y disponibilidad.

Confidencialidad:: La información sólo llega a los destinatarios previstos.
Integridad:: La información no se altera en tránsito.
Disponibilidad: El sistema funciona la mayor parte del tiempo.

Las propiedades importantes de la Red Relámpago se centran principalmente en la confidencialidad y la disponibilidad. Algunas de las propiedades más importantes a proteger son:

* Sólo el remitente y el receptor conocen el importe del pago.
* Nadie puede vincular a remitentes y receptores.
* Un usuario honesto no puede ser bloqueado para enviar y recibir pagos. 

Para cada objetivo de privacidad y modelo de seguridad, existe una determinada probabilidad de que un atacante tenga éxito.
Esta probabilidad depende de varios factores, como el tamaño y la estructura de la red.
En igualdad de condiciones, generalmente es más fácil atacar con éxito una red pequeña que una grande.
Del mismo modo, cuanto más centralizada esté la red, más capaz puede ser un atacante si los nodos "centrales" están bajo su control.
Por supuesto, el término centralización debe definirse con precisión para construir modelos de seguridad en torno a él, y hay muchas definiciones posibles de lo centralizada que está una red.
Por último, como red de pagos, la Lightning Network depende de los estímulos económicos.
El tamaño y la estructura de las fees afectan al algoritmo de enrutamiento y, por tanto, pueden ayudar al atacante reenviando la mayoría de los pagos a través de sus nodos o impedir que esto ocurra.


=== Conjunto de anonimato.

¿Qué significa desanonimizar a alguien?
En términos sencillos, la desanonimización implica vincular alguna acción con la identidad del mundo real de una persona, como su nombre o su dirección física.
En la investigación sobre la privacidad, la noción de desanonimización es más matizada.
En primer lugar, no estamos hablando necesariamente de nombres y direcciones.
Descubrir la dirección IP o el número de teléfono de alguien también puede considerarse una desanonimización.
Un dato que permite relacionar la acción de un usuario con sus acciones anteriores se denomina _identidad_.
En segundo lugar, la desanonimización no es binaria; un usuario no es totalmente anónimo ni está completamente desanonimizado.
En cambio, la investigación sobre la privacidad examina el anonimato en comparación con el conjunto de anonimato.

El _conjunto de anonimato_ es una noción central en la investigación sobre la privacidad.
Se refiere al conjunto de identidades tales que, desde el punto de vista de un atacante, una acción determinada podría corresponder a cualquiera del conjunto.
Consideremos un ejemplo de la vida real.
Imagina que te encuentras con una persona en una calle de la ciudad.
¿Cuál es su conjunto de anonimato desde tu punto de vista?
Si no la conoces personalmente, y sin ninguna información adicional, su conjunto de anonimato equivale aproximadamente a la población de la ciudad, incluidos los viajeros.
Si además tienes en cuenta su aspecto, podrás estimar aproximadamente su edad y excluir del conjunto de anonimato a los residentes de la ciudad que sean obviamente mayores o menores que la persona en cuestión.
Además, si se observa que la persona entra en la oficina de la empresa X utilizando una tarjeta de identificación electrónica, el conjunto de anonimato se reduce al número de empleados y visitantes de la empresa X.
Por último, puede fijarse en el número de matrícula del coche que ha utilizado para llegar al lugar.
Si usted es un observador casual, esto no le aporta mucho.
Sin embargo, si usted es un funcionario municipal y tiene acceso a la base de datos que relaciona los números de matrícula con los nombres, puede reducir el conjunto de anónimos a unas pocas personas: el propietario del coche y los amigos y familiares cercanos que puedan haber tomado prestado el coche.

Este ejemplo ilustra algunos puntos importantes.
En primer lugar, cualquier información puede acercar al adversario a su objetivo.
Puede que no sea necesario reducir el conjunto de anonimato al tamaño de uno.
Por ejemplo, si el adversario planea un ataque de denegación de servicio (DoS) dirigido y puede derribar 100 servidores, el conjunto de anonimato de 100 es suficiente.
En segundo lugar, el adversario puede correlacionar información de diferentes fuentes.
Incluso si una fuga de privacidad parece relativamente benigna, nunca sabemos lo que puede conseguir en combinación con otras fuentes de datos.
Por último, especialmente en entornos criptográficos, el atacante siempre tiene el "último recurso" de una búsqueda por fuerza bruta.
Las primitivas criptográficas están diseñadas para que sea prácticamente imposible adivinar un secreto como la clave privada.
Sin embargo, cada bit de información acerca al adversario a este objetivo y, en algún momento, se vuelve alcanzable.

En términos de Lightning, desanonimizar generalmente significa derivar una correspondencia entre los pagos y los usuarios identificados por los ID de los nodos.
A cada pago se le puede asignar un conjunto de anonimato del emisor y un conjunto de anonimato del receptor.
Lo ideal es que el conjunto de anonimato esté formado por todos los usuarios de la red.
Esto asegura que el atacante no tenga ningún tipo de información.
Sin embargo, la red real filtra información que permite a un atacante acotar la búsqueda.
Cuanto más pequeño sea el conjunto de anonimato, mayor será la probabilidad de éxito de la desanonimización. 

[role="pagebreak-before less_space"]
=== Diferencias entre la Lightning Network y Bitcoin en términos de privacidad.

Si bien es cierto que las transacciones en la red de Bitcoin no asocian las identidades del mundo real con las direcciones de Bitcoin, todas las transacciones se emiten en texto claro y pueden ser analizadas.
Se han creado múltiples empresas para desanonimizar a los usuarios de Bitcoin y otras criptodivisas.

A primera vista, Lightning proporciona mejor privacidad que Bitcoin porque los pagos de Lightning no se difunden a toda la red.
Aunque esto mejora la línea de base de la privacidad, otras propiedades del protocolo Lightning pueden hacer que los pagos anónimos sean más difíciles.
Por ejemplo, los pagos más grandes pueden tener menos opciones de enrutamiento.
Esto puede permitir a un adversario que controle nodos bien capitalizados enrutar la mayoría de los pagos grandes y descubrir los importes de los pagos y probablemente otros detalles. Con el tiempo, a medida que la Lightning Network crezca, esto puede dejar de ser un problema.

Otra diferencia relevante entre Lightning y Bitcoin es que los nodos de Lightning mantienen una identidad permanente, mientras que los de Bitcoin no.
Un usuario sofisticado de Bitcoin puede cambiar fácilmente los nodos utilizados para recibir los datos de la blockchain y difundir las transacciones.
Un usuario de Lightning, por el contrario, envía y recibe pagos a través de los nodos que ha utilizado para abrir sus canales de pago.
Además, el protocolo Lightning asume que los nodos de enrutamiento anuncian su dirección IP además de su ID de nodo.
Esto crea un vínculo permanente entre los ID de los nodos y las direcciones IP, lo que puede ser peligroso, teniendo en cuenta que una dirección IP suele ser un paso intermedio en los ataques de anonimato vinculados a la ubicación física del usuario y, en la mayoría de los casos, a su identidad en el mundo real.
Es posible utilizar Lightning a través de Tor, pero muchos nodos no utilizan esta funcionalidad, como se puede ver en https://1ml.com/statistics[estadísticas recogidas de los anuncios de los nodos].

Un usuario de Lightning, al enviar un pago, tiene a sus vecinos en su conjunto de anonimato.
En concreto, un nodo de enrutamiento sólo conoce los nodos inmediatamente anteriores y siguientes.
El nodo de enrutamiento no sabe si sus vecinos inmediatos en la ruta de pago son el emisor o el receptor final.
Por lo tanto, el conjunto de anonimato de un nodo en Lightning es aproximadamente igual a sus vecinos (véase <<anonymity_set>>).

[[anonymity_set]]
.The anonymity set of Alice and Bob constitutes their neighbors
image::images/mtln_1601.png["The anonymity set of Alice and Bob constitutes their neighbors"]

Una lógica similar se aplica a los receptores de pagos.
Muchos usuarios sólo abren un puñado de canales de pago, lo que limita sus conjuntos de anonimato.
Además, en Lightning, el conjunto de anonimato es estático o, al menos, cambia lentamente.
En cambio, se pueden conseguir conjuntos de anonimato significativamente mayores en las transacciones CoinJoin en la cadena.
Las transacciones CoinJoin con conjuntos de anonimato superiores a 50 son bastante frecuentes.
Normalmente, los conjuntos de anonimato en una transacción CoinJoin corresponden a un conjunto de usuarios que cambia dinámicamente.

Por último, a los usuarios de Lightning también se les puede negar el servicio, bloqueando o agotando sus canales por un atacante.
El envío de pagos requiere que el capital -un recurso escaso- se bloquee temporalmente en los HTLC a lo largo de la ruta.
Un atacante puede enviar muchos pagos pero no finalizarlos, ocupando el capital de los usuarios honestos durante largos periodos.
Este vector de ataque no está presente (o al menos no es tan obvio) en Bitcoin.

En resumen, aunque algunos aspectos de la arquitectura de Lightning Network sugieren que es un paso adelante en términos de privacidad en comparación con Bitcoin, otras propiedades del protocolo pueden facilitar los ataques a la privacidad. Es necesario investigar a fondo para evaluar qué garantías de privacidad ofrece la Lightning Network y mejorar el estado de la cuestión.

Los temas tratados en esta parte del capítulo resumen la investigación disponible a mediados de 2021. Sin embargo, esta área de investigación y desarrollo está creciendo rápidamente. Nos complace informar de que los autores tienen conocimiento de múltiples equipos de investigación que trabajan actualmente en la privacidad de Lightning.

Ahora revisemos algunos de los ataques a la privacidad de LN que se han descrito en la literatura académica.


=== Ataques a Lightning.

Las investigaciones recientes describen varias formas en las que la seguridad y la privacidad de la Lightning Network pueden verse comprometidas. 

==== Observación de los importes de los pagos.

Uno de los objetivos de un sistema de pago que preserve la privacidad es ocultar el importe del pago a las partes no implicadas.
La Lightning Network supone una mejora respecto a la capa 1 en este sentido.
Mientras que las transacciones de Bitcoin se transmiten en texto claro y pueden ser observadas por cualquiera, los pagos de Lightning sólo pasan por unos pocos nodos a lo largo de la ruta de pago.
Sin embargo, los nodos intermediarios sí ven el importe del pago, aunque este importe de pago puede no corresponder al importe total real del pago (véase <<mpp>>).
Esto es necesario para crear un nuevo HTLC en cada salto.
La disponibilidad de los importes de pago para los nodos intermediarios no representa una amenaza inmediata.
Sin embargo, un nodo intermediario _honrado-pero-curioso_ puede utilizarlo como parte de un ataque mayor.


==== Vinculación de emisores y receptores.

Un atacante podría estar interesado en conocer el remitente y/o el receptor de un pago para revelar ciertas relaciones económicas.
Esta violación de la privacidad podría perjudicar la resistencia a la censura, ya que un nodo intermediario podría censurar los pagos hacia o desde ciertos receptores o remitentes.
Idealmente, la vinculación de los remitentes con los receptores no debería ser posible para nadie más que el remitente y el receptor.

En las siguientes secciones, consideraremos dos tipos de adversarios: el adversario fuera de ruta y el adversario en ruta.
Un adversario fuera de la ruta intenta evaluar al remitente y al receptor de un pago sin participar en el proceso de enrutamiento del pago.
Un adversario on-path puede aprovechar cualquier información que pueda obtener al enrutar el pago de interés.

En primer lugar, consideremos al adversario "off-path".
En el primer paso de este escenario de ataque, un potente adversario fuera de la ruta deduce los saldos individuales en cada payment channel a través del sondeo (descrito en una sección posterior) y forma una instantánea de la red en el momento __t~1~__. Para simplificar, hagamos que __t~1~__ sea igual a las 12:05.
A continuación, sondea la red de nuevo en algún momento posterior a la hora __t~2~__, que haremos que sean las 12:10. El atacante compararía entonces las instantáneas de las 12:10 y las 12:05 y utilizaría las diferencias entre las dos instantáneas para inferir información sobre los pagos que tuvieron lugar mirando las rutas que han cambiado.
En el caso más sencillo, si sólo se produjo un pago entre las 12:10 y las 12:05, el adversario observaría una única trayectoria en la que los saldos han cambiado en las mismas cantidades.
Así, el adversario lo sabe casi todo sobre este pago: el remitente, el destinatario y el importe.
Si varias rutas de pago se solapan, el adversario necesita aplicar una heurística para identificar dicho solapamiento y separar los pagos.

Ahora nos centramos en un adversario "en la ruta".
Este tipo de adversario puede parecer complicado.
Sin embargo, en junio de 2020, los investigadores observaron que el único nodo más central https://arxiv.org/pdf/2006.12143.pdf[observaba cerca del 50% de todos los pagos de LN], mientras que los cuatro nodos más centrales https://arxiv.org/pdf/1909.06890.pdf[observaban una media del 72% de los pagos].
Estos resultados subrayan la importancia del modelo de atacante en la ruta.
Aunque los intermediarios de una ruta de pago sólo conocen a su sucesor y a su predecesor, hay varias filtraciones que un intermediario malicioso o honesto pero curioso podría utilizar para inferir el remitente y el receptor.

El adversario en la ruta puede observar el importe de cualquier pago enrutado, así como los deltas de los bloqueos de tiempo (véase "enrutamiento de cebolla").
Por lo tanto, el adversario puede excluir cualquier nodo del conjunto de anonimato del emisor o del receptor con capacidades inferiores a la cantidad enrutada.
Por lo tanto, observamos un equilibrio entre la privacidad y las cantidades de pago.
Normalmente, cuanto mayor es la cantidad de pago, más pequeños son los conjuntos de anonimato.
Observamos que esta fuga podría minimizarse con pagos en varias partes o con canales de pago de gran capacidad.
Del mismo modo, los canales de pago con pequeños deltas de tiempo podrían ser excluidos de una ruta de pago.
Más concretamente, un payment channel no puede pertenecer a un pago si el tiempo restante de bloqueo del pago es mayor que el que el nodo emisor estaría dispuesto a aceptar.
Esta fuga podría desalojarse adhiriéndose a las denominadas rutas en la sombra.

Una de las fugas más sutiles y, sin embargo, poderosas que puede fomentar un adversario en ruta es el análisis de tiempo.
Un adversario on-path puede mantener un registro de cada pago enrutado, junto con la cantidad de tiempo que tarda un nodo en responder a una solicitud HTLC.
Antes de iniciar el ataque, el atacante aprende las características de latencia de cada nodo en la Lightning Network enviándoles peticiones.
Naturalmente, esto puede ayudar a establecer la posición precisa del adversario en la ruta de pago.
Además, como se ha demostrado recientemente, un atacante puede determinar con éxito el remitente y el receptor de un pago a partir de un conjunto de posibles remitentes y receptores utilizando estimadores basados en el tiempo. 

Por último, es importante reconocer que probablemente existan filtraciones desconocidas o no estudiadas que podrían ayudar a los intentos de desanonimización. Por ejemplo, dado que los diferentes monederos Lightning aplican diferentes algoritmos de enrutamiento, incluso conocer el algoritmo de enrutamiento aplicado podría ayudar a excluir a ciertos nodos de ser un remitente y/o receptor de un pago.


==== Revelación de los saldos de los canales (Probing).

Se supone que los saldos de los canales Lightning están ocultos por razones de privacidad y eficiencia.
Un nodo Lightning sólo conoce los saldos de sus canales adyacentes.
El protocolo no proporciona ninguna forma estándar de consultar el balance de un canal remoto.

Sin embargo, un atacante puede revelar el balance de un canal remoto en un _ataque de sondeo_.
En seguridad de la información, el sondeo se refiere a la técnica de enviar peticiones a un sistema objetivo y sacar conclusiones sobre su estado privado basándose en las respuestas recibidas.

Los canales de Lightning son propensos a ser sondeados.
Recordemos que un Lightning payment estándar comienza con la creación por parte del receptor de un secreto de pago aleatorio y el envío de su hash al remitente.
Obsérvese que para los nodos intermediarios, todos los hashes parecen aleatorios.
No hay forma de saber si un hash corresponde a un secreto real o se ha generado aleatoriamente.

El ataque de sondeo procede como sigue.
Supongamos que el atacante Mallory quiere revelar el balance de un canal público entre Alice y Bob.
Supongamos que la capacidad total de ese canal es de 1 millón de satoshis.
El balance de Alice podría ser cualquier cosa desde cero hasta 1 millón de satoshis (para ser precisos, la estimación es un poco más ajustada debido a la reserva del canal, pero no lo tenemos en cuenta aquí por simplicidad).
Mallory abre un canal con Alice con 1 millón de satoshis y envía 500.000 satoshis a Bob a través de Alice utilizando un _número aleatorio_ como hash de pago.
Por supuesto, este número no se corresponde con ningún secreto de pago conocido.
Por lo tanto, el pago fallará.
La pregunta es: ¿cómo fallará exactamente?

Hay dos escenarios.
Si Alice tiene más de 500.000 satoshis en su lado del canal a Bob, reenvía el pago.
Bob descifra la cebolla de pago y se da cuenta de que el pago está destinado a él.
Consulta su almacén local de secretos de pago y busca la preimagen que corresponde al hash del pago, pero no la encuentra.
Siguiendo el protocolo, Bob devuelve el error "hash de pago desconocido" a Alice, que lo transmite a Mallory.
Como resultado, Mallory sabe que el pago _podría haber tenido éxito_ si el hash del pago fuera real.
Por lo tanto, Mallory puede actualizar su estimación del balance de Alice de "entre cero y 1 millón" a "entre 500.000 y 1 millón".
Otro escenario ocurre si el balance de Alice es inferior a 500.000 satoshis.
En ese caso, Alice no puede enviar el pago y devuelve a Mallory el error de "balance insuficiente".
Mallory actualiza su estimación de "entre cero y 1 millón" a "entre cero y 500.000".

Tenga en cuenta que, en cualquier caso, la estimación de Mallory se vuelve dos veces más precisa después de un solo sondeo.
Puede seguir sondeando, eligiendo la siguiente cantidad de sondeo de forma que divida el intervalo de estimación actual por la mitad.
Esta conocida técnica de búsqueda se denomina "búsqueda binaria".
Con la búsqueda binaria, el número de sondeos es _logarítmico_ en la precisión deseada.
Por ejemplo, para obtener el balance de Alice en un canal de 1 millón de satoshis hasta un solo satoshi, Mallory sólo tendría que realizar log~2~ (1.000.000) &asymp; 20 sondeos.
Si un sondeo tarda 3 segundos, ¡un canal puede ser sondeado con precisión en sólo un minuto!

El sondeo de canales puede ser aún más eficaz.
En su variante más sencilla, Mallory se conecta directamente al canal que quiere sondear.
¿Es posible sondear un canal sin abrir un canal a uno de sus extremos?
Imaginemos que Mallory quiere sondear un canal entre Bob y Charlie, pero no quiere abrir otro canal, lo que requiere el pago de tasas en la cadena y la espera de confirmaciones de las transacciones de financiación.
En su lugar, Mallory reutiliza su canal existente con Alice y envía una sonda a lo largo de la ruta Mallory -> Alice -> Bob -> Charlie.
Mallory puede interpretar el error "hash de pago desconocido" de la misma manera que antes: la sonda ha llegado al destino; por lo tanto, todos los canales a lo largo de la ruta tienen saldos suficientes para reenviarla.
Pero, ¿qué ocurre si Mallory recibe el error "balance insuficiente"?
¿Significa que el balance es insuficiente entre Alice y Bob o entre Bob y Charlie?

En el protocolo actual de Lightning, los mensajes de error no sólo informan de _qué_ error se ha producido, sino también de _dónde_ se ha producido.
Así, con un manejo más cuidadoso de los errores, Mallory sabe ahora qué canal ha fallado.
Si éste es el canal de destino, actualiza sus estimaciones; si no, elige otra ruta hacia el canal de destino.
Incluso obtiene información _adicional_ sobre los balances de los canales intermedios, además de la del canal objetivo.

El ataque de sondeo puede utilizarse también para vincular a los emisores y receptores, como se ha descrito en la sección anterior. 

Llegados a este punto, te preguntarás: ¿por qué la Lightning Network hace un trabajo tan pobre a la hora de proteger los datos privados de sus usuarios?
¿No sería mejor no revelar al remitente por qué y dónde ha fallado el pago?
Efectivamente, esta podría ser una posible contramedida, pero tiene importantes inconvenientes.
Lightning tiene que lograr un cuidadoso equilibrio entre privacidad y eficiencia.
Hay que recordar que los nodos normales no conocen las distribuciones de balance en los canales remotos.
Por lo tanto, los pagos pueden fallar (y a menudo lo hacen) debido a un balance insuficiente en un salto intermedio.
Los mensajes de error permiten al remitente excluir el canal que ha fallado para construir otra ruta.
Un popular monedero de Lightning incluso realiza un sondeo interno para comprobar si una ruta construida puede realmente gestionar un pago.

Hay otras posibles contramedidas contra el sondeo de canales.
En primer lugar, es difícil que un atacante se dirija a canales no anunciados.
En segundo lugar, los nodos que implementan el enrutamiento ust-in-time (JIT) pueden ser menos propensos al ataque.
Por último, como los pagos en varias partes hacen que el problema de la capacidad insuficiente sea menos grave, los desarrolladores del protocolo pueden considerar la posibilidad de ocultar algunos de los detalles del error sin perjudicar la eficiencia.

[[denial_of_service]]
==== Denegación de servicio.

Cuando los recursos se ponen a disposición del público, existe el riesgo de que los atacantes intenten hacer que ese recurso no esté disponible ejecutando un ataque de denegación de servicio (DoS).
Por lo general, esto se logra mediante el bombardeo de un recurso por parte del atacante con peticiones que no se distinguen de las consultas legítimas.
Los ataques rara vez provocan pérdidas económicas al objetivo, aparte del coste de oportunidad de la caída de su servicio, y sólo pretenden agraviar al objetivo.

Las mitigaciones típicas de los ataques DoS requieren la autenticación de las solicitudes para separar a los usuarios legítimos de los maliciosos. Estas mitigaciones suponen un coste trivial para los usuarios normales, pero actuarán como elemento disuasorio suficiente para un atacante que lance peticiones a gran escala.
Las medidas contra la denegación de servicio pueden verse en todas partes en Internet: los sitios web aplican límites de velocidad para garantizar que ningún usuario pueda consumir toda la atención de su servidor, los sitios de revisión de películas requieren autenticación de inicio de sesión para mantener a raya a los miembros enfadados de r/prequelmemes (grupo Reddit), y los servicios de datos venden claves de API para limitar el número de consultas.

===== DoS en bitcoin.

En Bitcoin, el ancho de banda que los nodos utilizan para retransmitir las transacciones y el espacio que ponen a disposición de la red en forma de su mempool son recursos disponibles públicamente.
Cualquier nodo de la red puede consumir ancho de banda y espacio de mempool enviando una transacción válida.
Si esta transacción es minada en un bloque válido, pagarán tasas de transacción, lo que añade un coste al uso de estos recursos de red compartidos.

En el pasado, la red Bitcoin se enfrentó a un intento de ataque DoS en el que los atacantes inundaron la red con transacciones de bajo coste.
Muchas de estas transacciones no eran seleccionadas por los mineros debido a sus bajas fees de transacción, por lo que los atacantes podían consumir los recursos de la red sin pagar las fees.
Para solucionar este problema, se estableció una tarifa mínima de retransmisión de transacciones que fijaba un umbral de tarifa que los nodos requerían para propagar las transacciones.
Esta medida garantiza en gran medida que las transacciones que consumen recursos de la red acaben pagando las tasas de su cadena.
La tarifa mínima de retransmisión es aceptable para los usuarios habituales, pero perjudicaría económicamente a los atacantes si intentaran hacer spam en la red.
Aunque algunas transacciones pueden no llegar a convertirse en bloques válidos en entornos con tasas elevadas, estas medidas han sido en gran medida eficaces para disuadir este tipo de spam.

===== DoS en Lightning.

De forma similar a Bitcoin, la Lightning Network cobra tasas por el uso de sus recursos públicos, pero en este caso, los recursos son canales públicos, y las tasas vienen en forma de tasas de enrutamiento.
La capacidad de enrutar los pagos a través de los nodos a cambio de las fees proporciona a la red una gran ventaja de escalabilidad -los nodos que no están conectados directamente pueden seguir realizando transacciones-, pero tiene el coste de exponer un recurso público que debe protegerse contra los ataques DoS.

Cuando un nodo Lightning reenvía un pago en su nombre, utiliza los datos y el ancho de banda del pago para actualizar su commitment transaction, y el importe del pago se reserva en su balance del canal hasta que se liquide o falle.
En los pagos exitosos, esto es aceptable porque el nodo finalmente recibe el pago de sus honorarios.
Los pagos fallidos no incurren en tasas en el protocolo actual.
Esto permite a los nodos encaminar sin coste los pagos fallidos a través de cualquier canal.
Esto es estupendo para los usuarios legítimos, a los que no les gustaría pagar por los intentos fallidos, pero también permite a los atacantes consumir sin coste alguno los recursos de los nodos, de forma parecida a las transacciones de bajo coste en Bitcoin que nunca acaban pagando las tasas de los mineros.

En el momento de escribir este artículo, se está debatiendo en la lista de correo de lightning-dev sobre la mejor manera de resolver este problema. 

===== Ataques DoS conocidos.

Hay dos ataques DoS conocidos en los canales públicos de LN que inutilizan un canal objetivo, o un conjunto de canales objetivo.
Ambos ataques implican el enrutamiento de los pagos a través de un canal público, para luego retenerlos hasta que se agote su tiempo, maximizando así la duración del ataque.
El requisito de fallar los pagos para no pagar tasas es bastante sencillo de cumplir porque los nodos maliciosos pueden simplemente redirigir los pagos hacia ellos mismos.
En ausencia de tasas por pagos fallidos, el único coste para el atacante es el coste en la cadena de abrir un canal para enviar estos pagos, lo que puede ser trivial en entornos con tasas bajas.

==== Commitment Jamming.

Los nodos del rayo actualizan su estado compartido utilizando transacciones de compromiso asimétricas, en las que se añaden y eliminan HTLC para facilitar los pagos.
Cada parte está limitada a un total de https://github.com/lightningnetwork/lightning-rfc/blob/c053ce7afb4cbf88615877a0d5fc7b8dbe2b9ba0/02-peer-protocol.md#the-open_channel-message[483] HTLC en la commitment transaction a la vez.
Un ataque de interferencia de canales permite a un atacante inutilizar un canal dirigiendo 483 pagos a través del canal objetivo y reteniéndolos hasta que se agoten.

Debe tenerse en cuenta que este límite fue elegido en la especificación para asegurar que todos los HTLCs pueden ser barridos en una https://github.com/lightningnetwork/lightning-rfc/blob/master/05-onchain.md#penalty-transaction-weight-calculation[transacción de justicia única].
Aunque este límite _puede_ aumentarse, las transacciones siguen estando limitadas por el tamaño del bloque, por lo que es probable que el número de ranuras disponibles siga siendo limitado.

==== Bloqueo de la liquidez del canal.

Un ataque de bloqueo de liquidez de canal es comparable a un ataque de bloqueo de canal en el sentido de que dirige los pagos a través de un canal y los retiene para que el canal sea inutilizable.
En lugar de bloquear ranuras en el compromiso del canal, este ataque dirige grandes HTLC a través de un canal objetivo, consumiendo todo el ancho de banda disponible del canal.
El compromiso de capital de este ataque es mayor que el ataque de interferencia de compromiso porque el nodo atacante necesita más fondos para enrutar los pagos fallidos a través del objetivo.

=== Desanonimización entre capas.

Las redes informáticas suelen estar divididas en capas.
La estratificación permite separar las preocupaciones y hace que todo el sistema sea manejable.
Nadie podría diseñar un sitio web si tuviera que entender toda la pila TCP/IP hasta la codificación física de los bits en un cable óptico.
Se supone que cada capa debe proporcionar la funcionalidad a la capa superior de forma limpia.
Idealmente, la capa superior debería percibir la capa inferior como una caja negra.
Sin embargo, en la realidad, las implementaciones no son ideales, y los detalles se _filtran_ a la capa superior.
Este es el problema de las abstracciones con fugas.

En el contexto de Lightning, el protocolo LN se basa en el protocolo Bitcoin y en la red LN P2P.
Hasta ahora, sólo hemos considerado las garantías de privacidad que ofrece la Lightning Network de forma aislada.
Sin embargo, la creación y el cierre de los canales de pago se realizan intrínsecamente en la blockchain de Bitcoin.
En consecuencia, para realizar un análisis completo de las disposiciones de privacidad de la Lightning Network, es necesario tener en cuenta todas las capas de la pila tecnológica con las que pueden interactuar los usuarios.
En concreto, un adversario que desanonimice puede utilizar, y lo hará, datos fuera de la cadena y dentro de ella para agrupar o vincular nodos de la LN con las correspondientes direcciones de Bitcoin.

Los atacantes que intentan desanonimizar a los usuarios de LN pueden tener varios objetivos, en un contexto multicapa:

  * Agrupar direcciones Bitcoin propiedad del mismo usuario (Capa 1). Llamamos a estas entidades Bitcoin.
  * Agrupar los nodos LN que pertenecen al mismo usuario (capa 2).
  * Vincular inequívocamente conjuntos de nodos LN a los conjuntos de entidades Bitcoin que los controlan.

Hay varias heurísticas y patrones de uso que permiten a un adversario agrupar direcciones Bitcoin y nodos LN propiedad de los mismos usuarios LN.
Además, estas agrupaciones pueden vincularse a través de las capas utilizando otras potentes heurísticas de vinculación entre capas.
El último tipo de heurística, las técnicas de enlace entre capas, pone de relieve la necesidad de una visión holística de la privacidad. Específicamente, debemos considerar la privacidad en el contexto de ambas capas juntas.


==== Agrupación de entidades de Bitcoin en la cadena.
Las interacciones de la blockchain Lightning Network se reflejan permanentemente en el gráfico de entidades de Bitcoin.
Incluso si un canal está cerrado, un atacante puede observar qué dirección financió el canal y dónde se gastaron las monedas después de cerrarlo.
Para este análisis, consideremos cuatro entidades separadas.
La apertura de un canal provoca un flujo monetario de una _entidad de origen_ a una _entidad de financiación_; el cierre de un canal provoca un flujo de una _entidad de liquidación_ a una _entidad de destino_.

A principios de 2021, https://arxiv.org/pdf/2007.00764.pdf[Romiti et al.] identificaron cuatro heurísticas que permiten agrupar estas entidades.
Dos de ellas capturan ciertos comportamientos de financiación con fugas y dos describen comportamientos de liquidación con fugas. 

Heurística de la estrella (financiación):: Si un componente contiene una entidad de origen que envía fondos a una o más entidades de financiación, es probable que estas entidades de financiación estén controladas por el mismo usuario.
Heurística de la serpiente (financiación):: Si un componente contiene una entidad de origen que reenvía fondos a una o más entidades, que a su vez se utilizan como entidades de origen y de financiación, es probable que todas estas entidades estén controladas por el mismo usuario.
Heurística del recaudador (liquidación):: Si un componente contiene una entidad de destino que recibe fondos de una o más entidades de liquidación, es probable que estas entidades de liquidación estén controladas por el mismo usuario.
Heurística del proxy (liquidación):: Si un componente contiene una entidad de destino que recibe fondos de una o más entidades, que a su vez se utilizan como entidades de liquidación y destino, es probable que estas entidades estén controladas por el mismo usuario.

Cabe señalar que esta heurística puede producir falsos positivos.
Por ejemplo, si las transacciones de varios usuarios no relacionados se combinan en una transacción CoinJoin, entonces la heurística de la estrella o del proxy puede producir falsos positivos.
Esto podría ocurrir si los usuarios están financiando un payment channel desde una transacción CoinJoin.
Otra fuente potencial de falsos positivos podría ser que una entidad representara a varios usuarios si las direcciones agrupadas son controladas por un servicio (por ejemplo, un intercambio) o en nombre de sus usuarios (billetera de custodia).
Sin embargo, estos falsos positivos pueden filtrarse eficazmente.

===== Contramedidas.
Si los resultados de las transacciones de financiación no se reutilizan para abrir otros canales, la heurística de la serpiente no funciona.
Si los usuarios se abstienen de financiar canales desde una única fuente externa y evitan recaudar fondos en una única entidad de destino externa, las otras heurísticas no darían resultados significativos.

==== Agrupación de nodos Lightning fuera de la cadena.
Los nodos LN anuncian alias, por ejemplo, _LNBig.com_.
Los alias pueden mejorar la usabilidad del sistema.
Sin embargo, los usuarios tienden a utilizar alias similares para sus propios nodos diferentes.
Por ejemplo, _LNBig.com Billing_ es probablemente propiedad del mismo usuario que el nodo con alias _LNBig.com_.
Teniendo en cuenta esta observación, se pueden agrupar los nodos LN aplicando sus alias de nodo.
En concreto, se agrupan los nodos LN en una única dirección si sus alias son similares con respecto a alguna métrica de similitud de cadenas.

Otro método para agrupar nodos LN es aplicar sus direcciones IP o Tor.
Si las mismas direcciones IP o Tor corresponden a diferentes nodos LN, es probable que estos nodos estén controlados por el mismo usuario.

===== Contramedidas.
Para una mayor privacidad, los alias deben ser suficientemente diferentes entre sí.
Mientras que el anuncio público de las direcciones IP puede ser inevitable para aquellos nodos que deseen tener canales de entrada en la Lightning Network, la vinculación entre nodos del mismo usuario puede ser mitigada si los clientes de cada nodo están alojados con diferentes proveedores de servicios y, por tanto, direcciones IP.

==== Vinculación entre capas: Nodos Lightning y entidades Bitcoin.
Asociar nodos LN a entidades Bitcoin es una grave violación de la privacidad que se ve agravada por el hecho de que la mayoría de los nodos LN exponen públicamente sus direcciones IP.
Normalmente, una dirección IP puede considerarse como un identificador único de un usuario.
Dos patrones de comportamiento ampliamente observados revelan los vínculos entre los nodos LN y las entidades Bitcoin:

Reutilización de monedas:: Cuando los usuarios cierran los canales de pago, recuperan sus correspondientes monedas. Sin embargo, muchos usuarios reutilizan esas monedas en la apertura de un nuevo canal.
Esas monedas pueden estar efectivamente vinculadas a un nodo LN común.

Reutilización de entidades:: Normalmente, los usuarios financian sus canales de pago desde direcciones Bitcoin correspondientes a la misma entidad Bitcoin.

Estos algoritmos de vinculación entre capas podrían verse frustrados si los usuarios poseen varias direcciones no agrupadas o utilizan varios monederos para interactuar con la Lightning Network.

La posible desanonimización de las entidades Bitcoin ilustra lo importante que es considerar la privacidad de ambas capas simultáneamente en lugar de una a la vez.

//TODO del autor: tal vez aquí deberíamos/podríamos incluir las figuras correspondientes del artículo de Romiti et al. mejoraría mucho y ayudaría a la comprensión de la sección

=== Gráfico de relámpagos.

La Lightning Network, como su nombre indica, es una red peer-to-peer de canales de pago.
Por lo tanto, muchas de sus propiedades (privacidad, robustez, conectividad, eficiencia de enrutamiento) están influenciadas y caracterizadas por su naturaleza de red.

En esta sección, discutimos y analizamos la Lightning Network desde el punto de vista de la ciencia de las redes.
Estamos especialmente interesados en comprender el gráfico del canal de la RL, su robustez, conectividad y otras características importantes. 

==== ¿Cómo se ve el gráfico Lightning en la realidad?.
Cabría esperar que la Red Relámpago fuera un grafo aleatorio, en el que las aristas se forman al azar entre los nodos.
Si este fuera el caso, la distribución de grados de la Red Relámpago seguiría una distribución normal gaussiana.
En concreto, la mayoría de los nodos tendrían aproximadamente el mismo grado, y no esperaríamos nodos con grados extraordinariamente grandes.
Esto se debe a que la distribución normal disminuye exponencialmente para los valores fuera del intervalo alrededor del valor medio de la distribución.
La representación de un gráfico aleatorio (como vimos en <<lngraph>>) se parece a la topología de una red de malla.
Parece descentralizado y no jerárquico: cada nodo parece tener la misma importancia.
Además, los grafos aleatorios tienen un gran diámetro.
En particular, el enrutamiento en estos grafos es un reto porque el camino más corto entre dos nodos cualquiera es moderadamente largo.

En cambio, el grafo LN es completamente diferente.

===== El gráfico Lightning hoy en día.
Lightning es una red financiera.
Por tanto, el crecimiento y la formación de la red también están influidos por los incentivos económicos.
Cuando un nodo se une a la Lightning Network, puede querer maximizar su conectividad con otros nodos para aumentar su eficiencia de enrutamiento. Este fenómeno se denomina adhesión preferente.
Estos incentivos económicos dan lugar a una red fundamentalmente diferente a la de un gráfico aleatorio.

Según las instantáneas de los canales anunciados públicamente, la distribución de grados de la Red del Rayo sigue una función de ley de potencia.
En este gráfico, la gran mayoría de los nodos tienen muy pocas conexiones con otros nodos, mientras que sólo un puñado de nodos tiene numerosas conexiones.
A alto nivel, la topología de este gráfico se asemeja a una estrella: la red tiene un núcleo bien conectado y una periferia poco conectada.
Las redes con una distribución de grados de potencia también se denominan redes sin escala.
Esta topología es ventajosa para enrutar los pagos de forma eficiente, pero es propensa a ciertos ataques basados en la topología.

===== Ataques basados en la topología.

Un adversario podría querer interrumpir la Red Rayo y podría decidir que su objetivo es desmantelar toda la red en muchos componentes más pequeños, haciendo que el enrutamiento de pagos sea prácticamente imposible en toda la red.
Un objetivo menos ambicioso, pero igualmente malicioso y severo, podría ser derribar sólo algunos nodos de la red.
Dicha interrupción podría producirse en el nivel de los nodos o en el de los bordes.

Supongamos que un adversario puede derribar cualquier nodo de la Lightning Network.
Por ejemplo, puede atacarlos con un ataque de denegación de servicio distribuido (DDoS) o hacerlos inoperativos por cualquier medio.
Resulta que si el adversario elige los nodos al azar, las redes sin escala como la Red Relámpago son robustas contra los ataques de eliminación de nodos.
Esto se debe a que un nodo aleatorio se encuentra en la periferia con un pequeño número de conexiones, por lo que juega un papel insignificante en la conectividad de la red.
Sin embargo, si el adversario es más prudente, puede dirigirse a los nodos mejor conectados.
No es de extrañar que la Red Relámpago y otras redes sin escala sean _no_ robustas contra los ataques dirigidos a la eliminación de nodos.

Por otro lado, el adversario podría ser más sigiloso.
Varios ataques basados en la topología tienen como objetivo un único nodo o un único payment channel.
Por ejemplo, un adversario podría estar interesado en agotar la capacidad de un determinado payment channel a propósito.
De forma más general, un adversario puede agotar toda la capacidad de salida de un nodo para derribarlo del mercado de enrutamiento.
Esto podría obtenerse fácilmente enrutando pagos a través del nodo víctima con cantidades iguales a la capacidad de salida de cada payment channel.
Después de completar este llamado ataque de aislamiento del nodo, la víctima no puede enviar o enrutar más pagos a menos que reciba un pago o reequilibre sus canales.

En conclusión, incluso por diseño, es posible eliminar aristas y nodos de la Lightning Network enrutable.
Sin embargo, dependiendo del vector de ataque utilizado, el adversario puede tener que proporcionar más o menos recursos para llevar a cabo el ataque.


===== Temporalidad de la Red Relámpago.

La Red Relámpago es una red sin permisos que cambia dinámicamente.
Los nodos pueden unirse o abandonar libremente la red, y pueden abrir y crear canales de pago en cualquier momento.
Por lo tanto, una única instantánea estática del gráfico de la RL es engañosa. Tenemos que tener en cuenta la temporalidad y la naturaleza siempre cambiante de la red. Por ahora, el gráfico LN está creciendo en términos de número de nodos y canales de pago.
Su diámetro efectivo también se está reduciendo; es decir, los nodos se acercan unos a otros, como podemos ver en <<temporal_ln>>. 

[[temporal_ln]]
.The steady growth of the Lightning Network in nodes, channels, and locked capacity (as of September 2021)
image::images/mtln_1602.png["The steady growth of the Lightning Network in terms of nodes, channels, and locked capacity (as of September 2021)"]

En las redes sociales, el comportamiento de cierre de triángulos es común.
En concreto, en un gráfico en el que los nodos representan a las personas y las amistades se representan como aristas, es de algún modo esperable que surjan triángulos en el gráfico.
Un triángulo, en este caso, representa las amistades por parejas entre tres personas.
Por ejemplo, si Alicia conoce a Bob y Bob conoce a Charlie, es probable que en algún momento Bob presente a Alicia a Charlie.
Sin embargo, este comportamiento sería extraño en la Red Relámpago.
Los nodos simplemente no están incentivados a cerrar triángulos porque podrían simplemente enrutar los pagos en lugar de abrir un nuevo payment channel.
Sorprendentemente, el cierre de triángulos es una práctica común en la Lightning Network.
El número de triángulos crecía constantemente antes de la implementación de los pagos multiparte.
Esto es contraintuitivo y sorprendente, ya que los nodos podrían haber enrutado los pagos a través de los dos lados del triángulo en lugar de abrir el tercer canal.
Esto puede significar que las ineficiencias de enrutamiento incentivaron a los usuarios a cerrar triángulos y no recurrir al enrutamiento.
Es de esperar que los pagos en varias partes ayuden a aumentar la eficacia del enrutamiento de los pagos

=== Centralización en la Lightning Network.

Una métrica común para evaluar la centralidad de un nodo en un gráfico es su _centralidad de punto central_. La dominancia del punto central es una métrica derivada de la centralidad entre nodos, utilizada para evaluar la centralidad de una red.
Para una definición precisa de la dominancia del punto central, se remite al lector a https://doi.org/10.2307/3033543 [trabajo de Freeman].

Cuanto mayor sea el dominio del punto central de una red, más centralizada estará la red.
Podemos observar que la red del rayo tiene una mayor dominancia del punto central (es decir, está más centralizada) que un grafo aleatorio (grafo de Erdős-Rényi) o un grafo sin escala (grafo de Barabási-Albert) de igual tamaño.

En general, nuestra comprensión de la naturaleza dinámica del grafo del canal LN es bastante limitada.
Es fructífero analizar cómo los cambios en el protocolo, como los pagos multiparte, pueden afectar a la dinámica de la Lightning Network.
Sería beneficioso explorar la naturaleza temporal del grafo LN en mayor profundidad.

=== Incentivos económicos y estructura del gráfico.

El gráfico LN se forma espontáneamente, y los nodos se conectan entre sí en función del interés mutuo.
Como resultado, los incentivos impulsan el desarrollo del gráfico.
Veamos algunos de los incentivos relevantes:

  * Incentivos racionales:
    - Los nodos establecen canales para enviar, recibir y enrutar pagos (ganar comisiones).
    - ¿Qué hace que sea más probable que se establezca un canal entre dos nodos que actúan racionalmente?
  * Incentivos altruistas:
    - Los nodos establecen canales "por el bien de la red".
    - Aunque no debemos basar nuestros supuestos de seguridad en el altruismo, hasta cierto punto, el comportamiento altruista impulsa a Bitcoin (aceptar conexiones entrantes, servir bloques).
    - ¿Qué papel juega en Lightning?

En las primeras etapas de la Lightning Network, muchos operadores de nodos han afirmado que las fees de enrutamiento ganadas no compensan los costes de oportunidad derivados del bloqueo de liquidez. Esto indicaría que operar un nodo puede estar impulsado principalmente por incentivos altruistas "por el bien de la red".
Esto podría cambiar en el futuro si la Lightning Network tiene un tráfico significativamente mayor o si surge un mercado de fees de enrutamiento.
Por otro lado, si un nodo desea optimizar sus fees de enrutamiento, minimizaría el promedio de las longitudes de los caminos más cortos hacia todos los demás nodos.
Dicho de otro modo, un nodo que busque beneficios intentará situarse en el _centro_ del gráfico del canal o cerca de él.

=== Consejos prácticos para que los usuarios protejan su privacidad.

Todavía estamos en las primeras etapas de la Red Relámpago.
Es probable que muchas de las preocupaciones enumeradas en este capítulo se aborden a medida que madure y crezca.
Mientras tanto, hay algunas medidas que puedes tomar para proteger tu nodo contra usuarios maliciosos; algo tan simple como actualizar los parámetros por defecto con los que se ejecuta tu nodo puede ayudar mucho a endurecerlo.

=== Canales no anunciados.

Si tiene la intención de utilizar la Lightning Network para enviar y recibir fondos entre nodos y billeteras que controla, y no tiene interés en enrutar los pagos de otros usuarios, no hay necesidad de anunciar sus canales al resto de la red.
Podría abrir un canal entre, por ejemplo, su ordenador de sobremesa que ejecuta un nodo completo y su teléfono móvil que ejecuta un monedero Lightning, y simplemente renunciar al anuncio del canal que se comenta en <<ch03_How_Lightning_Works>>.
A veces se denominan canales "privados"; sin embargo, es más correcto referirse a ellos como canales "no anunciados" porque no son estrictamente privados. 

Los canales no anunciados no serán conocidos por el resto de la red y normalmente no se utilizarán para enrutar los pagos de otros usuarios.
Pueden seguir utilizándose para enrutar pagos si otros nodos los conocen; por ejemplo, una invoice podría contener pistas de enrutamiento que sugieran una ruta con un canal no anunciado.
Sin embargo, asumiendo que sólo has abierto un canal no anunciado contigo mismo, ganas cierta medida de privacidad.
Como no expones tu canal a la red, reduces el riesgo de un ataque de denegación de servicio a tu nodo.
También puedes gestionar más fácilmente la capacidad de este canal, ya que sólo se utilizará para recibir o enviar directamente a tu nodo.

También hay ventajas en abrir un canal no anunciado con una parte conocida con la que se realizan transacciones con frecuencia.
Por ejemplo, si Alicia y Bob juegan frecuentemente al póquer por bitcoin, podrían abrir un canal para enviar sus ganancias de un lado a otro.
En condiciones normales, este canal no se utilizará para encauzar los pagos de otros usuarios ni para cobrar comisiones.
Y como el canal no será conocido por el resto de la red, los pagos entre Alice y Bob no podrán inferirse mediante el seguimiento de los cambios en la capacidad de enrutamiento del canal.
Esto confiere cierta privacidad a Alice y Bob; sin embargo, si uno de ellos decide dar a conocer el canal a otros usuarios, por ejemplo, incluyéndolo en las pistas de enrutamiento de una invoice, esta privacidad se pierde.

También hay que tener en cuenta que para abrir un canal no anunciado, hay que hacer una transacción pública en la blockchain de Bitcoin.
Por lo tanto, es posible inferir la existencia y el tamaño del canal si una parte maliciosa está monitorizando la blockchain en busca de transacciones de apertura de canales e intentando hacerlas coincidir con los canales de la red.
Además, cuando el canal se cierra, el balance final del canal se hará público una vez que se comprometa en el blockchain de Bitcoin.
Sin embargo, dado que las transacciones de apertura y compromiso son seudónimas, no será sencillo relacionarlas con Alice o Bob.
Además, la actualización de Taproot de 2021 hace difícil distinguir entre las transacciones de apertura y cierre de canales y otros tipos específicos de transacciones de Bitcoin.
Por lo tanto, aunque los canales no anunciados no son completamente privados, proporcionan algunos beneficios de privacidad cuando se usan con cuidado.

[[routing_considerations]]
=== Consideraciones sobre el enrutamiento.

Como se ha cubierto en <<denial_of_service>>, los nodos que abren canales públicos se exponen al riesgo de una serie de ataques a sus canales.
Mientras se desarrollan mitigaciones a nivel de protocolo, hay muchos pasos que un nodo puede tomar para protegerse contra ataques de denegación de servicio en sus canales públicos:

Tamaño mínimo de HTLC:: Al abrir el canal, tu nodo puede establecer el tamaño mínimo de HTLC que aceptará.
Establecer un valor más alto asegura que cada una de sus ranuras de canal disponibles no puede ser ocupada por un pago muy pequeño.
Limitación de velocidad:: Muchas implementaciones de nodos permiten a los nodos aceptar o rechazar dinámicamente los HTLC que se reenvían a través de su nodo.
Algunas pautas útiles para un limitador de tasa personalizado son las siguientes:
+
** Limitar el número de ranuras de compromiso que puede consumir un solo peer.
** Monitorizar las tasas de fallo de un solo peer, y limitar la tasa si sus fallos se disparan repentinamente Canales en sombra:: Los nodos que deseen abrir grandes canales hacia un único objetivo pueden abrir un único canal público hacia el objetivo y apoyarlo con más canales privados llamados canales sombra. Estos canales pueden seguir utilizándose para el enrutamiento, pero no se anuncian a los posibles atacantes.

==== Canales de aceptación.
En la actualidad, los nodos de Lightning tienen dificultades para conseguir liquidez de entrada. Aunque hay algunas soluciones de pago para adquirir liquidez entrante, como los servicios de intercambio, los mercados de canales y los servicios de apertura de canales de pago de centros conocidos, muchos nodos aceptarán con gusto cualquier solicitud de apertura de canales de aspecto legítimo para aumentar su liquidez entrante.

Volviendo al contexto de Bitcoin, esto puede compararse con la forma en que Bitcoin Core trata sus conexiones entrantes y salientes de forma diferente por la preocupación de que el nodo pueda ser eclipsado.
Si un nodo abre una conexión entrante a tu nodo Bitcoin, no tienes forma de saber si el iniciador te ha seleccionado al azar o si se dirige específicamente a tu nodo con intenciones maliciosas.
Sus conexiones salientes no necesitan ser tratadas con tal sospecha porque, o bien el nodo fue seleccionado al azar de un grupo de muchos pares potenciales, o bien usted se conectó intencionadamente al nodo manualmente. 

Lo mismo puede decirse en Lightning.
Cuando se abre un canal, se hace con intención, pero cuando una parte remota abre un canal hacia tu nodo, no tienes forma de saber si este canal se utilizará para atacar tu nodo o no.
Como señalan varios artículos, el coste relativamente bajo de poner en marcha un nodo y abrir canales a los objetivos es uno de los factores significativos que facilitan los ataques.
Si aceptas canales entrantes, es prudente poner algunas restricciones en los nodos de los que aceptas canales entrantes.
Muchas implementaciones exponen ganchos de aceptación de canales que le permiten adaptar sus políticas de aceptación de canales a sus preferencias.

La cuestión de aceptar y rechazar canales es filosófica.
¿Qué pasa si acabamos con una Red Relámpago en la que los nuevos nodos no pueden participar porque no pueden abrir ningún canal?
Nuestra sugerencia es que no establezcas una lista exclusiva de "mega-nodos" de los que aceptarás canales, sino que aceptes canales de una manera que se adapte a tu preferencia de riesgo.

Algunas estrategias posibles son

Sin riesgo:: No aceptar ningún canal entrante.
Bajo riesgo:: Acepta canales de un conjunto conocido de nodos con los que ya has tenido canales abiertos con éxito.
Riesgo medio:: Aceptar sólo canales de nodos que hayan estado presentes en el gráfico durante un período más largo y que tengan algunos canales de larga duración.
Riesgo alto:: Aceptar cualquier canal entrante, e implementar las mitigaciones descritas en <<routing_considerations>>.

=== Conclusión.
En resumen, la privacidad y la seguridad son temas complejos y llenos de matices, y aunque muchos investigadores y desarrolladores están buscando mejoras en toda la red, es importante que todos los que participan en la red entiendan lo que pueden hacer para proteger su propia privacidad y aumentar la seguridad a nivel de nodo individual.

=== Referencias y lecturas adicionales.

En este capítulo, hemos utilizado muchas referencias de investigaciones en curso sobre la seguridad de los rayos. Puedes encontrar estos artículos y documentos útiles listados por temas en las siguientes listas.

===== Privacidad y ataques de sondeo.

* Jordi Herrera-Joancomartí et al. https://eprint.iacr.org/2019/328["On the Difficulty of Hiding the Balance of Lightning Network Channels"]. _Asia CCS '19: Proceedings of the 2019 ACM Asia Conference on Computer and Communications Security_ (julio de 2019): 602-612.
* Utz Nisslmueller et al. "Toward Active and Passive Confidentiality Attacks on Cryptocurrency Off-Chain Networks". arXiv preprint, https://arxiv.org/abs/2003.00003[] (2020).
* Sergei Tikhomirov et al. "Probing Channel Balances in the Lightning Network", arXiv preprint, https://arxiv.org/abs/2004.00333[] (2020).
* George Kappos et al. "An Empirical Analysis of Privacy in the Lightning Network", arXiv preprint, https://arxiv.org/abs/2003.12470[] (2021).
* https://github.com/LN-Zap/zap-desktop/blob/v0.7.2-beta/services/grpc/router.methods.js[Código fuente de Zap con la función de sondeo].

===== Ataques de congestión.

* Ayelet Mizrahi y Aviv Zohar. "Congestion Attacks in Payment Channel Networks", arXiv preprint, https://arxiv.org/abs/2002.06564[] (2020).

===== Consideraciones sobre el enrutamiento.

* Marty Bent, entrevista con Joost Jager, _Tales from the Crypt_, audio del podcast, 2 de octubre de 2020, https://anchor.fm/tales-from-the-crypt/episodes/197-Joost-Jager-ekghn6[].

[[conclusion_chapter]]
== Conclusión.

En pocos años, la Lightning Network ha pasado de ser un libro blanco a una red global de rápido crecimiento. Como segunda capa de Bitcoin, ha cumplido la promesa de pagos rápidos, baratos y privados. Además, ha iniciado un tsunami de innovación, ya que libera a los desarrolladores de las limitaciones de consenso que existen en el desarrollo de Bitcoin.

La innovación en la Lightning Network se produce en varios niveles diferentes:

* En el protocolo Core de Bitcoin, proporcionando el uso y la demanda de nuevos opcodes de Bitcoin Script, algoritmos de firma y optimizaciones.
* A nivel del protocolo Lightning, con nuevas características desplegadas rápidamente en toda la red
* En el nivel de los canales de pago, con nuevas construcciones y mejoras de los canales
* Como características opcionales distintas desplegadas de extremo a extremo por implementaciones independientes que los remitentes y destinatarios pueden utilizar si lo desean
* Con nuevas e interesantes aplicaciones Lightning (LApps) construidas sobre los clientes y protocolos

Veamos cómo estas innovaciones están cambiando Lightning ahora y en un futuro próximo. 

=== Innovación descentralizada y asíncrona.

Lightning no está sujeto a un consenso cerrado, como es el caso de Bitcoin. Esto significa que diferentes clientes de Lightning pueden implementar diferentes características y negociar sus interacciones (ver <<feature_bits>>). Como resultado, la innovación en la Lightning Network se produce a un ritmo mucho más rápido que en Bitcoin.

Lightning no sólo está avanzando rápidamente, sino que está creando una demanda de nuevas características en el sistema Bitcoin. Muchas innovaciones recientes y previstas en Bitcoin están motivadas y justificadas por su uso en la Lightning Network. De hecho, la Lightning Network se menciona a menudo como un caso de uso de ejemplo para muchas de las nuevas características.

[[bitcoin_prot_17]]
==== Protocolo de Bitcoin e innovación en los scripts de Bitcoin.

El sistema Bitcoin es, por necesidad, un sistema conservador que tiene que preservar la compatibilidad con las reglas de consenso para evitar bifurcaciones no planificadas del blockchain o particiones de la red P2P. Como resultado, las nuevas características requieren mucha coordinación y pruebas antes de ser implementadas en la mainnet, el sistema de producción en vivo.

Estas son algunas de las innovaciones actuales o propuestas en Bitcoin que están motivadas por casos de uso en la Lightning Network:

Neutrino:: Un protocolo de cliente ligero con características de privacidad mejoradas respecto al protocolo SPV heredado. Neutrino es utilizado principalmente por los clientes de Lightning para acceder a la blockchain de Bitcoin.

Firmas Schnorr:: Introducidas como parte de la soft fork _Taproot_, las firmas Schnorr permitirán contratos flexibles de tiempo bloqueado (PTLC) para la construcción de canales en Lightning. Esto podría, en particular, hacer uso de firmas revocables en lugar de transacciones revocables.

Taproot:: También parte de la soft fork de noviembre de 2021 que introduce las firmas Schnorr, Taproot permite que las escrituras complejas aparezcan como pagos de un solo pagador y un solo beneficiario, e indistinguibles del tipo de pago más común en Bitcoin. Esto permitirá que las transacciones de cierre cooperativo (mutuo) del canal Lightning aparezcan indistinguibles de los pagos simples y aumentará la privacidad de los usuarios de LN.

Reencuadre de entrada:: También conocido por los nombres SIGHAS_NOINPUT o SIGHASH_ANYPREVOUT, esta actualización prevista del lenguaje Bitcoin Script está motivada principalmente por los contratos inteligentes avanzados, como el protocolo del canal eltoo.

Contratos:: Actualmente en las primeras etapas de investigación, los pactos permiten a las transacciones crear salidas que restringen las futuras transacciones que las gastan. Este mecanismo podría aumentar la seguridad de los canales Lightning al hacer posible la aplicación de listas blancas de direcciones en las transacciones de compromiso.

==== Innovación del protocolo Lightning.

El protocolo P2P de Lightning es altamente extensible y ha sufrido muchos cambios desde su creación. La regla "It's OK to be odd" utilizada en los bits de características (véase <<feature_bits>>) garantiza que los nodos puedan negociar las características que soportan, permitiendo múltiples actualizaciones independientes del protocolo.

==== Extensibilidad TLV.

El mecanismo Type-Length-Value (ver <<tlv>>) para extender el protocolo de mensajería es extremadamente potente y ya ha permitido la introducción de varias capacidades nuevas en Lightning manteniendo la compatibilidad hacia delante y hacia atrás.
Un ejemplo destacado, que se está desarrollando actualmente y que hace uso de esto, es el cegamiento de rutas y los pagos de trampolín. Esto permite a un destinatario ocultarse del remitente, pero también permite a los clientes móviles enviar pagos sin necesidad de almacenar el gráfico completo del canal en sus dispositivos, utilizando un tercero al que no necesitan revelar el destinatario final.

==== Construcción de canales de pago.

Los canales de pago son una abstracción que es operada por dos socios del canal. Siempre que esos dos estén dispuestos a ejecutar código nuevo, pueden implementar una variedad de mecanismos de canales simultáneamente. De hecho, investigaciones recientes sugieren que los canales podrían incluso actualizarse a un nuevo mecanismo de forma dinámica, sin necesidad de cerrar el viejo canal y abrir un nuevo tipo de canal.

eltoo:: Una propuesta de mecanismo de canal que utiliza la vinculación de entrada para simplificar significativamente el funcionamiento de los canales de pago y eliminar la necesidad del mecanismo de penalización. Necesita un nuevo tipo de firma de Bitcoin antes de poder ser implementado 

==== Opt-In Características de extremo a extremo.

Contratos puntuales con bloqueo de tiempo:: Un enfoque diferente a los HTLC, los PTLC pueden aumentar la privacidad, reducir la información filtrada a los nodos intermediarios, y operar más eficientemente que los canales basados en HTLC.

Canales grandes:: Los canales grandes o _Wumbo_ se introdujeron de forma dinámica en la red sin necesidad de coordinación. Los canales que admiten grandes pagos se anuncian como parte de los mensajes de anuncio del canal y pueden utilizarse de forma opcional.

Pagos multiparte (MPP):: El MPP también se introdujo de manera optativa, pero aún mejor, sólo requiere que el remitente y el destinatario de un pago puedan hacer MPP. El resto de la red simplemente enruta los HTLC como si fueran pagos de una sola parte.

Enrutamiento JIT:: Es un método opcional que pueden utilizar los nodos de enrutamiento para aumentar su fiabilidad y protegerse del spam.

Keysend:: Una mejora introducida de forma independiente por las implementaciones de clientes de Lightning, permite al remitente enviar dinero de forma "no solicitada" y asíncrona sin requerir una invoice previamente.

Facturas HODLnota: [La palabra _HODL_ proviene de un error ortográfico de la palabra "HOLD" gritado en un foro para animar a la gente a no vender bitcoin en un momento de pánico]:: Pagos en los que el HTLC final no se cobra, comprometiendo al remitente con el pago, pero permitiendo al destinatario retrasar el cobro hasta que se cumpla alguna otra condición, o cancelar la invoice sin cobrarla. Esto también fue implementado de forma independiente por diferentes clientes de Lightning y puede ser utilizado de forma opcional.

Servicios de mensajes enrutados en cebolla:: El mecanismo de enrutamiento de cebolla y la base de datos de clave pública subyacente de los nodos pueden utilizarse para enviar datos que no están relacionados con los pagos, como mensajes de texto o publicaciones en foros. El uso de Lightning para habilitar la mensajería de pago como solución a los mensajes no deseados y a los ataques Sybil (spam) es otra innovación que se implementó independientemente del protocolo principal.

Ofertas:: Actualmente propuesto como BOLT #12 pero ya implementado por algunos nodos, es un protocolo de comunicación para solicitar facturas (recurrentes) a nodos remotos a través de mensajes Onion.

[[lapps]]
=== Aplicaciones Lightning (LApps).

Aunque todavía están en pañales, ya estamos viendo la aparición de interesantes aplicaciones Lightning. Definidas ampliamente como una aplicación que utiliza el protocolo Lightning o un cliente Lightning como componente, las LApps son la capa de aplicación de Lightning. 
Un ejemplo destacado es LNURL, que proporciona una funcionalidad similar a la de las ofertas BOLT #12, pero sobre HTTP y direcciones Lightning. Funciona sobre las ofertas para proporcionar a los usuarios una dirección de correo electrónico a la que otros pueden enviar fondos mientras el software en segundo plano solicita una invoice contra el punto final LNURL del nodo.
Se están construyendo más LApps para juegos sencillos, aplicaciones de mensajería, microservicios, APIs de pago, dispensadores de pago (por ejemplo, surtidores de combustible), sistemas de comercio de derivados, y mucho más.

=== ¡Preparados, listos, ya!.

El futuro parece brillante. La Lightning Network está llevando a Bitcoin a nuevos mercados y aplicaciones inexploradas. Equipado con los conocimientos de este libro, puede explorar esta nueva frontera o incluso unirse como pionero y forjar un nuevo camino.

[appendix]
[[bitcoin_fundamentals_review]]
== Revisión de los fundamentos de Bitcoin.

La Lightning Network es capaz de funcionar por encima de múltiples blockchains, pero está principalmente anclada en Bitcoin. Para entender la Red Relámpago, necesitas una comprensión fundamental de Bitcoin y sus bloques de construcción.

Hay muchos buenos recursos que puede utilizar para aprender más sobre Bitcoin, incluyendo el libro complementario _Mastering Bitcoin_, 2ª Edición, por Andreas M. Antonopoulos, que puede encontrar en GitHub bajo https://github.com/bitcoinbook/bitcoinbook [una licencia de código abierto]. Sin embargo, ¡no es necesario que lea otro libro completo para estar preparado para este!

En este capítulo, hemos recopilado los conceptos más importantes que necesita saber sobre Bitcoin y los hemos explicado en el contexto de la Lightning Network. De este modo, podrá aprender exactamente lo que necesita saber para comprender la Lightning Network sin ninguna distracción.

Este capítulo cubre varios conceptos importantes de Bitcoin, incluyendo:

* Claves y firmas digitales
* Funciones Hash
* Transacciones de Bitcoin y su estructura
* Encadenamiento de transacciones de Bitcoin
* Puntos de salida de las transacciones
* Script de Bitcoin: scripts de bloqueo y desbloqueo
* Scripts de bloqueo básicos
* Scripts de bloqueo complejos y condicionales
* Timelocks 

=== Claves y firmas digitales.

Es posible que hayas oído que bitcoin se basa en la _criptografía_, que es una rama de las matemáticas muy utilizada en la seguridad informática. La criptografía también puede utilizarse para demostrar el conocimiento de un secreto sin revelarlo (firma digital), o para probar la autenticidad de los datos (huella digital). Estos tipos de pruebas criptográficas son las herramientas matemáticas fundamentales para Bitcoin y se utilizan ampliamente en las aplicaciones de Bitcoin.

La propiedad de Bitcoin se establece a través de _claves digitales_, _direcciones Bitcoin_ y _firmas digitales_. Las claves digitales no se almacenan realmente en la red, sino que son creadas y almacenadas por los usuarios en un archivo, o simple base de datos, llamado _wallet_. Las claves digitales en el monedero de un usuario son completamente independientes del Protocolo Bitcoin y pueden ser generadas y gestionadas por el software del monedero del usuario sin referencia a la blockchain o acceso a Internet.

La mayoría de las transacciones de Bitcoin requieren una firma digital válida para ser incluida en la blockchain, que sólo puede ser generada con una clave secreta; por lo tanto, cualquiera que tenga una copia de esa clave tiene el control del bitcoin.  La firma digital utilizada para gastar fondos también se denomina _testigo_, un término utilizado en criptografía. Los datos del testigo en una transacción de bitcoin atestiguan la verdadera propiedad de los fondos que se gastan. Las claves vienen en pares que consisten en una clave privada (secreta) y una clave pública. Piensa que la clave pública es similar a un número de cuenta bancaria y que la clave privada es similar al PIN secreto.

==== Claves privadas y públicas.

Una clave privada es simplemente un número, elegido al azar. En la práctica, y para facilitar la gestión de muchas claves, la mayoría de los monederos Bitcoin generan una secuencia de claves privadas a partir de una única _semilla_ aleatoria utilizando un algoritmo de derivación determinista. En pocas palabras, se utiliza un único número aleatorio para producir una secuencia repetible de números aparentemente aleatorios que se utilizan como claves privadas. Esto permite que los usuarios sólo hagan una copia de seguridad de la semilla y puedan _derivar_ todas las claves que necesiten a partir de esa semilla.

Función unidireccional. En pocas palabras, la naturaleza de las matemáticas de la curva elíptica hace que sea trivial calcular la multiplicación escalar de un punto, pero imposible calcular la inversa (división o logaritmo discreto).

Cada clave privada tiene su correspondiente _clave pública_, que se calcula a partir de la clave privada, utilizando la multiplicación escalar en la curva elíptica. En términos sencillos, con una clave privada _k_, podemos multiplicarla por una constante _G_ para producir una clave pública _K_:

++++
<ul class="simplelist">
<li><em>K</em> = <em>k</em>*<em>G</em></li>
</ul>
++++

It is impossible to reverse this calculation. Given a public key _K_, one cannot calculate the private key _k_. Division by _G_ is not possible in elliptic curve math. Instead, one would have to try all possible values of _k_ in an exhaustive process called a _brute-force attack_. Because _k_ is a 256-bit number, exhausting all possible values with any classical computer would require more time and energy than available in this universe.

==== Hashes.

Another important tool used extensively in Bitcoin, and in the Lightning Network, are _cryptographic hash functions_, and specifically the SHA-256 hash function.

A hash function, also known as a _digest function_, is a function that takes arbitrary length data and transforms it into a fixed length result, called the _hash_, _digest_, or _fingerprint_ (see <<SHA256>>). Importantly, hash functions are _one-way_ functions, meaning that you can't reverse them and calculate the input data from the fingerprint.

[[SHA256]]
.The SHA-256 cryptographic hash algorithm
image::images/mtln_aa01.png["The SHA-256 cryptographic hash algorithm"]

[role="pagebreak-before"]
For example, if we use a command-line terminal to feed the text "Mastering the Lightning Network" into the SHA-256 function, it will produce a fingerprint as follows:

----
$ echo -n "Mastering the Lightning Network" | shasum -a 256

ce86e4cd423d80d054b387aca23c02f5fc53b14be4f8d3ef14c089422b2235de  -
----

[TIP]
====
The input used to calculate a hash is also called a _preimage_.
====

La longitud de la entrada puede ser mucho mayor, por supuesto. Intentemos lo mismo con el https://bitcoin.org/bitcoin.pdf[archivo PDF del whitepaper de Bitcoin] de Satoshi Nakamoto:

----
$ wget http://bitcoin.org/bitcoin.pdf
$ cat bitcoin.pdf | shasum -a 256
b1674191a88ec5cdd733e4240a81803105dc412d6c6708d53ab94fc248f4f553  -
----

Aunque tarda más que una sola frase, la función SHA-256 procesa el PDF de 9 páginas, "digiriéndolo" en una huella digital de 256 bits.

Llegados a este punto, te preguntarás cómo es posible que una función que digiere datos de tamaño ilimitado produzca una huella digital única que es un número de tamaño fijo.

En teoría, dado que hay un número infinito de posibles preimágenes (entradas) y sólo un número finito de huellas digitales, debe haber muchas preimágenes que produzcan la misma huella digital de 256 bits. Cuando dos preimágenes producen el mismo hash, esto se conoce como una _colisión_. 

En la práctica, un número de 256 bits es tan grande que nunca se encontrará una colisión a propósito. Las funciones hash criptográficas funcionan sobre la base de que la búsqueda de una colisión es un esfuerzo de fuerza bruta que requiere tanta energía y tiempo que no es posible en la práctica.

Las funciones hash criptográficas se utilizan ampliamente en una variedad de aplicaciones porque tienen algunas características útiles. Estas son

Deterministas:: La misma entrada siempre produce el mismo hash.

Irreversible: No es posible calcular la preimagen de un hash.

A prueba de colisiones:: Es computacionalmente inviable encontrar dos mensajes que tengan el mismo hash.

Sin correlación:: Un pequeño cambio en la entrada produce un cambio tan grande en la salida que ésta parece no estar relacionada con la entrada.

Uniforme/aleatorio:: Una función de hash criptográfica produce hashes que se distribuyen uniformemente en todo el espacio de 256 bits de posibles resultados. La salida de un hash parece ser aleatoria, aunque no es realmente aleatoria.

Utilizando estas características de los hash criptográficos, podemos construir algunas aplicaciones interesantes:

Huellas dactilares:: Un hash puede utilizarse para tomar una huella digital de un archivo o mensaje, de modo que pueda identificarse de forma única. Los hash pueden utilizarse como identificadores universales de cualquier conjunto de datos.

Prueba de integridad:: Una huella digital de un archivo o mensaje demuestra su integridad porque el archivo o mensaje no puede ser manipulado o modificado de ninguna manera sin cambiar la huella digital. Suele utilizarse para garantizar que el software no ha sido manipulado antes de instalarlo en el ordenador.

Compromiso/no repudio:: Puedes comprometerte con una preimagen específica (por ejemplo, un número o un mensaje) sin revelarla publicando su hash. Más tarde, puedes revelar el secreto, y todo el mundo puede verificar que es lo mismo que te comprometiste antes porque produce el hash publicado.

Prueba de trabajo/rectificación de hash:: Puedes usar un hash para demostrar que has hecho un trabajo computacional mostrando un patrón no aleatorio en el hash que sólo puede ser producido por repetidas conjeturas de una imagen previa. Por ejemplo, el hash de la cabecera de un bloque de Bitcoin comienza con un montón de bits cero. La única forma de producirlo es cambiando una parte de la cabecera y haciendo un hash trillones de veces hasta que produzca ese patrón por azar.

Atomicidad:: Se puede hacer de una preimagen secreta un requisito para gastar fondos en varias transacciones vinculadas. Si una de las partes revela la imagen previa para gastar una de las transacciones, todas las demás partes pueden gastar también sus transacciones. Todos o ninguno se pueden gastar, logrando la atomicidad a través de varias transacciones.

==== Firmas digitales.

La clave privada se utiliza para crear firmas que se requieren para gastar bitcoin demostrando la propiedad de los fondos utilizados en una transacción.

Una _firma digital_ es un número que se calcula a partir de la aplicación de la clave privada a un mensaje específico.

Dado un mensaje _m_ y una clave privada _k_, una función de firma __F~sign~__ puede producir una firma _S_:

[latexmath]
++++
$ S = F_{sign}(m, k) $
++++

Esta firma _S_ puede ser verificada independientemente por cualquiera que tenga la clave pública _K_ (correspondiente a la clave privada _k_), y el mensaje:

[latexmath]
++++
$ F_{verify}(m, K, S) $
++++

Si __F~verify~__ devuelve un resultado verdadero, entonces el verificador puede confirmar que el mensaje _m_ fue firmado por alguien que tuvo acceso a la clave privada _k_. Es importante destacar que la firma digital demuestra la posesión de la clave privada _k_ en el momento de la firma, sin revelar _k_.

Las firmas digitales utilizan un algoritmo hash criptográfico. La firma se aplica a un hash del mensaje, de modo que el mensaje _m_ se "resume" en un hash de longitud fija _H_(_m_) que sirve de huella digital.

Al aplicar la firma digital sobre el hash de una transacción, la firma no sólo demuestra la autorización, sino que también "bloquea" los datos de la transacción, garantizando su integridad. Una transacción firmada no puede ser modificada porque cualquier cambio daría lugar a un hash diferente e invalidaría la firma. 

==== Tipos de firma.

Las firmas no siempre se aplican a toda la transacción. Para proporcionar flexibilidad de firma, una firma digital de Bitcoin contiene un prefijo llamado tipo de hash de firma, que especifica qué parte de los datos de la transacción se incluye en el hash. Esto permite a la firma comprometer o "bloquear" todos o sólo algunos de los datos de la transacción. El tipo de hash de firma más común es +SIGHASH_ALL+ que bloquea todo en la transacción al incluir todos los datos de la transacción en el hash que se firma. En comparación, +SIGHASH_SINGLE+ bloquea todas las entradas de la transacción, pero sólo una salida (más sobre entradas y salidas en la siguiente sección). Se pueden combinar diferentes tipos de hash de firma para producir seis "patrones" diferentes de datos de transacción que son bloqueados por la firma.

Puede encontrar más información sobre los tipos de hash de firma en https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch06.asciidoc#sighash_types[la sección "Tipos de Hash de Firma" en el Capítulo 6 de _Mastering Bitcoin_, Segunda Edición].

=== Transacciones de Bitcoin.

Las _Transacciones_ son estructuras de datos que codifican la transferencia de valor entre los participantes en el sistema bitcoin.

[[utxo]]
==== Entradas y salidas.

Las _entradas_ de las transacciones son simplemente referencias a las salidas de las transacciones previamente registradas. De esta manera, cada transacción gasta las salidas de las transacciones anteriores y crea nuevas salidas (ver <<transaction_structure>>).

[[transaction_structure]]
.A transaction transfers value from inputs to outputs
image::images/mtln_aa02.png["transaction inputs and outputs"]

Los nodos completos de Bitcoin hacen un seguimiento de todas las salidas disponibles y gastables, conocidas como _salidas de transacciones no gastadas_ (UTXOs). La colección de todos los UTXOs se conoce como el conjunto de UTXOs, que actualmente asciende a millones de UTXOs. El conjunto de UTXOs crece cuando se crean nuevos UTXOs y se reduce cuando se consumen UTXOs. Cada transacción representa un cambio (transición de estado) en el conjunto de UTXO, consumiendo uno o más UTXOs como _entradas de transacción_ y creando uno o más UTXOs como sus _salidas de transacción_.

Por ejemplo, supongamos que un usuario Alice tiene un UTXO de 100.000 satoshi que puede gastar. Alice puede pagar a Bob 100.000 satoshi construyendo una transacción con una entrada (consumiendo su entrada existente de 100.000 satoshi) y una salida que "paga" a Bob 100.000 satoshi. Ahora Bob tiene un UTXO de 100.000 satoshi que puede gastar, creando una nueva transacción que consume este nuevo UTXO y lo gasta en otro UTXO como pago a otro usuario, y así sucesivamente (ver <<alice_100ksat_to_bob>>).

[[alice_100ksat_to_bob]]
.Alice pays 100,000 satoshis to Bob
image::images/mtln_aa03.png["Alice pays 100,000 satoshis to Bob"]

La salida de una transacción puede tener un valor arbitrario (entero) denominado en satoshis. Al igual que los dólares pueden dividirse con dos decimales en centavos, el bitcoin puede dividirse con ocho decimales en satoshis. Aunque una salida puede tener cualquier valor arbitrario, una vez creada es indivisible. Esta es una característica importante de las salidas que hay que destacar: las salidas son unidades de valor discretas e indivisibles, denominadas en satoshis enteros. Un output no gastado sólo puede ser consumido en su totalidad por una transacción.

Entonces, ¿qué pasa si Alice quiere pagar a Bob 50.000 satoshi, pero sólo tiene un UTXO indivisible de 100.000 satoshi? Alice necesitará crear una transacción que consuma (como entrada) los 100.000 satoshi UTXO y tenga dos salidas: una pagando 50.000 satoshi a Bob y otra pagando 50.000 satoshi _de vuelta_ a Alice como "cambio" (ver <<alice_50ksat_to_bob_change>>).

[[alice_50ksat_to_bob_change]]
.Alice pays 50k sat to Bob and 50k sat to herself as change
image::images/mtln_aa04.png["Alice pays 50,000 satoshis to Bob and 50,000 satoshis to herself as change"]

[TIP]
====
No hay nada especial en una salida de cambio ni ninguna forma de distinguirla de cualquier otra salida. No tiene por qué ser la última salida. Puede haber más de una salida de cambio, o ninguna salida de cambio. Sólo el creador de la transacción sabe qué salidas son para otros y qué salidas son para las direcciones que le pertenecen y, por tanto, "cambian".
====

De forma similar, si Alicia quiere pagar a Bob 85.000 satoshi pero tiene dos UTXOs de 50.000 satoshi disponibles, tiene que crear una transacción con dos entradas (consumiendo sus dos UTXOs de 50.000 satoshi) y dos salidas, pagando a Bob 85.000 y enviando 15.000 satoshi de vuelta a ella misma como cambio (ver <<tx_twoin_twoout>>).

[[tx_twoin_twoout]]
.Alice uses two 50k inputs to pay 85k sat to Bob and 15k sat to herself as change
image::images/mtln_aa05.png["Alice uses two 50k inputs to pay 85k sat to Bob and 15k sat to herself as change"]

Las ilustraciones y ejemplos anteriores muestran cómo una transacción de Bitcoin combina (gasta) una o más entradas y crea una o más salidas. Una transacción puede tener cientos o incluso miles de entradas y salidas. 

[TIP]
====
Si bien las transacciones creadas por la Red Relámpago tienen múltiples salidas, no tienen "cambio" per se, porque todo el balance disponible de un canal se divide entre los dos socios del canal.
====

==== Cadenas de transacciones.

Cada salida puede gastarse como entrada en una transacción posterior. Así, por ejemplo, si Bob decidiera gastar 10.000 satoshi en una transacción pagando a Chan, y Chan gastara 4.000 satoshi para pagar a Dina, se desarrollaría como se muestra en <<tx_chain>>.

Una salida se considera _gastada_ si es referenciada como entrada en otra transacción que se registra en la blockchain. Una salida se considera _no gastada_ (y disponible para gastar) si ninguna transacción registrada hace referencia a ella.

El único tipo de transacción que no tiene entradas es una transacción especial creada por los mineros de Bitcoin llamada _transacción coinbase_. La transacción coinbase sólo tiene salidas y no entradas porque crea nuevos bitcoin a partir de la minería. Cualquier otra transacción gasta una o más salidas previamente registradas como sus entradas.

Como las transacciones están encadenadas, si eliges una transacción al azar, puedes seguir cualquiera de sus entradas hacia atrás hasta la transacción anterior que la creó. Si sigues haciendo eso, eventualmente llegarás a una transacción de Coinbase donde el bitcoin fue minado por primera vez.

[[tx_chain]]
.Alice paga a Bob que paga a Chan que paga a Dina
image::images/mtln_aa06.png["Alice pays Bob who pays Chan who pays Dina"]


==== TxID: Transaction Identifiers.

Every transaction in the Bitcoin system is identified by a unique identifier (assuming the existence of BIP-0030), called the _transaction ID_ or _TxID_ for short. To produce a unique identifier, we use the SHA-256 cryptographic hash function to produce a hash of the transaction's data. This "fingerprint" serves as a universal identifier. A transaction can be referenced by its transaction ID, and once a transaction is recorded on the Bitcoin blockchain, every node in the Bitcoin network knows that this transaction is valid.

Por ejemplo, un ID de transacción puede tener este aspecto:

.A transaction ID produced from hashing the transaction data
----
e31e4e214c3f436937c74b8663b3ca58f7ad5b3fce7783eb84fd9a5ee5b9a54c
----

This is a real transaction (created as an example for the _Mastering Bitcoin_ book) that can be found on the Bitcoin blockchain. Try to find it by entering this TxID into a block explorer:

++++
<ul class="simplelist">
<li><a href="https://blockstream.info/tx/e31e4e214c3f436937c74b8663b3ca58f7ad5b3fce7783eb84fd9a5ee5b9a54c"><em>https://blockstream.info/tx/e31e4e214c3f436937c74b8663b3ca58f7ad5b3fce7783eb84fd9a5ee5b9a54c</em></a></li></ul>
++++

or use the short link (case-sensitive):

++++
<ul class="simplelist">
<li><a href="http://bit.ly/AliceTx"><em>http://bit.ly/AliceTx</em></a></li>
</ul>
++++

==== Outpoints: Output Identifiers.

Because every transaction has a unique ID, we can also identify a transaction output within that transaction uniquely by reference to the TxID and the output index number. The first output in a transaction is output index 0, the second output is output index 1, and so on. An output identifier is commonly known as an _outpoint_.

By convention we write an outpoint as the TxID, a colon, and the output index number:

.A outpoint: identifying an output by TxID and index number
----
7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18:0
----

Output identifiers (outpoints) are the mechanisms that link transactions together in a chain. Every transaction input is a reference to a specific output of a previous transaction. That reference is an outpoint: a TxID and output index number. So a transaction "spends" a specific output (by index number) from a specific transaction (by TxID) to create new outputs that themselves can be spent by reference to the outpoint.

<<tx_chain_vout>> presents the chain of transactions from Alice to Bob to Chan to Dina, this time with outpoints in each of the inputs.

[[tx_chain_vout]]
.Transaction inputs refer to outpoints forming a chain
image::images/mtln_aa07.png["Transaction inputs refer to outpoints forming a chain"]

La entrada en la transacción de Bob hace referencia a la transacción de Alice (por TxID) y a la salida indexada 0.

La entrada en la transacción de Chan hace referencia al TxID de la transacción de Bob y a la primera salida indexada, porque el pago a Chan es la salida nº 1. En el pago de Bob a Chan, el cambio de Bob es la salida #0.footnote:[Recordemos que el cambio no tiene que ser la última salida en una transacción y de hecho es indistinguible de otras salidas].

Ahora, si miramos el pago de Alice a Bob, podemos ver que Alice está gastando un punto de salida que fue la tercera (índice de salida #2) salida en una transacción cuyo ID es 6a5f1b3[...]. No vemos esa transacción referenciada en el diagrama, pero podemos deducir estos detalles del punto de salida. 

=== Script de Bitcoin.

El último elemento de Bitcoin que se necesita para completar nuestra comprensión es el lenguaje de scripting que controla el acceso a los puntos de salida. Hasta ahora, hemos simplificado la descripción diciendo "Alice firma la transacción para pagar a Bob". Sin embargo, entre bastidores hay una complejidad oculta que permite implementar condiciones de gasto más complejas. La condición de gasto más sencilla y común es "presentar una firma que coincida con la siguiente clave pública". Una condición de gasto como ésta se registra en cada salida como _script de bloqueo_ escrito en un lenguaje de scripting llamado _Bitcoin Script_.

Bitcoin Script es un lenguaje de scripting basado en pila extremadamente simple. No contiene bucles ni recursividad y, por tanto, es _Turing incompleto_ (lo que significa que no puede expresar una complejidad arbitraria y tiene una ejecución predecible). Los que estén familiarizados con el (ya antiguo) lenguaje de programación FORTH reconocerán la sintaxis y el estilo.

==== Ejecutando el Script de Bitcoin.

En términos sencillos, el sistema Bitcoin evalúa Bitcoin Script ejecutando el script en una pila; si el resultado final es +TRUE+, considera la condición de gasto satisfecha y la transacción válida.

Veamos un ejemplo muy simple de Bitcoin Script, que suma los números 2 y 3 y luego compara el resultado con el número 5:

----
2 3 ADD 5 EQUAL
----

En <<figa08>>, vemos cómo se ejecuta este script (de izquierda a derecha).

[[figa08]]
.Example of Bitcoin Script execution
image::images/mtln_aa08.png["Example of Bitcoin Script execution"]

[role="pagebreak-before less_space"]
==== Bloqueo y desbloqueo de scripts.

El Script de Bitcoin se compone de dos partes:

Scripts de bloqueo:: Estos están incrustados en las salidas de las transacciones, estableciendo las condiciones que deben cumplirse para gastar esa salida. Por ejemplo, el monedero de Alice añade un script de bloqueo a la salida que paga a Bob, que establece la condición de que se requiere la firma de Bob para gastarlo.

Scripts de desbloqueo:: Están incrustados en las entradas de las transacciones, cumpliendo las condiciones establecidas por el script de bloqueo de la salida referenciada. Por ejemplo, Bob puede desbloquear la salida anterior proporcionando un script de desbloqueo que contenga una firma digital.

Utilizando un modelo simplificado, para la validación, el script de desbloqueo y el script de bloqueo se concatenan y se ejecutan (P2SH y SegWit son excepciones). Por ejemplo, si alguien bloqueara una salida de transacción con el script de bloqueo +"3 ADD 5 EQUAL "+, podríamos gastarlo con el script de desbloqueo "+2+" en una entrada de transacción. Cualquiera que valide esa transacción concatenaría nuestro script de desbloqueo (+2+) y el script de bloqueo (+3 ADD 5 EQUAL+) y ejecutaría el resultado a través del motor de ejecución de Bitcoin Script. Obtendrían +TRUE+ y podríamos gastar la salida.

Obviamente, este ejemplo simplificado sería una opción muy pobre para bloquear una salida real de Bitcoin porque no hay ningún secreto, sólo aritmética básica. Cualquiera podría gastar la salida proporcionando la respuesta "2". La mayoría de los scripts de bloqueo, por lo tanto, requieren demostrar el conocimiento de un secreto.

==== Bloqueo a una clave pública (firma).

La forma más simple de una secuencia de comandos de bloqueo es la que requiere una firma. Consideremos la transacción de Alice que paga a Bob 50.000 satoshis. La salida que Alice crea para pagar a Bob tendrá un script de bloqueo que requiere la firma de Bob y se vería así

[[bob_locking_script]]
.A locking script that requires a digital signature from Bob's private key
----
<Bob Public Key> CHECKSIG
----

El operador `CHECKSIG` toma dos elementos de la pila: una firma y una clave pública. Como puedes ver, la clave pública de Bob está en el script de bloqueo, así que lo que falta es la firma correspondiente a esa clave pública. Este script de bloqueo sólo puede ser gastado por Bob, porque sólo Bob tiene la correspondiente clave privada necesaria para producir una firma digital que coincida con la clave pública.

Para desbloquear esta secuencia de comandos de bloqueo, Bob proporcionaría una secuencia de comandos de desbloqueo que contenga únicamente su firma digital:

[[bob_unlocking_script]]
.An unlocking script containing (only) a digital signature from Bob's private key
----
<Bob Signature>
----

En <<locking_unlocking_chain>> se puede ver el script de bloqueo en la transacción de Alice (en la salida que paga a Bob) y el script de desbloqueo (en la entrada que gasta esa salida) en la transacción de Bob.

[[locking_unlocking_chain]]
.A transaction chain showing the locking script (output) and unlocking script (input)
image::images/mtln_aa09.png["A transaction chain showing the locking script (output) and unlocking script (input)"]

Para validar la transacción de Bob, un nodo de Bitcoin haría lo siguiente

. Extraer el script de desbloqueo de la entrada (+<Firma de Bob>+).
. Buscar el punto de salida que está intentando gastar (+a643e37...3213:0+). Esta es la transacción de Alice y se encontraría en el blockchain.
. Extrae el script de bloqueo de ese punto de salida (+<Bob PubKey> CHECKSIG+).
. Concatenar en un solo script, colocando el script de desbloqueo delante del script de bloqueo (+<Bob Signature> <Bob PubKey> CHECKSIG+).
. Ejecute este script en el motor de ejecución de Bitcoin Script para ver qué resultado se produce.
. Si el resultado es +TRUE+, deduzca que la transacción de Bob es válida porque fue capaz de cumplir la condición de gasto para gastar ese punto de salida.

==== Bloqueo a un Hash (Secreto).

Otro tipo de script de bloqueo, que se utiliza en la Lightning Network, es un _hashlock_. Para desbloquearlo, hay que conocer la _preimagen_ secreta del hash.

Para demostrar esto, hagamos que Bob genere un número aleatorio +R+ y lo mantenga en secreto:

----
R = 1833462189
----

[role="pagebreak-before"]
Ahora, Bob calcula el hash SHA-256 de este número:

----
H = SHA256(R) =>
H = SHA256(1833462189) =>
H = 0ffd8bea4abdb0deafd6f2a8ad7941c13256a19248a7b0612407379e1460036a
----

Ahora, Bob da el hash +H+ que calculamos anteriormente a Alice, pero mantiene el número +R+ en secreto. Recordemos que, debido a las propiedades de los hashes criptográficos, Alice no puede "invertir" el cálculo del hash y adivinar el número +R+.

Alice crea una salida pagando 50.000 satoshi con el script de bloqueo:

----
HASH256 H IGUAL
----

donde +H+ es el valor hash real (+0ffd8...036a+) que Bob le dio a Alice.

Vamos a explicar este script:

El operador +HASH256+ saca un valor de la pila y calcula el hash SHA-256 de ese valor. Luego empuja el resultado a la pila.

El valor +H+ se coloca en la pila, y luego el operador +EQUAL+ comprueba si los dos valores son iguales y coloca +TRUE+ o +FALSE+ en la pila.

Por lo tanto, esta secuencia de comandos de bloqueo sólo funcionará si se combina con una secuencia de comandos de desbloqueo que contenga +R+, de modo que cuando se concatena, tenemos:

----
R HASH256 H IGUAL
----

Sólo Bob conoce +R+, por lo que sólo Bob puede producir una transacción con un script de desbloqueo que revele el valor secreto +R+.

Curiosamente, Bob puede dar el valor +R+ a cualquier otra persona, que puede entonces gastar ese Bitcoin. Esto hace que el valor secreto +R+ sea casi como un "vale" de bitcoin, ya que cualquiera que lo tenga puede gastar la salida que creó Alice. ¡Veremos cómo esta es una propiedad útil para la Lightning Network!

[[multisig]]
==== Guiones multifirma.

Un acuerdo que requiere múltiples firmas para gastar Bitcoin se llama un _esquema de multifirma_, especificado además como un esquema _K-de-N_, donde:

* _N_ es el número total de firmantes identificados en el esquema de multifirma, y
* _K_ es el _quórum_ o _umbral_: el número mínimo de firmas para autorizar el gasto.

[role="pagebreak-before"]
El script para una multifirma __K__de-__N__ es:

----
K <PubKey1> <PubKey2> ... <PubKeyN> N CHECKMULTISIG
----

donde _N_ es el número total de claves públicas enumeradas (de la clave pública 1 a la clave pública _N_) y _K_ es el umbral de firmas necesarias para gastar la salida.

La Lightning Network utiliza un esquema de multifirma 2 de 2 para construir un payment channel. Por ejemplo, un payment channel entre Alice y Bob se construiría con una multifirma 2-de-2 como esta

----
2 <PubKey Alice> <PubKey Bob> 2 CHECKMULTISIG
----

La secuencia de comandos de bloqueo anterior puede satisfacerse con una secuencia de comandos de desbloqueo que contenga un par de firmas:footnote:[El primer argumento (0) no tiene ningún significado, pero es necesario debido a un error en la implementación de la multifirma de Bitcoin. Este problema se describe en _Mastering Bitcoin_, https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch07.asciidoc[Capítulo 7].]

----
0 <Sig Alice> <Sig Bob>
----
Los dos scripts juntos formarían el script de validación combinado:

----
0 <Sig Alice> <Sig Bob> 2 <PubKey Alice> <PubKey Bob> 2 CHECKMULTISIG
----

Un script de bloqueo multifirma puede ser representado por una dirección Bitcoin, codificando el hash del script de bloqueo. Por ejemplo, la funding transaction inicial de un payment channel Lightning es una transacción que paga a una dirección que codifica una secuencia de comandos de bloqueo de una multifirma de 2 de 2 de los dos socios del canal.

==== Scripts de bloqueo de tiempo.

Otro importante bloque de construcción que existe en Bitcoin y se utiliza ampliamente en la Lightning Network es un _timelock_. Un timelock es una restricción al gasto que requiere que haya transcurrido un cierto tiempo o altura de bloque antes de que se permita el gasto. Es un poco como un cheque posfechado de una cuenta bancaria que no puede ser cobrado antes de la fecha del cheque.

Bitcoin tiene dos niveles de timelocks: timelocks a nivel de transacción y timelocks a nivel de salida. 

Un _bloqueo a nivel de transacción_ se registra en el campo `nLockTime` de la transacción y evita que toda la transacción sea aceptada antes de que el bloqueo de tiempo haya pasado. Los bloqueos de tiempo a nivel de transacción son el mecanismo de bloqueo de tiempo más utilizado en Bitcoin hoy en día.

Un timelock a nivel de salida es creado por un operador de script. Hay dos tipos de timelocks de salida: timelocks absolutos y timelocks relativos.

Los timelocks absolutos a nivel de salida son implementados por el operador +CHECKLOCKTIMEVERIFY+, que a menudo se abrevia en la conversación como _CLTV_. Los timelocks absolutos implementan una restricción de tiempo con una marca de tiempo absoluta o altura de bloque, expresando el equivalente a "no gastar antes del bloque 800.000".

Los timelocks relativos a nivel de salida se implementan con el operador +CHECKSEQUENCEVERIFY+, a menudo abreviado en la conversación como _CSV_. Los timelocks relativos implementan una restricción de gasto que es relativa a la confirmación de la transacción, expresando el equivalente a "no se puede gastar hasta 1.024 bloques después de la confirmación."

[[conditional_scripts]]
==== Scripts con múltiples condiciones.

Una de las características más potentes de Bitcoin Script es el control de flujo, también conocido como cláusulas condicionales. Probablemente esté familiarizado con el control de flujo en varios lenguajes de programación que utilizan la construcción +IF...THEN...ELSE+. Las cláusulas condicionales de Bitcoin parecen un poco diferentes, pero son esencialmente la misma construcción.

At a basic level, bitcoin conditional opcodes allow us to construct a locking script that has two ways of being unlocked, depending on a +TRUE+/+FALSE+ outcome of evaluating a logical condition. For example, if x is +TRUE+, the locking script is A +ELSE+ the locking script is B.

Additionally, bitcoin conditional expressions can be _nested_ indefinitely, meaning that a conditional clause can contain another within it, which contains another, etc. Bitcoin Script flow control can be used to construct very complex scripts with hundreds or even thousands of possible execution paths. There is no limit to nesting, but consensus rules impose a limit on the maximum size, in bytes, of a script.

Bitcoin implements flow control using the +IF+, +ELSE+, +ENDIF+, and +NOTIF+ opcodes. Additionally, conditional expressions can contain boolean operators such as +BOOLAND+, <code>BOOLOR</code>, and +NOT+.

At first glance, you may find Bitcoin's flow control scripts confusing. Esto se debe a que Bitcoin Script es un lenguaje de pila. De la misma manera que la operación aritmética latexmath:[$1 + 1$] parece "hacia atrás" cuando se expresa en Bitcoin Script como +1 1 ADD+, las cláusulas de control de flujo en Bitcoin también parecen "hacia atrás".

En la mayoría de los lenguajes de programación tradicionales (procedimentales), el control de flujo tiene este aspecto:

.Pseudocode of flow control in most programming languages
----
if (condition):
  code to run when condition is true
else:
  code to run when condition is false
code to run in either case
----

En un lenguaje basado en la pila como Bitcoin Script, la condición lógica viene _antes_ del +IF+, lo que hace que se vea "al revés", así:

.Bitcoin Script flow control
----
condition
IF
  code to run when condition is true
ELSE
  code to run when condition is false
ENDIF
code to run in either case
----

Cuando lea Bitcoin Script, recuerde que la condición que se evalúa viene _antes_ del opcode +IF+.

==== Uso del control de flujo en los scripts.

Un uso muy común para el control de flujo en Bitcoin Script es construir un script de bloqueo que ofrezca múltiples caminos de ejecución, cada uno de ellos una forma diferente de redimir el UTXO.

Veamos un ejemplo sencillo, donde tenemos dos firmantes, Alice y Bob, y cualquiera de ellos puede canjear. Con multisig, esto se expresaría como una secuencia de comandos multisig 1-de-2. Para la demostración, haremos lo mismo con una cláusula +IF+:

----
IF
 <Alice's Pubkey> CHECKSIG
ELSE
 <Bob's Pubkey> CHECKSIG
ENDIF
----

Al ver esta secuencia de comandos de bloqueo, es posible que se pregunte: "¿Dónde está la condición? No hay nada que preceda a la cláusula +IF+".

La condición no forma parte del script de bloqueo. En su lugar, la condición será _ofrecida en el script de desbloqueo_, permitiendo a Alice y Bob "elegir" la ruta de ejecución que desean.

Alice redime esto con el script de desbloqueo:
----
<Alice's Sig> 1
----

El +1+ del final sirve como condición (+TRUE+) que hará que la cláusula +IF+ ejecute la primera ruta de canje para la que Alice tenga una firma.

Para que Bob lo canjee, tendría que elegir la segunda ruta de ejecución dando un valor +FALSE+ a la cláusula +IF+:

----
<Bob's Sig> 0
----

El script de desbloqueo de Bob pone un +0+ en la pila, haciendo que la cláusula +IF+ ejecute el segundo script (+ELSE+), que requiere la firma de Bob.

Como cada una de las dos condiciones también requiere una firma, Alice no puede usar la segunda cláusula y Bob no puede usar la primera cláusula; ¡no tienen las firmas necesarias para ello!

Dado que los flujos condicionales pueden anidarse, también lo pueden hacer los valores +TRUE+ / +FALSE+ en el script de desbloqueo, para recorrer un camino complejo de condiciones. 

En <<htlc_script_example>> puedes ver un ejemplo del tipo de script complejo que se utiliza en la Red Relámpago, con múltiples condiciones.footnote:[De https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md[BOLT #3]. Los scripts utilizados en la Red Relámpago están muy optimizados y son compactos, para minimizar la huella en la cadena, por lo que no son fáciles de leer y entender.

[[htlc_script_example]]
.A complex script used in the Lightning Network
====
----
# To remote node with revocation key
DUP HASH160 <RIPEMD160(SHA256(revocationpubkey))> EQUAL
IF
    CHECKSIG
ELSE
    <remote_htlcpubkey> SWAP SIZE 32 EQUAL
    NOTIF
        # To local node via HTLC-timeout transaction (timelocked).
        DROP 2 SWAP <local_htlcpubkey> 2 CHECKMULTISIG
    ELSE
        # To remote node with preimage.
        HASH160 <RIPEMD160(payment_hash)> EQUALVERIFY
        CHECKSIG
    ENDIF
ENDIF
----
====

[appendix]
[[appendix_docker]]
== Instalación y uso básico de Docker.

Este libro contiene una serie de ejemplos que se ejecutan dentro de contenedores Docker para su estandarización en diferentes sistemas operativos.

Esta sección te ayudará a instalar Docker y a familiarizarte con algunos de los comandos de Docker más utilizados, para que puedas ejecutar los contenedores de ejemplo del libro.


=== Instalación de Docker.

Antes de empezar, debes instalar el sistema de contenedores Docker en tu ordenador. Docker es un sistema abierto que se distribuye gratuitamente como _Community Edition_ para muchos sistemas operativos diferentes, incluyendo Windows, macOS y Linux. Las versiones para Windows y Macintosh se denominan _Docker Desktop_ y constan de una aplicación de escritorio con interfaz gráfica y herramientas de línea de comandos. La versión para Linux se llama _Docker Engine_ y consta de un demonio de servidor y herramientas de línea de comandos. Utilizaremos las herramientas de línea de comandos, que son idénticas en todas las plataformas.

Siga adelante e instale Docker para su sistema operativo siguiendo las instrucciones para "Obtener Docker" desde el https://docs.docker.com/get-docker[sitio web de Docker].

Selecciona tu sistema operativo de la lista y sigue las instrucciones de instalación.

[TIP]
====
Si lo instalas en Linux, sigue las instrucciones posteriores a la instalación para asegurarte de que puedes ejecutar Docker como un usuario normal en lugar de como usuario root. De lo contrario, tendrá que anteponer a todos los comandos +docker+ el prefijo +sudo+, ejecutándolos como root como +sudo docker+.
====

Una vez que tengas Docker instalado, puedes probar tu instalación ejecutando el contenedor de demostración +hello-world+ así:

[[docker-hello-world]]
----
$ docker run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

[...]
----

=== Comandos básicos de Docker.

En este apéndice, utilizamos Docker de forma bastante extensa. Utilizaremos los siguientes comandos y argumentos de Docker.

==== Construyendo un contenedor.

++++
<pre data-type="programlisting">docker build [-t <em>tag</em>] [<em>directory</em>]</pre>
++++

++__tag__++ es como identificamos el contenedor que estamos construyendo, y ++__directorio__++ es donde se encuentra el contexto del contenedor (carpetas y archivos) y el archivo de definición (+Dockerfile+).

==== Ejecutando un contenedor.

++++
<pre data-type="programlisting">docker run -it [--network <em>netname</em>] [--name <em>cname</em>] <em>tag</em></pre>
++++

++__netname__++ es el nombre de una red Docker, ++__cname__++ es el nombre que elegimos para esta instancia de contenedor, y ++__tag__++ es la etiqueta de nombre que le dimos al contenedor cuando lo construimos.

==== Ejecutando un comando en un contenedor.

++++
<pre data-type="programlisting">docker exec <em>cname command</em></pre>
++++

++__cname__++ es el nombre que le dimos al contenedor en el comando +run+, y ++__command__++ es un ejecutable o script que queremos ejecutar dentro del contenedor.

==== Detener e iniciar un contenedor.

En la mayoría de los casos, si estamos ejecutando un contenedor tanto en modo _interactivo_ como en modo _terminal_, es decir, con las banderas +i+ y +t+ (combinadas como +-it+) activadas, el contenedor puede detenerse simplemente pulsando Ctrl-C o saliendo del shell con +exit+ o Ctrl-D. Si un contenedor no termina, puedes detenerlo desde otra terminal de la siguiente manera:

++++
<pre data-type="programlisting">docker stop <em>cname</em></pre>
++++

Para reanudar un contenedor ya existente, utilice el comando `start` así:

++++
<pre data-type="programlisting">docker start <em>cname</em></pre>
++++

==== Eliminación de un contenedor por su nombre.

Si nombras un contenedor en lugar de dejar que Docker lo nombre al azar, no podrás reutilizar ese nombre hasta que el contenedor sea eliminado. Docker devolverá un error como este:

----
docker: Error response from daemon: Conflict. The container name "/bitcoind" is already in use...
----

Para solucionar esto, elimine la instancia existente del contenedor:

++++
<pre data-type="programlisting">docker rm <em>cname</em></pre>
++++

++__cname__++ es el nombre asignado al contenedor (+bitcoind+ en el mensaje de error del ejemplo).

==== Listado de contenedores en ejecución.

----
docker ps
----

Este comando muestra los contenedores en ejecución y sus nombres.

==== Listado de imágenes Docker.

----
docker image ls
----

Este comando muestra las imágenes Docker que han sido construidas o descargadas en tu ordenador.

=== Conclusión.

Estos comandos básicos de Docker serán suficientes para empezar y te permitirán ejecutar todos los ejemplos de este libro. 

[appendix]
[[sources_licenses]]
== Fuentes y avisos de licencia.

Este apéndice contiene avisos de atribución y licencia para el material incluido con permiso concedido a través de licencias abiertas.

=== Fuentes.

El material se ha obtenido de varias fuentes públicas y con licencia abierta:

* https://wiki.ion.radar.tech[ION Lightning Network Wiki]
* https://medium.com/suredbits/lightning-101-what-is-a-lightning-invoice-d527db1a77e6["Lightning 101: ¿Qué es una invoice Lightning?" por Suredbits]
* https://github.com/lightningnetwork/lightning-rfc[Lightning Network In-Progress Specifications GitHub]; Creative Commons Attribution (CC-BY 4.0)
* https://w.wiki/4QCL[Página de Wikipedia, "Elliptic-curve Diffie-Hellman"]
* https://w.wiki/4QCX[Página de Wikipedia, "Firma digital"]
* https://w.wiki/4QCb[Página de Wikipedia, "Función hash criptográfica"]
* https://w.wiki/4QCc[Página de Wikipedia, "Enrutamiento de cebolla"]
* https://w.wiki/4QCd[Wikimedia Commons, "Lightning Network Protocol Suite"]
* https://w.wiki/4QCf[Wikimedia Commons, "Introducción al protocolo de la Lightning Network y los fundamentos de la tecnología Lightning"]

[role="pagebreak-before less_space"]
=== Servidor BTCPay.

BTCPay Server https://github.com/btcpayserver/btcpayserver-media[logo, capturas de pantalla y otras imágenes] utilizadas con permiso bajo la licencia https://github.com/btcpayserver/btcpayserver-media/blob/master/LICENSE[MIT License]:

[quote]
____
Licencia MIT

Copyright (c) 2018 BTCPay Server

Por la presente se concede permiso, sin cargo alguno, a cualquier persona que obtenga una copia de este software y los archivos de documentación asociados (el "Software"), para comerciar con el Software sin restricciones, incluidos, sin limitación, los derechos de uso, copia, modificación, fusión, publicación, distribución, sublicencia y/o venta de copias del Software, y para permitir que las personas a las que se les proporciona el Software lo hagan, con sujeción a las siguientes condiciones:

El anterior aviso de copyright y este aviso de permiso se incluirán en todas las copias o partes sustanciales del Software.

EL SOFTWARE SE PROPORCIONA "TAL CUAL", SIN GARANTÍA DE NINGÚN TIPO, EXPRESA O
IMPLÍCITA, INCLUYENDO PERO SIN LIMITARSE A LAS GARANTÍAS DE COMERCIABILIDAD
IDONEIDAD PARA UN FIN DETERMINADO Y NO INFRACCIÓN. EN NINGÚN CASO LOS AUTORES
LOS AUTORES O LOS TITULARES DE LOS DERECHOS DE AUTOR SERÁN RESPONSABLES DE CUALQUIER RECLAMACIÓN, DAÑO U OTRA
RESPONSABILIDAD, YA SEA EN UNA ACCIÓN DE CONTRATO, AGRAVIO O DE OTRO TIPO, QUE SURJA DE,
O EN RELACIÓN CON EL SOFTWARE O EL USO U OTRAS OPERACIONES CON EL
SOFTWARE.
____

=== Lamassu Industries AG.

Las imágenes del https://lamassu.is/product/gaia[_Gaia_ Bitcoin ATM] que se ven en <<bitcoin-atm>> se utilizan con permiso de Lamassu Industries AG. El uso de estas imágenes no es una aprobación del producto o de la empresa, sino que se proporcionan como un ejemplo visual de un cajero automático de Bitcoin.

[appendix]
[[wire_protocol_enumeration]]
[[protocol_messages]]
[[messages]]
== Mensajes del Protocolo Wire.

Este apéndice enumera todos los tipos de mensajes actualmente definidos y utilizados en el protocolo P2P de Lightning. Además, se muestra la estructura de cada mensaje, agrupando los mensajes en agrupaciones lógicas basadas en los flujos del protocolo.

[NOTE]
====
Los mensajes del protocolo Lightning son extensibles y su estructura puede cambiar durante las actualizaciones de la red. Para obtener la información autorizada, consulte la última versión de los BOLT que se encuentra en https://github.com/lightningnetwork/lightning-rfc[repositorio GitHub Lightning-RFC].
==== 

=== Tipos de mensajes.

Los tipos de mensajes definidos actualmente se enumeran en <<apdx_message_types>>.

[[apdx_message_types]]
.Message types
[options="header"]
|===
| Type integer | Message name | Category
| 16  | `init`             |  Connection Establishment
| 17  | `error`             | Error Communication
| 18  | `ping`             | Connection Liveness
| 19  | `pong`             | Connection Liveness
| 32  | `open_channel`             |          Channel Funding
| 33  | `accept_channel`             |          Channel Funding
| 34  | `funding_created`             |          Channel Funding
| 35  | `funding_signed`             |          Channel Funding
| 36  | `funding_locked`             |          Channel Funding + Channel Operation
| 38  | `shutdown`             | Channel Closing
| 39  | `closing_signed`             |         Channel Closing
| 128 | `update_add_htlc`             |          Channel Operation
| 130 | `update_fulfill_hltc`             |          Channel Operation
| 131 | `update_fail_htlc`             |          Channel Operation
| 132 | `commit_sig`             |          Channel Operation
| 133 | `revoke_and_ack`             |          Channel Operation
| 134 | `update_fee`             |          Channel Operation
| 135 | `update_fail_malformed_htlc`             |          Channel Operation
| 136 | `channel_reestablish`             |         Channel Operation
| 256 | `channel_announcement`             |          Channel Announcement
| 257 | `node_announcement`             |          Channel Announcement
| 258 | `channel_update`             |          Channel Announcement
| 259 | `announce_signatures`             |          Channel Announcement
| 261 | `query_short_chan_ids`             |          Channel Graph Syncing
| 262 | `reply_short_chan_ids_end`             |          Channel Graph Syncing
| 263 | `query_channel_range`             |          Channel Graph Syncing
| 264 | `reply_channel_range`             |          Channel Graph Syncing
| 265 | `gossip_timestamp_range`             |          Channel Graph Syncing
|===

En <<message_types>>, el campo `Category` nos permite categorizar rápidamente un mensaje en base a su funcionalidad dentro del propio protocolo. En un nivel alto, colocamos un mensaje en uno de los ocho cubos (no exhaustivos) que incluyen:

Establecimiento de la conexión:: Se envía cuando se establece por primera vez una conexión peer-to-peer.
   se establece una conexión entre pares. También se utiliza para negociar el conjunto de características soportadas
   por una nueva conexión.

Comunicación de errores:: Utilizado por los pares para comunicar la ocurrencia de
   errores a nivel de protocolo.

Conexión: Utilizada por los pares para comprobar que una conexión de transporte
  de transporte sigue activa.

Financiación del canal:: Utilizado por los pares para crear un nuevo payment channel. Este proceso de
   proceso también se conoce como proceso de financiación del canal.

Operación del canal:: El acto de actualizar un determinado canal fuera de la cadena. Este
   incluye el envío y la recepción de pagos, así como el reenvío de pagos
   dentro de la red.

Anuncio del canal:: El proceso de anunciar un nuevo canal público a
   la red en general para que pueda ser utilizado con fines de enrutamiento.

Sincronización del gráfico del canal:: El proceso de descargar y verificar el gráfico del canal
  del canal.


Observe que los mensajes que pertenecen a la misma categoría suelen compartir también un _tipo de mensaje_ adyacente. Esto se hace a propósito para agrupar mensajes semánticamente similares dentro de la propia especificación.

=== Estructura de los mensajes.

Ahora detallamos cada categoría de mensaje para definir la estructura y semántica precisas de todos los mensajes definidos dentro del protocolo LN.

==== Mensajes de establecimiento de conexión.

Los mensajes de esta categoría son el primer mensaje que se envía entre pares una vez que establecen una conexión de transporte. En el momento de escribir este capítulo, sólo existe un único mensaje dentro de esta categoría, el mensaje `init`.
El mensaje `init` es enviado por _ambos_ lados de la conexión una vez que se ha establecido por primera vez. Ningún otro mensaje debe ser enviado antes de que el mensaje "init" haya sido enviado por ambas partes. 

[[apdx_init_message]]
===== El mensaje de init.

La estructura del mensaje `init` se define como sigue:

 * Tipo: 16
 * Campos:
    ** `uint16`: `global_features_len`
    ** `global_features_len*byte`: `global_features`
    ** `uint16`: `features_len`
    ** `features_len*byte`: `features`
    ** `tlv_stream_tlvs`

Estructuralmente, el mensaje `init` está compuesto por dos trozos de bytes de tamaño variable que almacenan cada uno un conjunto de _bits de características_. Como vemos en <<feature_bits>>, los bits de características son una primitiva utilizada dentro del protocolo para anunciar el conjunto de características del protocolo que un nodo entiende (características opcionales) o exige (características requeridas).

Tenga en cuenta que las implementaciones modernas de nodos sólo utilizarán el campo `features`, con elementos que residen en el vector `global_features` con fines principalmente _históricos_ (compatibilidad con versiones anteriores).

Lo que sigue después del mensaje principal es una serie de registros de tipo-longitud-valor (TLV) que pueden utilizarse para ampliar el mensaje de forma compatible con el futuro. Más adelante en este apéndice veremos qué son los registros TLV y cómo se utilizan.

Un mensaje `init` es examinado por un peer para determinar si la conexión está bien definida basándose en el conjunto de bits de características opcionales y requeridas anunciadas por ambas partes.

Una característica opcional significa que un par conoce una característica, pero no la considera crítica para el funcionamiento de una nueva conexión. Un ejemplo de ello sería algo como la capacidad de entender la semántica de un campo recién añadido a un mensaje existente.

Por otro lado, las características requeridas indican que si el otro par no conoce la característica, entonces la conexión no está bien definida. Un ejemplo de este tipo de característica sería un nuevo tipo de canal teórico dentro del protocolo: si tu compañero no conoce esta característica, entonces no querrás mantener la conexión porque no podrá abrir tu nuevo tipo de canal preferido.

==== Mensajes de comunicación de error.

Los mensajes de esta categoría se utilizan para enviar errores de nivel de conexión entre dos peers. Existe otro tipo de error en el protocolo: un error de nivel de reenvío HTLC. Los errores de nivel de conexión pueden señalar cosas como la incompatibilidad de bits de características o la intención de _forzar el cierre_ (emitir unilateralmente el último compromiso firmado).

[[apdx_error_message]]
===== El mensaje de error.

El único mensaje en esta categoría es el mensaje de `error`.

 * Tipo: 17
 * Campos:
  ** `channel_id` : `chan_id`
  ** `uint16` : `data_len`
  ** `data_len*byte` : `data`

Se puede enviar un mensaje de `error` dentro del ámbito de un canal en particular estableciendo el `channel_id` al `channel_id` del canal que está sufriendo este nuevo estado de error. Alternativamente, si el error se aplica a la conexión en general, entonces el campo `channel_id` debe ser puesto a todos los ceros. Este campo "all zero
también se conoce como el identificador de nivel de conexión para un error.

Dependiendo de la naturaleza del error, enviar un mensaje de `error` a un peer con el que se tiene un canal puede indicar que el canal no puede continuar sin intervención manual, por lo que la única opción en ese momento es forzar el cierre del canal emitiendo el último estado de compromiso del canal.

==== Liviandad de la conexión.

Se definen los mensajes `ping` y `pong`.

[[apdx_ping_message]]
===== El mensaje ping.

El mensaje `ping` se utiliza para comprobar si la otra parte de una conexión está "viva". Contiene los siguientes campos:

 * Tipo: 18
 * Campos:
  ** `uint16` : `num_pong_bytes`
  ** `uint16` : `ping_body_len`
  ** `ping_body_len*bytes` : `ping_body`

A continuación su compañero, el mensaje `pong`.

[[apdx_pong_message]]
===== El mensaje pong.

El mensaje +pong+ se envía en respuesta al mensaje +ping+ y contiene los siguientes campos:

 * Tipo: 19
 * Campos:
  ** `uint16` : `pong_body_len`
  ** `ping_body_len*bytes` : `pong_body`

Un mensaje `ping` puede ser enviado por cualquiera de las partes en cualquier momento.

El mensaje `ping` incluye un campo `num_pong_bytes` que se utiliza para indicar al nodo receptor el tamaño de la carga útil que envía en su mensaje `pong`. El mensaje `ping` también incluye un conjunto opaco de bytes `ping_body` que puede ser ignorado con seguridad. Sólo sirve para que el remitente pueda rellenar los mensajes `ping` que envía, lo que puede ser útil para intentar frustrar ciertas técnicas de desanonimización basadas en el tamaño de los paquetes en el cable.

Un mensaje `pong` debe ser enviado en respuesta a un mensaje `ping` recibido. El receptor debe leer un conjunto de `num_pong_bytes` aleatorios para enviar de vuelta como el campo
campo `pong_body`. El uso inteligente de estos campos/mensajes puede permitir que un nodo de enrutamiento consciente de la privacidad intente frustrar ciertas clases de intentos de desanonimización de la red porque puede crear una transcripción "falsa" que se parezca a otros mensajes basándose en los tamaños de los paquetes enviados. Recuerde que, por defecto, la Lightning Network utiliza un transporte _encriptado_, por lo que un monitor de red pasivo no puede leer los bytes de texto plano y, por lo tanto, sólo dispone de la temporización y el tamaño de los paquetes. 

==== Financiación del canal.

A medida que avanzamos, nos adentramos en el territorio de los mensajes centrales que rigen la funcionalidad y la semántica del protocolo Lightning. En esta sección, exploramos los mensajes enviados durante el proceso de creación de un nuevo canal. Sólo describiremos los campos utilizados, ya que dejamos el análisis en profundidad del proceso de financiación para <<payment_channels>>.

Los mensajes que se envían durante el flujo de financiación del canal pertenecen al siguiente conjunto de cinco mensajes: `open_channel`, `accept_channel`, `funding_created`,
`funding_signed` y `funding_locked`.

El flujo de protocolo detallado que utiliza estos mensajes se describe en <<payment_channels>>.

[[apdx_open_channel_message]]
===== El mensaje open_channel.

El mensaje +open_channel+ inicia el proceso de financiación del canal y contiene los siguientes campos:

 * Type: 32
 * Fields:
  ** `chain_hash` : `chain_hash`
  ** `32*byte` : `temp_chan_id`
  ** `uint64` : `funding_satoshis`
  ** `uint64` : `push_msat`
  ** `uint64` : `dust_limit_satoshis`
  ** `uint64` : `max_htlc_value_in_flight_msat`
  ** `uint64` : `channel_reserve_satoshis`
  ** `uint64` : `htlc_minimum_msat`
  ** `uint32` : `feerate_per_kw`
  ** `uint16` : `to_self_delay`
  ** `uint16` : `max_accepted_htlcs`
  ** `pubkey` : `funding_pubkey`
  ** `pubkey` : `revocation_basepoint`
  ** `pubkey` : `payment_basepoint`
  ** `pubkey` : `delayed_payment_basepoint`
  ** `pubkey` : `htlc_basepoint`
  ** `pubkey` : `first_per_commitment_point`
  ** `byte` : `channel_flags`
  ** `tlv_stream` : `tlvs`

Este es el primer mensaje que se envía cuando un nodo desea ejecutar un nuevo flujo de financiación con otro nodo. Este mensaje contiene toda la información necesaria para que ambos pares construyan tanto la funding transaction como la commitment transaction.

En el momento de redactar este capítulo, se define un único registro TLV dentro del conjunto de registros TLV opcionales que pueden añadirse al final de un mensaje definido:

 * Type: 0
 * Data:  `upfront_shutdown_script`

El `upfront_shutdown_script` es un trozo de byte de tamaño variable que debe ser una secuencia de comandos de clave pública válida aceptada por el algoritmo de consenso de la red Bitcoin. Al proporcionar dicha dirección, la parte que envía es capaz de crear efectivamente un "bucle cerrado" para su canal, ya que ninguna de las partes firmará una transacción de cierre cooperativo que pague a cualquier otra dirección. En la práctica, esta dirección suele ser una derivada de un monedero de cold storage.

El campo `channel_flags` es un campo de bits del que, en el momento de escribir esto, sólo el _primer_ bit tiene algún tipo de significado. Si este bit está activado, entonces este canal debe ser anunciado a la red pública como un canal enrutable. De lo contrario, el canal es considerado como no anunciado, también comúnmente referido como un private channel.

[[apdx_accept_channel_message]]
===== El mensaje accept_channel.

El mensaje `accept_channel` es la respuesta al mensaje `open_channel`.

[role="pagebreak-before"]
* Type: 33
 * Fields:
  ** `32*byte` : `temp_chan_id`
  ** `uint64` : `dust_limit_satoshis`
  ** `uint64` : `max_htlc_value_in_flight_msat`
  ** `uint64` : `channel_reserve_satoshis`
  ** `uint64` : `htlc_minimum_msat`
  ** `uint32` : `minimum_depth`
  ** `uint16` : `to_self_delay`
  ** `uint16` : `max_accepted_htlcs`
  ** `pubkey` : `funding_pubkey`
  ** `pubkey` : `revocation_basepoint`
  ** `pubkey` : `payment_basepoint`
  ** `pubkey` : `delayed_payment_basepoint`
  ** `pubkey` : `htlc_basepoint`
  ** `pubkey` : `first_per_commitment_point`
  ** `tlv_stream` : `tlvs`

El mensaje `accept_channel` es el segundo mensaje enviado durante el proceso de flujo de financiación. Sirve para reconocer la intención de abrir un canal con un nuevo peer remoto. El mensaje se hace eco principalmente del conjunto de parámetros que el respondedor desea aplicar a su versión de la commitment transaction. En <<payment_channels>>, cuando profundizamos en el proceso de financiación, exploramos las implicaciones de los distintos parámetros que se pueden establecer al abrir un nuevo canal.

[[apdx_funding_created_message]]
===== El mensaje funding_created.

En respuesta, el iniciador enviará el mensaje `funding_created`.

 * Type: 34
 * Fields:
  ** `32*byte` : `temp_chan_id`
  ** `32*byte` : `funding_txid`
  ** `uint16` : `funding_output_index`
  ** `sig` : `commit_sig`

Una vez que el iniciador de un canal recibe el mensaje `accept_channel` del respondedor, tiene todo el material que necesita para construir la commitment transaction, así como la funding transaction. Como los canales son por defecto de un solo financiador (sólo una parte compromete fondos), sólo el iniciador necesita construir la funding transaction. Como resultado, para permitir que el respondedor firme una versión de una commitment transaction para el iniciador, éste sólo necesita enviar el punto de salida de la financiación del canal. 

[[apdx_funding_signed_message]]
===== El mensaje funding_signed.

Para concluir, el respondedor envía el mensaje `funding_signed`.

 * Type: 34
 * Fields:
  ** `channel_id` : `channel_id`
  ** `sig` : `signature`

Para concluir, después de que el respondedor reciba el mensaje `funding_created`, ahora posee una firma válida de la commitment transaction por parte del iniciador. Con esta firma son capaces de salir del canal en cualquier momento firmando su mitad de la salida de financiación multisig y emitiendo la transacción. Esto se denomina cierre forzado. A la inversa, para dar al iniciador la posibilidad de cerrar el canal, el respondedor también firma la commitment transaction del iniciador.

Una vez que el iniciador ha recibido este mensaje, es seguro para ellos emitir la funding transaction porque ahora son capaces de salir del acuerdo del canal unilateralmente.

[[apdx_funding_locked_message]]
===== El mensaje funding_locked.

Una vez que la funding transaction ha recibido suficientes confirmaciones, el mensaje
mensaje `funding_locked`.

 * Type: 36
 * Fields:
  ** `channel_id` : `channel_id`
  ** `pubkey` : `next_per_commitment_point`

Una vez que la funding transaction obtiene un número de confirmaciones "mínimo", ambas partes deben enviar el mensaje "financiación bloqueada". Sólo después de que se haya recibido y enviado este mensaje se podrá empezar a utilizar el canal.

==== Cierre del canal.

El financiador del canal envía el primer mensaje `closing_signed`, y el otro lado puede aceptar enviando un mensaje `closing_signed` con los mismos valores de la tarifa.

[[apdx_shutdown_message]]
===== El mensaje de cierre.

El mensaje +shutdown+ inicia el proceso de cierre de un canal y contiene los siguientes campos:

 * Type: 38
 * Fields:
  ** `channel_id` : `channel_id`
  ** `u16` : `len`
  ** `len*byte` : `scriptpubkey`

[[apdx_closing_signed_message]]
===== El mensaje closing_signed.

El mensaje +closing_signed+ es enviado por cada socio del canal hasta que acuerdan las fees. Contiene los siguientes campos:

 * Type: 39
 * Fields:
  ** `channel_id` : `channel_id`
  ** `u64` : `fee_satoshis`
  ** `signature` : `signature`

==== Funcionamiento del canal.

En esta sección, describimos brevemente el conjunto de mensajes utilizados para permitir a los nodos operar un canal. Por operación, nos referimos a poder enviar, recibir y reenviar pagos para un canal dado.

Para enviar, recibir o reenviar un pago a través de un canal, primero se debe añadir un HTLC a las dos transacciones de compromiso que componen un enlace de canal.

[role="pagebreak-before less_space"]
[[apdx_update_add_htlc_message]]
===== El mensaje update_add_htlc.

El mensaje `update_add_htlc` permite a cualquiera de las partes añadir un nuevo HTLC a la commitment transaction opuesta.

 * Type: 128
 * Fields:
  ** `channel_id` : `channel_id`
  ** `uint64` : `id`
  ** `uint64` : `amount_msat`
  ** `sha256` : `payment_hash`
  ** `uint32` : `cltv_expiry`
  ** `1366*byte` : `onion_routing_packet`

El envío de este mensaje permite a una de las partes iniciar el envío de un nuevo pago o el reenvío de un pago existente que llegó a través de un canal de entrada. El mensaje especifica el importe (`amount_msat`) junto con el hash del pago que desbloquea el propio pago. El conjunto de instrucciones de reenvío del siguiente salto están encriptadas dentro del campo `onion_routing_packet`. En <<onion_routing>>, sobre el reenvío de HTLC de varios saltos, cubrimos en detalle el protocolo de enrutamiento de cebolla utilizado en la Lightning Network.

Tenga en cuenta que cada HTLC enviado utiliza un ID que se incrementa automáticamente y que es utilizado por cualquier mensaje que modifique un HTLC (liquidar o cancelar) para hacer referencia al HTLC de una manera única en el ámbito del canal.

[[apdx_update_fulfill_hltc_message]]
===== El mensaje update_fulfill_hltc.

El mensaje `update_fulfill_hltc` permite la redención (recepción) de un HTLC activo.

 * Type: 130
 * Fields:
  ** `channel_id` : `channel_id`
  ** `uint64` : `id`
  ** `32*byte` : `payment_preimage`

Este mensaje es enviado por el receptor de HTLC al proponente para canjear un HTLC activo. El mensaje hace referencia al `id` del HTLC en cuestión, y también proporciona la preimagen (que desbloquea el HLTC).

[[apdx_update_fail_htlc_message]]
===== El mensaje update_fail_htlc.

El mensaje `update_fail_htlc` se envía para eliminar un HTLC de una commitment transaction.

 * Type: 131
 * Fields:
  ** `channel_id` : `channel_id`
  ** `uint64` : `id`
  ** `uint16` : `len`
  ** `len*byte` : `reason`

El mensaje `update_fail_htlc` es el opuesto al mensaje `update_fulfill_hltc` ya que permite al receptor de un HTLC eliminar el mismo HTLC. Este mensaje se envía normalmente cuando un HTLC no puede ser enrutado correctamente hacia arriba y necesita ser enviado de vuelta al emisor para desenredar la cadena HTLC. Como exploramos en
<<failure_messages>>, el mensaje contiene una razón de fallo _encriptada_ (`reason`) que puede permitir al emisor ajustar su ruta de pago o terminar si el fallo en sí es terminal. 

[[apdx_commitment_signed_message]]
===== El mensaje commitment_signed.

El mensaje `commitment_signed` se utiliza para sellar la creación de una nueva commitment transaction.

 * Type: 132
 * Fields:
  ** `channel_id` : `channel_id`
  ** `sig` : `signature`
  ** `uint16` : `num_htlcs`
  ** `num_htlcs*sig` : `htlc_signature`

Además de enviar una firma para la siguiente commitment transaction, el remitente de este mensaje también necesita enviar una firma para cada HTLC que esté presente en la commitment transaction.

[role="pagebreak-before less_space"]
[[apdx_revoke_and_ack_message]]
===== El mensaje revoke_and_ack.

El mensaje `revoke_and_ack` se envía para revocar un compromiso fechado.

 * Type: 133
 * Fields:
  ** `channel_id` : `channel_id`
  ** `32*byte` : `per_commitment_secret`
  ** `pubkey` : `next_per_commitment_point`

Dado que la Lightning Network utiliza una commitment transaction de reemplazo por revocación, después de recibir una nueva commitment transaction a través del mensaje `commit_sig`, una parte debe revocar su compromiso anterior antes de poder recibir otro.
Al revocar una commitment transaction, el revocador también proporciona el siguiente punto de compromiso que se requiere para permitir que la otra parte le envíe un nuevo estado de compromiso.

[[apdx_update_fee_message]]
===== El mensaje update_fee.

El mensaje `update_fee` se envía para actualizar la tarifa en las transacciones de compromiso actuales.

 * Type: 134
 * Fields:
  ** `channel_id` : `channel_id`
  ** `uint32` : `feerate_per_kw`

Este mensaje sólo puede ser enviado por el iniciador del canal; ellos son los que pagarán la cuota de compromiso del canal mientras esté abierto.

[[apdx_update_fail_malformed_htlc_message]]
===== El mensaje update_fail_malformed_htlc.

El mensaje `update_fail_malformed_htlc` se envía para eliminar un HTLC corrupto.

 * Type: 135
 * Fields:
  ** `channel_id` : `channel_id`
  ** `uint64` : `id`
  ** `sha256` : `sha256_of_onion`
  ** `uint16` : `failure_code`

Este mensaje es similar al mensaje `update_fail_htlc`, pero rara vez se utiliza en la práctica. Como se mencionó anteriormente, cada HTLC lleva un paquete de enrutamiento cifrado de cebolla que también cubre la integridad de partes del propio HTLC. Si una parte recibe un paquete onion que de alguna manera ha sido corrompido en el camino, entonces no será capaz de descifrar el paquete. Como resultado, tampoco puede reenviar correctamente el HTLC; por lo tanto, enviará este mensaje para indicar que el HTLC se ha corrompido en algún punto de la ruta de vuelta al remitente.

==== Anuncio de canal.

Los mensajes de esta categoría se utilizan para anunciar los componentes de la estructura de datos autentificados del gráfico del canal a la red más amplia. El gráfico de canales tiene una serie de propiedades únicas debido a la condición de que todos los datos añadidos al gráfico de canales deben estar también anclados en la blockchain base de Bitcoin. Como resultado, para añadir una nueva entrada al grafo del canal, un agente debe ser una tasa de transacción en la cadena. Esto sirve como un elemento natural de disuasión de spam para la Lightning Network.


[[apdx_channel_announcement_message]]
===== El mensaje channel_announcement.

El mensaje `channel_announcement` se utiliza para anunciar un nuevo canal a toda la red.

 * Type: 256
 * Fields:
  ** `sig` : `node_signature_1`
  ** `sig` : `node_signature_2`
  ** `sig` : `bitcoin_signature_1`
  ** `sig` : `bitcoin_signature_2`
  ** `uint16` : `len`
  ** `len*byte` : `features`
  ** `chain_hash` : `chain_hash`
  ** `short_channel_id` : `short_channel_id`
  ** `pubkey` : `node_id_1`
  ** `pubkey` : `node_id_2`
  ** `pubkey` : `bitcoin_key_1`
  ** `pubkey` : `bitcoin_key_2`

La serie de firmas y claves públicas en el mensaje sirve para crear una
_prueba_ de que el canal existe realmente dentro de la blockchain base de Bitcoin. Como detallamos en <<scid>>, cada canal se identifica de forma única mediante un localizador que codifica su _ubicación_ dentro de la blockchain. Este localizador se llama `short_channel_id` y puede caber en un entero de 64 bits.

[[apdx_node_announcement_message]]
===== El mensaje de anuncio de nodo.

El mensaje `node_announcement` permite a un nodo anunciar/actualizar su vértice dentro del grafo del canal mayor.

 * Type: 257
 * Fields:
  ** `sig` : `signature`
  ** `uint64` : `flen`
  ** `flen*byte` : `features`
  ** `uint32` : `timestamp`
  ** `pubkey` : `node_id`
  ** `3*byte` : `rgb_color`
  ** `32*byte` : `alias`
  ** `uint16` : `addrlen`
  ** `addrlen*byte` : `addresses`

Ten en cuenta que si un nodo no tiene ningún canal anunciado dentro del grafo de canales, entonces este mensaje se ignora para asegurar que añadir un elemento al grafo de canales tiene un coste en la cadena. En este caso, el coste en la cadena será el coste de crear el canal al que está conectado este nodo.

Además de anunciar su conjunto de características, este mensaje también permite a un nodo anunciar/actualizar el conjunto de `direcciones de red` donde puede ser alcanzado. 

[[apdx_channel_update_message]]
===== El mensaje channel_update.

El mensaje `channel_update` se envía para actualizar las propiedades y políticas de un borde de canal activo dentro del gráfico de canales.

 * Type: 258
 * Fields:
  ** `signature` : `signature`
  ** `chain_hash` : `chain_hash`
  ** `short_channel_id` : `short_channel_id`
  ** `uint32` : `timestamp`
  ** `byte` : `message_flags`
  ** `byte` : `channel_flags`
  ** `uint16` : `cltv_expiry_delta`
  ** `uint64` : `htlc_minimum_msat`
  ** `uint32` : `fee_base_msat`
  ** `uint32` : `fee_proportional_millionths`
  ** `uint16` : `htlc_maximum_msat`

Además de poder habilitar/deshabilitar un canal, este mensaje permite a un nodo actualizar sus fees de enrutamiento, así como otros campos que conforman el tipo de pago que se permite fluir a través de este canal.

[[apdx_announce_signatures_message]]
===== El mensaje announce_signatures.

El mensaje `announce_signatures` es intercambiado por los pares del canal para reunir el conjunto de firmas necesarias para producir un mensaje `channel_announcement`.

 * Type: 259
 * Fields:
  ** `channel_id` : `channel_id`
  ** `short_channel_id` : `short_channel_id`
  ** `sig` : `node_signature`
  ** `sig` : `bitcoin_signature`

Después de enviar el mensaje `funding_locked`, si ambas partes desean anunciar su canal a la red, entonces cada una enviará el mensaje
mensaje `announce_signatures` que permite a ambas partes emplerar las cuatro firmas necesarias para generar un mensaje `announce_signatures`.

==== Sincronización del gráfico del canal.

Los nodos crean una perspectiva local del gráfico del canal utilizando cinco mensajes: +query_short_chan_ids+, +reply_short_chan_ids_end+, +query_channel_range+, +reply_channel_range+, y +gossip_timestamp_range+.

[[apdx_query_short_chan_ids_message]]
===== El mensaje query_short_chan_ids.

El mensaje `query_short_chan_ids` permite a un peer obtener la información del canal relacionada con una serie de IDs de canales cortos.

 * Type: 261
 * Fields:
  ** `chain_hash` : `chain_hash`
  ** `u16` : `len`
  ** `len*byte` : `encoded_short_ids`
  ** `query_short_channel_ids_tlvs` : `tlvs`

Como aprendemos en <<gossip>>, estos IDs de canal pueden ser una serie de canales que eran nuevos para el remitente o que estaban desactualizados, lo que permite al remitente obtener el último conjunto de información para un conjunto de canales.

[[apdx_reply_short_chan_ids_end_message]]
===== El mensaje reply_short_chan_ids_end.

El mensaje `reply_short_chan_ids_end` se envía después de que un peer termine de responder a un mensaje anterior `query_short_chan_ids`.

 * Type: 262
 * Fields:
  ** `chain_hash` : `chain_hash`
  ** `byte` : `full_information`

Este mensaje indica a la parte receptora que si desea enviar otro mensaje de consulta, puede hacerlo.

[[apdx_query_channel_range_message]]
===== El mensaje query_channel_range.

El mensaje `query_channel_range` permite a un nodo consultar el conjunto de canales abiertos dentro de un rango de bloques.

 * Type: 263
 * Fields:
  ** `chain_hash` : `chain_hash`
  ** `u32` : `first_blocknum`
  ** `u32` : `number_of_blocks`
  ** `query_channel_range_tlvs` : `tlvs`


Como los canales se representan utilizando un ID de canal corto que codifica la ubicación de un canal en la cadena, un nodo en la red puede utilizar una altura de bloque como una especie de _cursor_ para buscar a través de la cadena con el fin de descubrir un conjunto de canales recién abiertos.

[[apdx_reply_channel_range_message]]
===== El mensaje reply_channel_range.

El mensaje `reply_channel_range` es la respuesta al mensaje `query_channel_range` e incluye el conjunto de IDs de canales cortos para los canales conocidos dentro de ese rango.

 * Type: 264
 * Fields:
  ** `chain_hash` : `chain_hash`
  ** `u32` : `first_blocknum`
  ** `u32` : `number_of_blocks`
  ** `byte` : `sync_complete`
  ** `u16` : `len`
  ** `len*byte` : `encoded_short_ids`
  ** `reply_channel_range_tlvs` : `tlvs`

Como respuesta a `query_channel_range`, este mensaje devuelve el conjunto de canales que se abrieron dentro de ese rango. Este proceso puede repetirse con el solicitante avanzando su cursor más abajo en la cadena para continuar sincronizando el gráfico de canales.

[[apdx_gossip_timestamp_range_message]]
===== El mensaje gossip_timestamp_range.

El mensaje `gossip_timestamp_range` permite a un peer empezar a recibir nuevos mensajes de cotilleo entrantes en la red.

 * Type: 265
 * Fields:
  ** `chain_hash` : `chain_hash`
  ** `u32` : `first_timestamp`
  ** `u32` : `timestamp_range`

Una vez que un peer ha sincronizado el gráfico del canal, puede enviar este mensaje si desea recibir actualizaciones en tiempo real sobre los cambios en el gráfico del canal. También pueden establecer los campos `first_timestamp` y `timestamp_range` si desean recibir una acumulación de actualizaciones que pueden haber perdido mientras estaban 

[[failure_types_table]]
.Onion error failure types
[options="header"]
|===
| Type | Symbolic name | Meaning
| `PERM\|1` | +invalid_realm+ | The `realm` byte was not understood by the processing node
| `NODE\|2` | +temporary_node_failure+ | General temporary failure of the processing node
| `PERM\|NODE\|2` | +permanent_node_failure+ | General permanent failure of the processing node
| `PERM\|NODE\|3` | +required_node_fea&#x2060;ture_&#x200b;missing+ | The processing node has a required feature which was not in this onion
| `BADONION\|PERM\|4` | +invalid_onion_version+ | The `version` byte was not understood by the processing node
| `BADONION\|PERM\|5` | +invalid_onion_hmac+ | The HMAC of the onion was incorrect when it reached the processing node
| `BADONION\|PERM\|6` | +invalid_onion_key+ | The ephemeral key was unparsable by the processing node
| `UPDATE\|7` | +temporary_channel_&#x200b;fail&#x2060;ure+ | The channel from the processing node was unable to handle this HTLC,
but may be able to handle it, or others, later
| `PERM\|8` | +permanent_channel_&#x200b;fail&#x2060;ure+ | The channel from the processing node is unable to handle any HTLCs
| `PERM\|9` | +required_channel_&#x200b;fea&#x2060;ture_missing+ | The channel from the processing node requires features not present in
the onion
| `PERM\|10` | +unknown_next_peer+ | The onion specified a `short_channel_id` which doesn't match any
leading from the processing node
| `UPDATE\|11` | +amount_below_minimum+ | The HTLC amount was below the `htlc_minimum_msat` of the channel from
the processing node
| `UPDATE\|12` | +fee_insufficient+ | The fee amount was below that required by the channel from the
processing node
| `UPDATE\|13` | +incorrect_cltv_expiry+ | The `cltv_expiry` does not comply with the `cltv_expiry_delta` required by
the channel from the processing node
| `UPDATE\|14` | +expiry_too_soon+ | The CLTV expiry is too close to the current block height for safe
handling by the processing node
| `PERM\|15` | +incor&#x2060;rect_or_unknown_&#x200b;pay&#x2060;ment_details+ | The `payment_hash` is unknown to the final node, the `payment_secret` doesn't
match the `payment_hash`, the amount for that `payment_hash` is incorrect, or
the CLTV expiry of the HTLC is too close to the current block height for safe
handling
| `18` | +final_incor&#x2060;rect_&#x200b;cltv_expiry+ | The CLTV expiry in the HTLC doesn't match the value in the onion
| `19` | +final_incor&#x2060;rect_&#x200b;htlc_amount+ | The amount in the HTLC doesn't match the value in the onion
| `UPDATE\|20` | +channel_disabled+ | The channel from the processing node has been disabled
| `21` | +expiry_too_far+ | The CLTV expiry in the HTLC is too far in the future
| `PERM\|22` | +invalid_onion_payload+ | The decrypted onion per-hop payload was not understood by the processing node
or is incomplete
| `23` | +mpp_timeout+ | The complete amount of the multipart payment was not received within a
reasonable time
|===